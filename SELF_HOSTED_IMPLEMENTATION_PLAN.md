# Self-Hosted Implementation Plan

## Overview

This document outlines the complete implementation plan for adding self-hosted capabilities to Nectar while maintaining the existing SaaS offering. The approach ensures licensing control, prevents piracy, and creates a hybrid architecture where core functionality remains on our servers.

## Current State

- ✅ Marketing site separated (ports 5000/5001)
- ✅ Admin portal separated (ports 4000/4001)
- ✅ Customer app remains at root (ports 3000/3001)
- ✅ Basic Docker configurations created
- ✅ Clean separation working in development

## Business Requirements

### Dual Offering Model
1. **SaaS Version** (Current): Full-featured, cloud-hosted
2. **Self-Hosted Version**: Core features local, premium features require our APIs

### Licensing Control
- Must prevent unauthorized usage after license expiration
- Must track usage for billing/compliance
- Must allow instant remote disabling
- Must support tiered licensing (different feature sets)

### Architecture Goals
- Core business logic remains on our servers (anti-piracy)
- Customer data stays on their infrastructure (compliance)
- Seamless user experience regardless of deployment type
- Easy maintenance and updates

## Implementation Phases

---

## Phase 1: License Server Infrastructure

### 1.1 Create License Server Application

**Deliverables:**
- New Express.js application for license management
- JWT-based license key system
- Customer license database
- License validation API endpoints
- Admin interface for license management

**Files to Create:**
```
license-server/
├── package.json
├── server.js
├── models/
│   ├── License.js
│   ├── Customer.js
│   └── Usage.js
├── routes/
│   ├── validate.js
│   ├── admin.js
│   └── usage.js
├── middleware/
│   ├── auth.js
│   └── rateLimit.js
├── config/
│   └── database.js
└── migrations/
    ├── 001_licenses.sql
    ├── 002_customers.sql
    └── 003_usage_tracking.sql
```

**License Key Structure:**
```javascript
{
  "lic": "NECTAR-ENTERPRISE-2024", // License type
  "cid": "customer-uuid",          // Customer ID
  "exp": 1703980800,              // Expiration timestamp
  "feat": ["workflows", "analytics", "integrations"], // Features
  "limits": {
    "workflows_per_month": 10000,
    "users": 100,
    "storage_gb": 500
  },
  "iat": 1672444800,              // Issued at
  "domain_restrictions": ["company.com", "*.company.com"]
}
```

### 1.2 License Validation Endpoints

**API Endpoints:**
```
POST /api/validate
- Validates license key
- Returns feature permissions and limits
- Logs usage for tracking

POST /api/heartbeat
- Regular check-in from customer installations
- Updates last seen timestamp
- Validates ongoing license status

POST /api/usage
- Tracks feature usage
- Enforces monthly limits
- Returns usage statistics

GET /api/license/{customerId}
- Returns license details for customer
- Admin endpoint for support

POST /api/revoke
- Immediately revokes license
- Admin endpoint for cancellations
```

### 1.3 Customer License Database Schema

```sql
-- Customers table
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    company_name VARCHAR(255),
    plan_type VARCHAR(50) NOT NULL, -- 'starter', 'professional', 'enterprise'
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Licenses table
CREATE TABLE licenses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID REFERENCES customers(id),
    license_key TEXT UNIQUE NOT NULL,
    plan_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'suspended', 'expired', 'revoked'
    issued_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    domain_restrictions JSONB,
    feature_limits JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Usage tracking table
CREATE TABLE usage_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_id UUID REFERENCES licenses(id),
    feature VARCHAR(100) NOT NULL,
    usage_count INTEGER DEFAULT 1,
    usage_date DATE DEFAULT CURRENT_DATE,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Installation tracking
CREATE TABLE installations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_id UUID REFERENCES licenses(id),
    installation_id VARCHAR(255) UNIQUE NOT NULL, -- Generated by customer app
    domain VARCHAR(255),
    version VARCHAR(50),
    last_heartbeat TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW()
);
```

---

## Phase 2: Core API Service Layer

### 2.1 Create Nectar Cloud API Service

**Purpose:** Host essential business logic that self-hosted customers must use

**New Service Structure:**
```
nectar-cloud-api/
├── package.json
├── server.js
├── services/
│   ├── workflowEngine.js      // Core workflow execution
│   ├── aiAnalytics.js         // AI-powered insights
│   ├── integrationHub.js      // Third-party integrations
│   ├── advancedReports.js     // Complex reporting
│   └── collaborationEngine.js // Real-time collaboration
├── routes/
│   ├── workflows.js
│   ├── analytics.js
│   ├── integrations.js
│   └── reports.js
├── middleware/
│   ├── licenseAuth.js         // Validate license for each request
│   ├── usageTracking.js       // Track API usage
│   └── rateLimiting.js        // Enforce limits based on plan
└── models/
    ├── WorkflowExecution.js
    ├── AnalyticsJob.js
    └── IntegrationConfig.js
```

### 2.2 Essential Cloud Services Definition

**Workflow Engine Service:**
```javascript
// What stays on customer servers: Basic workflow builder, data storage
// What requires our API: Advanced execution, AI steps, external integrations

POST /api/workflows/execute
{
  "workflowId": "uuid",
  "nodes": [...], // Workflow definition
  "data": {...},  // Input data
  "customerId": "uuid",
  "licenseKey": "key"
}
```

**AI Analytics Service:**
```javascript
// What stays on customer servers: Basic charts, simple queries
// What requires our API: ML predictions, pattern recognition, recommendations

POST /api/analytics/insights
{
  "dataSet": {...},
  "analysisType": "predictive|pattern|recommendation",
  "licenseKey": "key"
}
```

**Integration Hub Service:**
```javascript
// What stays on customer servers: Basic API calls
// What requires our API: OAuth management, complex transformations, certified connectors

POST /api/integrations/salesforce/sync
POST /api/integrations/slack/notify
POST /api/integrations/stripe/invoice
```

### 2.3 License-Gated Feature Architecture

**Feature Categories:**
1. **Free Features** (Work offline): Basic CRUD, simple UI, local storage
2. **Licensed Features** (Require API): Advanced workflows, AI, integrations, collaboration
3. **Premium Features** (Higher tier plans): Enterprise integrations, advanced security, priority support

---

## Phase 3: Customer Application Modifications

### 3.1 Add License Integration to Customer App

**Environment Variables:**
```env
# Customer app .env
NECTAR_LICENSE_KEY=customer-license-key-here
NECTAR_CLOUD_API_URL=https://api.nectar.com
NECTAR_LICENSE_SERVER_URL=https://license.nectar.com
NECTAR_INSTALLATION_ID=auto-generated-uuid
NECTAR_DEPLOYMENT_TYPE=self-hosted  # or 'saas'
```

**License Client Service:**
```javascript
// customer-app/src/services/licenseClient.js
class LicenseClient {
  constructor() {
    this.licenseKey = process.env.NECTAR_LICENSE_KEY;
    this.installationId = this.getOrCreateInstallationId();
    this.validationCache = new Map();
    this.startHeartbeat();
  }

  async validateFeature(feature) {
    // Check cache first
    if (this.validationCache.has(feature)) {
      const cached = this.validationCache.get(feature);
      if (Date.now() - cached.timestamp < 5 * 60 * 1000) { // 5 min cache
        return cached.valid;
      }
    }

    try {
      const response = await fetch(`${process.env.NECTAR_LICENSE_SERVER_URL}/api/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          licenseKey: this.licenseKey,
          feature,
          installationId: this.installationId,
          domain: window.location.hostname
        })
      });

      const result = await response.json();

      // Cache result
      this.validationCache.set(feature, {
        valid: result.valid,
        timestamp: Date.now(),
        limits: result.limits
      });

      return result.valid;
    } catch (error) {
      console.warn('License validation failed:', error);
      // Fail open for network issues, but log for monitoring
      return true;
    }
  }

  startHeartbeat() {
    setInterval(async () => {
      try {
        await fetch(`${process.env.NECTAR_LICENSE_SERVER_URL}/api/heartbeat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            licenseKey: this.licenseKey,
            installationId: this.installationId,
            version: process.env.REACT_APP_VERSION
          })
        });
      } catch (error) {
        console.warn('Heartbeat failed:', error);
      }
    }, 60 * 60 * 1000); // Every hour
  }
}
```

### 3.2 Create Cloud API Client

**Cloud Services Client:**
```javascript
// customer-app/src/services/cloudApiClient.js
class CloudApiClient {
  constructor() {
    this.baseUrl = process.env.NECTAR_CLOUD_API_URL;
    this.licenseKey = process.env.NECTAR_LICENSE_KEY;
  }

  async executeWorkflow(workflow, data) {
    const response = await fetch(`${this.baseUrl}/api/workflows/execute`, {
      method: 'POST',
      headers: {
        'Authorization': `License ${this.licenseKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ workflow, data })
    });

    if (!response.ok) {
      if (response.status === 403) {
        throw new Error('License expired or invalid. Please contact support.');
      }
      if (response.status === 429) {
        throw new Error('Usage limit exceeded. Please upgrade your plan.');
      }
      throw new Error('Workflow execution failed');
    }

    return response.json();
  }

  async getAIInsights(dataSet, analysisType) {
    // Similar pattern for AI analytics
  }

  async syncIntegration(provider, action, data) {
    // Similar pattern for integrations
  }
}
```

### 3.3 Feature Gating Components

**License-Gated Component Wrapper:**
```javascript
// customer-app/src/components/common/LicenseGate.jsx
import React, { useState, useEffect } from 'react';
import { useLicense } from '../hooks/useLicense';

export const LicenseGate = ({
  feature,
  fallback = <div>Feature not available in your plan</div>,
  children
}) => {
  const { hasFeature, isLoading } = useLicense(feature);

  if (isLoading) {
    return <div>Checking license...</div>;
  }

  if (!hasFeature) {
    return fallback;
  }

  return children;
};

// Usage:
<LicenseGate feature="advanced-workflows">
  <AdvancedWorkflowBuilder />
</LicenseGate>
```

**Usage Tracking Hook:**
```javascript
// customer-app/src/hooks/useLicense.js
export const useLicense = (feature) => {
  const [hasFeature, setHasFeature] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [usage, setUsage] = useState(null);

  useEffect(() => {
    const checkLicense = async () => {
      setIsLoading(true);
      try {
        const licenseClient = new LicenseClient();
        const valid = await licenseClient.validateFeature(feature);
        setHasFeature(valid);
      } catch (error) {
        console.error('License check failed:', error);
        setHasFeature(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkLicense();
  }, [feature]);

  const trackUsage = async (action, metadata = {}) => {
    try {
      await fetch(`${process.env.NECTAR_LICENSE_SERVER_URL}/api/usage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          licenseKey: process.env.NECTAR_LICENSE_KEY,
          feature,
          action,
          metadata
        })
      });
    } catch (error) {
      console.warn('Usage tracking failed:', error);
    }
  };

  return { hasFeature, isLoading, usage, trackUsage };
};
```

---

## Phase 4: Distribution Strategy

### 4.1 Docker Image Building

**Customer App Dockerfile Optimization:**
```dockerfile
# customer-app/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Add license validation at startup
COPY scripts/validate-license.sh /docker-entrypoint.d/
RUN chmod +x /docker-entrypoint.d/validate-license.sh

EXPOSE 3000
```

**License Validation Script:**
```bash
#!/bin/sh
# scripts/validate-license.sh

if [ -z "$NECTAR_LICENSE_KEY" ]; then
  echo "ERROR: NECTAR_LICENSE_KEY environment variable is required"
  exit 1
fi

# Validate license key format
if ! echo "$NECTAR_LICENSE_KEY" | grep -E "^NECTAR-[A-Z]+-[0-9]{4}-[A-Z0-9]{8}$" > /dev/null; then
  echo "ERROR: Invalid license key format"
  exit 1
fi

# Test license server connectivity
if ! curl -f -s "$NECTAR_LICENSE_SERVER_URL/health" > /dev/null; then
  echo "WARNING: Cannot reach license server. Application may have limited functionality."
fi

echo "License validation complete"
```

### 4.2 Customer Distribution Package

**Create Distribution Builder:**
```javascript
// build-scripts/create-customer-package.js
const fs = require('fs-extra');
const path = require('path');

async function createCustomerPackage() {
  const packageDir = 'dist/customer-package';

  // Clean and create package directory
  await fs.remove(packageDir);
  await fs.ensureDir(packageDir);

  // Copy customer app files (excluding admin/marketing)
  await fs.copy('customer-app', packageDir, {
    filter: (src, dest) => {
      // Exclude sensitive files
      const excludePatterns = [
        /node_modules/,
        /\.git/,
        /\.env$/,
        /admin-frontend/,
        /marketing-site/,
        /license-server/
      ];

      return !excludePatterns.some(pattern => pattern.test(src));
    }
  });

  // Copy documentation
  await fs.copy('SELF_HOSTED_DEPLOYMENT.md', path.join(packageDir, 'README.md'));

  // Create customer-specific docker-compose
  const dockerCompose = `
version: '3.8'
services:
  nectar-frontend:
    image: nectar-registry.com/customer-frontend:latest
    ports:
      - "3000:3000"
    environment:
      - NECTAR_LICENSE_KEY=\${NECTAR_LICENSE_KEY}
      - NECTAR_CLOUD_API_URL=https://api.nectar.com
    depends_on:
      - nectar-backend

  nectar-backend:
    image: nectar-registry.com/customer-backend:latest
    ports:
      - "3001:3001"
    environment:
      - NECTAR_LICENSE_KEY=\${NECTAR_LICENSE_KEY}
      - NECTAR_CLOUD_API_URL=https://api.nectar.com
      - DATABASE_URL=\${DATABASE_URL}
    depends_on:
      postgres:
        condition: service_healthy

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: nectar_db
      POSTGRES_USER: nectar
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U nectar -d nectar_db"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
`;

  await fs.writeFile(path.join(packageDir, 'docker-compose.yml'), dockerCompose);

  console.log('Customer package created in:', packageDir);
}

createCustomerPackage().catch(console.error);
```

---

## Phase 5: Monitoring and Analytics

### 5.1 Usage Analytics Dashboard

**Admin Dashboard for License Management:**
```
admin-frontend/src/pages/
├── LicenseManagement.jsx      // View all customer licenses
├── UsageAnalytics.jsx         // Customer usage statistics
├── InstallationMonitor.jsx    // Active installations
└── RevenueTracking.jsx        // Self-hosted revenue metrics
```

**Key Metrics to Track:**
- Active installations per customer
- Feature usage patterns
- License expiration dates
- Usage vs. plan limits
- Revenue attribution (SaaS vs. self-hosted)

### 5.2 Automated License Management

**License Lifecycle Automation:**
```javascript
// license-server/services/automationService.js
class LicenseAutomationService {
  async processExpiringLicenses() {
    // Send warnings 30, 7, and 1 day before expiration
    const expiringLicenses = await this.getExpiringLicenses();

    for (const license of expiringLicenses) {
      await this.sendExpirationWarning(license);
    }
  }

  async processExpiredLicenses() {
    // Auto-suspend expired licenses
    const expiredLicenses = await this.getExpiredLicenses();

    for (const license of expiredLicenses) {
      await this.suspendLicense(license);
      await this.notifyCustomer(license);
    }
  }

  async processUsageLimits() {
    // Check customers approaching usage limits
    const nearLimitCustomers = await this.getCustomersNearLimits();

    for (const customer of nearLimitCustomers) {
      await this.sendUsageWarning(customer);
    }
  }
}
```

---

## Phase 6: Testing and Validation

### 6.1 Integration Testing

**Test Scenarios:**
1. **License Validation Flow**
   - Valid license with all features
   - Expired license behavior
   - Invalid license handling
   - Network failure graceful degradation

2. **Cloud API Integration**
   - Successful workflow execution
   - Rate limiting enforcement
   - Feature restriction validation
   - Error handling and fallbacks

3. **Usage Tracking**
   - Accurate usage measurement
   - Limit enforcement
   - Billing integration
   - Analytics accuracy

### 6.2 Security Testing

**Security Validation:**
1. License key tampering attempts
2. API endpoint unauthorized access
3. Rate limiting bypass attempts
4. Data encryption in transit
5. Customer data isolation

---

## Implementation Todo List

### License Server (4-6 weeks)
- [ ] Set up new Express.js license server project
- [ ] Design and implement license database schema
- [ ] Create license validation API endpoints
- [ ] Implement JWT-based license key system
- [ ] Build admin interface for license management
- [ ] Add usage tracking and analytics
- [ ] Implement automated license lifecycle management
- [ ] Set up monitoring and alerting
- [ ] Write comprehensive API documentation
- [ ] Deploy to production infrastructure

### Cloud API Service (6-8 weeks)
- [ ] Set up new cloud API service project
- [ ] Migrate workflow engine to cloud service
- [ ] Migrate AI analytics to cloud service
- [ ] Migrate integration hub to cloud service
- [ ] Implement license authentication middleware
- [ ] Add usage tracking and rate limiting
- [ ] Set up auto-scaling infrastructure
- [ ] Implement comprehensive logging
- [ ] Add performance monitoring
- [ ] Write API documentation

### Customer App Integration (3-4 weeks)
- [ ] Add license client service to customer app
- [ ] Implement cloud API client
- [ ] Create license-gated UI components
- [ ] Add feature usage tracking
- [ ] Implement graceful fallbacks for offline scenarios
- [ ] Update environment configuration
- [ ] Add license validation to startup process
- [ ] Create user-friendly error messages
- [ ] Update documentation
- [ ] Add comprehensive testing

### Distribution System (2-3 weeks)
- [ ] Create Docker image build automation
- [ ] Set up private Docker registry
- [ ] Build customer package creation scripts
- [ ] Create license-locked docker-compose templates
- [ ] Implement secure distribution portal
- [ ] Set up customer onboarding automation
- [ ] Create installation validation scripts
- [ ] Build customer support documentation
- [ ] Test full distribution workflow
- [ ] Set up customer feedback collection

### Admin Portal Updates (2-3 weeks)
- [ ] Add license management interface
- [ ] Create usage analytics dashboard
- [ ] Implement installation monitoring
- [ ] Add revenue tracking for self-hosted
- [ ] Create customer support tools
- [ ] Add automated notification system
- [ ] Implement customer communication tools
- [ ] Create compliance reporting
- [ ] Add security monitoring
- [ ] Update admin user permissions

### Testing and Launch (3-4 weeks)
- [ ] Comprehensive integration testing
- [ ] Security penetration testing
- [ ] Performance and load testing
- [ ] Customer pilot program
- [ ] Documentation finalization
- [ ] Support team training
- [ ] Launch marketing materials
- [ ] Pricing and packaging finalization
- [ ] Go-to-market strategy execution
- [ ] Post-launch monitoring and optimization

## Success Metrics

### Technical Metrics
- 99.9% license server uptime
- <100ms license validation response time
- Zero unauthorized feature access
- <1% customer installation failures

### Business Metrics
- 15%+ of customers choose self-hosted option
- 90%+ customer satisfaction with deployment process
- <5% license-related support tickets
- 25%+ higher ARPU for self-hosted customers

## Risk Mitigation

### Technical Risks
- **License server downtime**: Implement redundancy and graceful degradation
- **API performance issues**: Auto-scaling and caching strategies
- **Customer installation failures**: Comprehensive testing and support documentation

### Business Risks
- **Customer resistance to cloud dependencies**: Clear communication about hybrid benefits
- **Competitive pressure**: Faster time-to-market through phased approach
- **Support burden**: Automation and self-service tools

## Timeline Summary

- **Phase 1 (License Server)**: Weeks 1-6
- **Phase 2 (Cloud API)**: Weeks 4-12 (parallel with Phase 1)
- **Phase 3 (Customer App)**: Weeks 8-12
- **Phase 4 (Distribution)**: Weeks 10-13
- **Phase 5 (Monitoring)**: Weeks 12-15
- **Phase 6 (Testing)**: Weeks 13-16
- **Launch**: Week 16

**Total Timeline: 16 weeks to full production launch**

This plan ensures a robust, secure, and profitable self-hosted offering while maintaining complete control over your intellectual property and customer relationships.