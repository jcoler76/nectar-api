# Cursor AI Rules for Nectar API Platform
# Enhanced context and intelligent code suggestions for modern full-stack development

## Project Context
You are working on the Nectar API platform, a modern business application platform with React frontend, Node.js backend, and PostgreSQL database using Prisma ORM. The system provides API management, workflow automation, and business intelligence features.

## Key Architecture Components
- **Frontend**: React 18 with ShadCN UI components and Tailwind CSS
- **Backend**: Node.js with Express, Prisma ORM, and PostgreSQL
- **Database**: PostgreSQL with Prisma schema management
- **Authentication**: JWT with refresh tokens and role-based access control
- **API**: RESTful APIs with procedure-based endpoints
- **Workflows**: Custom workflow engine with node-based execution
- **File Storage**: Secure file management with organization-based access

## Core Business Entities
### Customer Entity
- Primary focus: Customer relationship management and contact tracking
- Key operations: Customer CRUD, contact management, relationship tracking

### Invoice Entity
- Primary focus: Billing, accounts receivable, payment tracking
- Key operations: Invoice generation, payment processing, financial reporting

### Contract Entity
- Primary focus: Sales contracts and opportunity management
- Key operations: Contract lifecycle, sales pipeline tracking

### Workflow Entity
- Primary focus: Business process automation
- Key operations: Workflow execution, node management, trigger handling

### Organization Entity
- Primary focus: Multi-tenant organization management
- Key operations: Organization setup, user management, role assignment

## Development Patterns

### Database Operations
Use Prisma ORM for type-safe database operations:

```javascript
// ✅ CORRECT: Use Prisma client with proper error handling
import { PrismaClient } from './prisma/generated/client';
const prisma = new PrismaClient();

// ✅ CORRECT: Type-safe queries with relationships
const customers = await prisma.customer.findMany({
  include: {
    organization: true,
    invoices: {
      where: { status: 'active' }
    }
  }
});

// ✅ CORRECT: Transaction handling for complex operations
const result = await prisma.$transaction(async (tx) => {
  const customer = await tx.customer.create({ data: customerData });
  const invoice = await tx.invoice.create({
    data: { ...invoiceData, customerId: customer.id }
  });
  return { customer, invoice };
});
```

### API Development
Follow RESTful patterns with proper error handling:

```javascript
// ✅ CORRECT: Proper route structure with middleware
router.get('/api/v1/:orgSlug/_proc/:procedureName',
  authMiddleware,
  organizationMiddleware,
  async (req, res) => {
    try {
      const { orgSlug, procedureName } = req.params;
      const result = await procedureService.execute(procedureName, req.body);
      res.json({ success: true, data: result });
    } catch (error) {
      logger.error('Procedure execution failed', { error: error.message, procedureName });
      res.status(500).json({ success: false, error: error.message });
    }
  }
);

// ✅ CORRECT: Input validation with proper sanitization
const { body, validationResult } = require('express-validator');

router.post('/api/customers', [
  body('name').notEmpty().trim().escape(),
  body('email').isEmail().normalizeEmail(),
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  // Process validated data
});
```

### Frontend Development
Use React 18 with ShadCN UI components:

```jsx
// ✅ CORRECT: Modern React with hooks and proper error boundaries
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

const CustomerList = () => {
  const [customers, setCustomers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        const response = await fetch('/api/customers');
        const data = await response.json();
        setCustomers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchCustomers();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <Card>
      <CardHeader>
        <CardTitle>Customers</CardTitle>
      </CardHeader>
      <CardContent>
        {customers.map(customer => (
          <div key={customer.id}>{customer.name}</div>
        ))}
      </CardContent>
    </Card>
  );
};
```

### Authentication & Authorization
Implement secure authentication patterns:

```javascript
// ✅ CORRECT: JWT token management with refresh
const authService = {
  async login(credentials) {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(credentials)
    });

    if (!response.ok) {
      throw new Error('Authentication failed');
    }

    const { accessToken, user } = await response.json();
    localStorage.setItem('accessToken', accessToken);
    return { user };
  },

  async refreshToken() {
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      credentials: 'include'
    });

    if (response.ok) {
      const { accessToken } = await response.json();
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    }

    throw new Error('Token refresh failed');
  }
};
```

## File Structure Understanding
```
nectar-api/
├── src/                           # React frontend
│   ├── components/
│   │   ├── ui/                    # ShadCN UI components
│   │   ├── auth/                  # Authentication components
│   │   ├── customers/             # Customer management
│   │   ├── workflows/             # Workflow management
│   │   └── common/                # Shared components
│   ├── hooks/                     # Custom React hooks
│   ├── context/                   # React context providers
│   └── utils/                     # Frontend utilities
├── server/                        # Node.js backend
│   ├── controllers/               # Request handlers
│   ├── middleware/                # Express middleware
│   ├── models/                    # Data models (if needed)
│   ├── routes/                    # API routes
│   ├── services/                  # Business logic
│   ├── utils/                     # Backend utilities
│   ├── prisma/                    # Database schema and migrations
│   └── server.js                  # Main server file
└── docs/                          # API documentation
```

## Development Guidelines

### Code Quality
1. **Type Safety**: Use TypeScript where possible, leverage Prisma types
2. **Error Handling**: Implement comprehensive error boundaries and try-catch blocks
3. **Validation**: Validate all inputs on both frontend and backend
4. **Security**: Sanitize inputs, use parameterized queries, implement CSRF protection
5. **Performance**: Use React.memo, useCallback, and useMemo appropriately

### API Design
1. **RESTful Structure**: Follow REST conventions for resource endpoints
2. **Procedure Endpoints**: Use `/_proc/` pattern for business logic procedures
3. **Error Responses**: Consistent error response format with proper HTTP status codes
4. **Rate Limiting**: Implement rate limiting for API endpoints
5. **Documentation**: Use OpenAPI/Swagger for API documentation

### Database Operations
1. **Prisma First**: Use Prisma for all database operations
2. **Transactions**: Use transactions for multi-step operations
3. **Relationships**: Leverage Prisma relationships for data fetching
4. **Migrations**: Use Prisma migrations for schema changes
5. **Performance**: Use appropriate indexes and query optimization

## Security Best Practices
- Always validate and sanitize user inputs
- Use parameterized queries to prevent SQL injection
- Implement proper authentication and authorization
- Use HTTPS in production
- Sanitize data before logging
- Implement rate limiting and CSRF protection
- Use secure session management
- Regular security audits and dependency updates

## Performance Considerations
- Use React.memo for expensive components
- Implement proper caching strategies
- Optimize database queries with proper indexes
- Use connection pooling for database connections
- Implement proper loading states and error boundaries
- Use code splitting for large applications

## Error Handling
- Implement comprehensive error boundaries in React
- Use proper try-catch blocks in async operations
- Provide meaningful error messages to users
- Log errors appropriately for debugging
- Implement fallback UI states for error conditions

## AI Assistant Optimization
When generating code:
1. Use modern React patterns (hooks, functional components)
2. Implement proper TypeScript types when applicable
3. Include proper error handling and validation
4. Use ShadCN UI components for consistent design
5. Follow security best practices
6. Include proper testing patterns
7. Use Prisma for all database operations
8. Implement proper authentication and authorization

This system provides comprehensive guidance for developing modern, secure, and maintainable business applications with React, Node.js, and PostgreSQL.