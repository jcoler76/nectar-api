/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Organization
 *
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Membership
 *
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>;
/**
 * Model Invitation
 *
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>;
/**
 * Model EmailVerificationToken
 *
 */
export type EmailVerificationToken =
  $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>;
/**
 * Model BillingEvent
 *
 */
export type BillingEvent = $Result.DefaultSelection<Prisma.$BillingEventPayload>;
/**
 * Model Subscription
 *
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>;
/**
 * Model Invoice
 *
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>;
/**
 * Model DatabaseConnection
 *
 */
export type DatabaseConnection = $Result.DefaultSelection<Prisma.$DatabaseConnectionPayload>;
/**
 * Model Endpoint
 *
 */
export type Endpoint = $Result.DefaultSelection<Prisma.$EndpointPayload>;
/**
 * Model ApiKey
 *
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>;
/**
 * Model UsageMetric
 *
 */
export type UsageMetric = $Result.DefaultSelection<Prisma.$UsageMetricPayload>;
/**
 * Model Workflow
 *
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>;
/**
 * Model WorkflowExecution
 *
 */
export type WorkflowExecution = $Result.DefaultSelection<Prisma.$WorkflowExecutionPayload>;
/**
 * Model Webhook
 *
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model Service
 *
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>;
/**
 * Model Application
 *
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model ApiActivityLog
 *
 */
export type ApiActivityLog = $Result.DefaultSelection<Prisma.$ApiActivityLogPayload>;
/**
 * Model DatabaseObject
 *
 */
export type DatabaseObject = $Result.DefaultSelection<Prisma.$DatabaseObjectPayload>;
/**
 * Model ExposedEntity
 *
 */
export type ExposedEntity = $Result.DefaultSelection<Prisma.$ExposedEntityPayload>;
/**
 * Model ExposedFieldPolicy
 *
 */
export type ExposedFieldPolicy = $Result.DefaultSelection<Prisma.$ExposedFieldPolicyPayload>;
/**
 * Model ExposedRowPolicy
 *
 */
export type ExposedRowPolicy = $Result.DefaultSelection<Prisma.$ExposedRowPolicyPayload>;
/**
 * Model TermsAndConditions
 *
 */
export type TermsAndConditions = $Result.DefaultSelection<Prisma.$TermsAndConditionsPayload>;
/**
 * Model TermsAcceptance
 *
 */
export type TermsAcceptance = $Result.DefaultSelection<Prisma.$TermsAcceptancePayload>;
/**
 * Model RateLimitConfig
 *
 */
export type RateLimitConfig = $Result.DefaultSelection<Prisma.$RateLimitConfigPayload>;
/**
 * Model RateLimitUsage
 *
 */
export type RateLimitUsage = $Result.DefaultSelection<Prisma.$RateLimitUsagePayload>;
/**
 * Model SocialAccount
 *
 */
export type SocialAccount = $Result.DefaultSelection<Prisma.$SocialAccountPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const ExposedEntityType: {
    TABLE: 'TABLE';
    VIEW: 'VIEW';
  };

  export type ExposedEntityType = (typeof ExposedEntityType)[keyof typeof ExposedEntityType];

  export const MemberRole: {
    OWNER: 'OWNER';
    ADMIN: 'ADMIN';
    MEMBER: 'MEMBER';
    VIEWER: 'VIEWER';
  };

  export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole];

  export const SubscriptionPlan: {
    FREE: 'FREE';
    STARTER: 'STARTER';
    PROFESSIONAL: 'PROFESSIONAL';
    BUSINESS: 'BUSINESS';
    ENTERPRISE: 'ENTERPRISE';
  };

  export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan];

  export const SubscriptionStatus: {
    TRIALING: 'TRIALING';
    ACTIVE: 'ACTIVE';
    PAST_DUE: 'PAST_DUE';
    CANCELED: 'CANCELED';
    UNPAID: 'UNPAID';
  };

  export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus];

  export const InvoiceStatus: {
    PENDING: 'PENDING';
    PAID: 'PAID';
    FAILED: 'FAILED';
    CANCELED: 'CANCELED';
  };

  export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus];

  export const DatabaseType: {
    POSTGRESQL: 'POSTGRESQL';
    MYSQL: 'MYSQL';
    MARIADB: 'MARIADB';
    MSSQL: 'MSSQL';
    MONGODB: 'MONGODB';
    REDIS: 'REDIS';
    SUPABASE: 'SUPABASE';
    SNOWFLAKE: 'SNOWFLAKE';
    BIGQUERY: 'BIGQUERY';
    DYNAMODB: 'DYNAMODB';
  };

  export type DatabaseType = (typeof DatabaseType)[keyof typeof DatabaseType];

  export const HttpMethod: {
    GET: 'GET';
    POST: 'POST';
    PUT: 'PUT';
    PATCH: 'PATCH';
    DELETE: 'DELETE';
  };

  export type HttpMethod = (typeof HttpMethod)[keyof typeof HttpMethod];

  export const ExecutionStatus: {
    PENDING: 'PENDING';
    RUNNING: 'RUNNING';
    SUCCESS: 'SUCCESS';
    FAILED: 'FAILED';
    CANCELED: 'CANCELED';
  };

  export type ExecutionStatus = (typeof ExecutionStatus)[keyof typeof ExecutionStatus];

  export const NotificationType: {
    SYSTEM: 'SYSTEM';
    WORKFLOW: 'WORKFLOW';
    SECURITY: 'SECURITY';
    USER_MESSAGE: 'USER_MESSAGE';
  };

  export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType];

  export const NotificationPriority: {
    HIGH: 'HIGH';
    MEDIUM: 'MEDIUM';
    LOW: 'LOW';
  };

  export type NotificationPriority =
    (typeof NotificationPriority)[keyof typeof NotificationPriority];

  export const AcceptanceMethod: {
    CLICK: 'CLICK';
    SCROLL: 'SCROLL';
    SIGNATURE: 'SIGNATURE';
  };

  export type AcceptanceMethod = (typeof AcceptanceMethod)[keyof typeof AcceptanceMethod];

  export const RateLimitType: {
    API: 'API';
    AUTH: 'AUTH';
    UPLOAD: 'UPLOAD';
    GRAPHQL: 'GRAPHQL';
    WEBSOCKET: 'WEBSOCKET';
    CUSTOM: 'CUSTOM';
  };

  export type RateLimitType = (typeof RateLimitType)[keyof typeof RateLimitType];

  export const RateLimitKeyStrategy: {
    IP: 'IP';
    USER_ID: 'USER_ID';
    API_KEY: 'API_KEY';
    SESSION: 'SESSION';
    CUSTOM: 'CUSTOM';
  };

  export type RateLimitKeyStrategy =
    (typeof RateLimitKeyStrategy)[keyof typeof RateLimitKeyStrategy];
}

export type ExposedEntityType = $Enums.ExposedEntityType;

export const ExposedEntityType: typeof $Enums.ExposedEntityType;

export type MemberRole = $Enums.MemberRole;

export const MemberRole: typeof $Enums.MemberRole;

export type SubscriptionPlan = $Enums.SubscriptionPlan;

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan;

export type SubscriptionStatus = $Enums.SubscriptionStatus;

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus;

export type InvoiceStatus = $Enums.InvoiceStatus;

export const InvoiceStatus: typeof $Enums.InvoiceStatus;

export type DatabaseType = $Enums.DatabaseType;

export const DatabaseType: typeof $Enums.DatabaseType;

export type HttpMethod = $Enums.HttpMethod;

export const HttpMethod: typeof $Enums.HttpMethod;

export type ExecutionStatus = $Enums.ExecutionStatus;

export const ExecutionStatus: typeof $Enums.ExecutionStatus;

export type NotificationType = $Enums.NotificationType;

export const NotificationType: typeof $Enums.NotificationType;

export type NotificationPriority = $Enums.NotificationPriority;

export const NotificationPriority: typeof $Enums.NotificationPriority;

export type AcceptanceMethod = $Enums.AcceptanceMethod;

export const AcceptanceMethod: typeof $Enums.AcceptanceMethod;

export type RateLimitType = $Enums.RateLimitType;

export const RateLimitType: typeof $Enums.RateLimitType;

export type RateLimitKeyStrategy = $Enums.RateLimitKeyStrategy;

export const RateLimitKeyStrategy: typeof $Enums.RateLimitKeyStrategy;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Memberships
   * const memberships = await prisma.membership.findMany()
   * ```
   */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Invitations
   * const invitations = await prisma.invitation.findMany()
   * ```
   */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more EmailVerificationTokens
   * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
   * ```
   */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingEvent`: Exposes CRUD operations for the **BillingEvent** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more BillingEvents
   * const billingEvents = await prisma.billingEvent.findMany()
   * ```
   */
  get billingEvent(): Prisma.BillingEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscription.findMany()
   * ```
   */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Invoices
   * const invoices = await prisma.invoice.findMany()
   * ```
   */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseConnection`: Exposes CRUD operations for the **DatabaseConnection** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DatabaseConnections
   * const databaseConnections = await prisma.databaseConnection.findMany()
   * ```
   */
  get databaseConnection(): Prisma.DatabaseConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endpoint`: Exposes CRUD operations for the **Endpoint** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Endpoints
   * const endpoints = await prisma.endpoint.findMany()
   * ```
   */
  get endpoint(): Prisma.EndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApiKeys
   * const apiKeys = await prisma.apiKey.findMany()
   * ```
   */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageMetric`: Exposes CRUD operations for the **UsageMetric** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UsageMetrics
   * const usageMetrics = await prisma.usageMetric.findMany()
   * ```
   */
  get usageMetric(): Prisma.UsageMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Workflows
   * const workflows = await prisma.workflow.findMany()
   * ```
   */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowExecution`: Exposes CRUD operations for the **WorkflowExecution** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WorkflowExecutions
   * const workflowExecutions = await prisma.workflowExecution.findMany()
   * ```
   */
  get workflowExecution(): Prisma.WorkflowExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Webhooks
   * const webhooks = await prisma.webhook.findMany()
   * ```
   */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Applications
   * const applications = await prisma.application.findMany()
   * ```
   */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiActivityLog`: Exposes CRUD operations for the **ApiActivityLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApiActivityLogs
   * const apiActivityLogs = await prisma.apiActivityLog.findMany()
   * ```
   */
  get apiActivityLog(): Prisma.ApiActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseObject`: Exposes CRUD operations for the **DatabaseObject** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DatabaseObjects
   * const databaseObjects = await prisma.databaseObject.findMany()
   * ```
   */
  get databaseObject(): Prisma.DatabaseObjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exposedEntity`: Exposes CRUD operations for the **ExposedEntity** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExposedEntities
   * const exposedEntities = await prisma.exposedEntity.findMany()
   * ```
   */
  get exposedEntity(): Prisma.ExposedEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exposedFieldPolicy`: Exposes CRUD operations for the **ExposedFieldPolicy** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExposedFieldPolicies
   * const exposedFieldPolicies = await prisma.exposedFieldPolicy.findMany()
   * ```
   */
  get exposedFieldPolicy(): Prisma.ExposedFieldPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exposedRowPolicy`: Exposes CRUD operations for the **ExposedRowPolicy** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExposedRowPolicies
   * const exposedRowPolicies = await prisma.exposedRowPolicy.findMany()
   * ```
   */
  get exposedRowPolicy(): Prisma.ExposedRowPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsAndConditions`: Exposes CRUD operations for the **TermsAndConditions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TermsAndConditions
   * const termsAndConditions = await prisma.termsAndConditions.findMany()
   * ```
   */
  get termsAndConditions(): Prisma.TermsAndConditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsAcceptance`: Exposes CRUD operations for the **TermsAcceptance** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TermsAcceptances
   * const termsAcceptances = await prisma.termsAcceptance.findMany()
   * ```
   */
  get termsAcceptance(): Prisma.TermsAcceptanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rateLimitConfig`: Exposes CRUD operations for the **RateLimitConfig** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RateLimitConfigs
   * const rateLimitConfigs = await prisma.rateLimitConfig.findMany()
   * ```
   */
  get rateLimitConfig(): Prisma.RateLimitConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rateLimitUsage`: Exposes CRUD operations for the **RateLimitUsage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RateLimitUsages
   * const rateLimitUsages = await prisma.rateLimitUsage.findMany()
   * ```
   */
  get rateLimitUsage(): Prisma.RateLimitUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialAccount`: Exposes CRUD operations for the **SocialAccount** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SocialAccounts
   * const socialAccounts = await prisma.socialAccount.findMany()
   * ```
   */
  get socialAccount(): Prisma.SocialAccountDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Organization: 'Organization';
    User: 'User';
    Membership: 'Membership';
    Invitation: 'Invitation';
    EmailVerificationToken: 'EmailVerificationToken';
    BillingEvent: 'BillingEvent';
    Subscription: 'Subscription';
    Invoice: 'Invoice';
    DatabaseConnection: 'DatabaseConnection';
    Endpoint: 'Endpoint';
    ApiKey: 'ApiKey';
    UsageMetric: 'UsageMetric';
    Workflow: 'Workflow';
    WorkflowExecution: 'WorkflowExecution';
    Webhook: 'Webhook';
    AuditLog: 'AuditLog';
    Service: 'Service';
    Application: 'Application';
    Role: 'Role';
    Notification: 'Notification';
    ApiActivityLog: 'ApiActivityLog';
    DatabaseObject: 'DatabaseObject';
    ExposedEntity: 'ExposedEntity';
    ExposedFieldPolicy: 'ExposedFieldPolicy';
    ExposedRowPolicy: 'ExposedRowPolicy';
    TermsAndConditions: 'TermsAndConditions';
    TermsAcceptance: 'TermsAcceptance';
    RateLimitConfig: 'RateLimitConfig';
    RateLimitUsage: 'RateLimitUsage';
    SocialAccount: 'SocialAccount';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'organization'
        | 'user'
        | 'membership'
        | 'invitation'
        | 'emailVerificationToken'
        | 'billingEvent'
        | 'subscription'
        | 'invoice'
        | 'databaseConnection'
        | 'endpoint'
        | 'apiKey'
        | 'usageMetric'
        | 'workflow'
        | 'workflowExecution'
        | 'webhook'
        | 'auditLog'
        | 'service'
        | 'application'
        | 'role'
        | 'notification'
        | 'apiActivityLog'
        | 'databaseObject'
        | 'exposedEntity'
        | 'exposedFieldPolicy'
        | 'exposedRowPolicy'
        | 'termsAndConditions'
        | 'termsAcceptance'
        | 'rateLimitConfig'
        | 'rateLimitUsage'
        | 'socialAccount';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>;
        fields: Prisma.OrganizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrganization>;
          };
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>;
        fields: Prisma.MembershipFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[];
          };
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>;
          };
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMembership>;
          };
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MembershipGroupByOutputType>[];
          };
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>;
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number;
          };
        };
      };
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>;
        fields: Prisma.InvitationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[];
          };
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[];
          };
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[];
          };
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>;
          };
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvitation>;
          };
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InvitationGroupByOutputType>[];
          };
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>;
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number;
          };
        };
      };
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>;
        fields: Prisma.EmailVerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEmailVerificationToken>;
          };
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>;
            result: $Utils.Optional<EmailVerificationTokenCountAggregateOutputType> | number;
          };
        };
      };
      BillingEvent: {
        payload: Prisma.$BillingEventPayload<ExtArgs>;
        fields: Prisma.BillingEventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BillingEventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BillingEventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          findFirst: {
            args: Prisma.BillingEventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BillingEventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          findMany: {
            args: Prisma.BillingEventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>[];
          };
          create: {
            args: Prisma.BillingEventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          createMany: {
            args: Prisma.BillingEventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BillingEventCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>[];
          };
          delete: {
            args: Prisma.BillingEventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          update: {
            args: Prisma.BillingEventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          deleteMany: {
            args: Prisma.BillingEventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BillingEventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BillingEventUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>[];
          };
          upsert: {
            args: Prisma.BillingEventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BillingEventPayload>;
          };
          aggregate: {
            args: Prisma.BillingEventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBillingEvent>;
          };
          groupBy: {
            args: Prisma.BillingEventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BillingEventGroupByOutputType>[];
          };
          count: {
            args: Prisma.BillingEventCountArgs<ExtArgs>;
            result: $Utils.Optional<BillingEventCountAggregateOutputType> | number;
          };
        };
      };
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>;
        fields: Prisma.SubscriptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
          };
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
          };
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubscription>;
          };
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number;
          };
        };
      };
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>;
        fields: Prisma.InvoiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[];
          };
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>;
          };
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInvoice>;
          };
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>;
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number;
          };
        };
      };
      DatabaseConnection: {
        payload: Prisma.$DatabaseConnectionPayload<ExtArgs>;
        fields: Prisma.DatabaseConnectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DatabaseConnectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DatabaseConnectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          findFirst: {
            args: Prisma.DatabaseConnectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DatabaseConnectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          findMany: {
            args: Prisma.DatabaseConnectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>[];
          };
          create: {
            args: Prisma.DatabaseConnectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          createMany: {
            args: Prisma.DatabaseConnectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DatabaseConnectionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>[];
          };
          delete: {
            args: Prisma.DatabaseConnectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          update: {
            args: Prisma.DatabaseConnectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          deleteMany: {
            args: Prisma.DatabaseConnectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DatabaseConnectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DatabaseConnectionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>[];
          };
          upsert: {
            args: Prisma.DatabaseConnectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseConnectionPayload>;
          };
          aggregate: {
            args: Prisma.DatabaseConnectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDatabaseConnection>;
          };
          groupBy: {
            args: Prisma.DatabaseConnectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseConnectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.DatabaseConnectionCountArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseConnectionCountAggregateOutputType> | number;
          };
        };
      };
      Endpoint: {
        payload: Prisma.$EndpointPayload<ExtArgs>;
        fields: Prisma.EndpointFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EndpointFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EndpointFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          findFirst: {
            args: Prisma.EndpointFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EndpointFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          findMany: {
            args: Prisma.EndpointFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          create: {
            args: Prisma.EndpointCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          createMany: {
            args: Prisma.EndpointCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EndpointCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          delete: {
            args: Prisma.EndpointDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          update: {
            args: Prisma.EndpointUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          deleteMany: {
            args: Prisma.EndpointDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EndpointUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.EndpointUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          upsert: {
            args: Prisma.EndpointUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          aggregate: {
            args: Prisma.EndpointAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEndpoint>;
          };
          groupBy: {
            args: Prisma.EndpointGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EndpointGroupByOutputType>[];
          };
          count: {
            args: Prisma.EndpointCountArgs<ExtArgs>;
            result: $Utils.Optional<EndpointCountAggregateOutputType> | number;
          };
        };
      };
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>;
        fields: Prisma.ApiKeyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[];
          };
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[];
          };
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[];
          };
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApiKey>;
          };
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApiKeyGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>;
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number;
          };
        };
      };
      UsageMetric: {
        payload: Prisma.$UsageMetricPayload<ExtArgs>;
        fields: Prisma.UsageMetricFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UsageMetricFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UsageMetricFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          findFirst: {
            args: Prisma.UsageMetricFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UsageMetricFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          findMany: {
            args: Prisma.UsageMetricFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[];
          };
          create: {
            args: Prisma.UsageMetricCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          createMany: {
            args: Prisma.UsageMetricCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UsageMetricCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[];
          };
          delete: {
            args: Prisma.UsageMetricDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          update: {
            args: Prisma.UsageMetricUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          deleteMany: {
            args: Prisma.UsageMetricDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UsageMetricUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UsageMetricUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>[];
          };
          upsert: {
            args: Prisma.UsageMetricUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UsageMetricPayload>;
          };
          aggregate: {
            args: Prisma.UsageMetricAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsageMetric>;
          };
          groupBy: {
            args: Prisma.UsageMetricGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsageMetricGroupByOutputType>[];
          };
          count: {
            args: Prisma.UsageMetricCountArgs<ExtArgs>;
            result: $Utils.Optional<UsageMetricCountAggregateOutputType> | number;
          };
        };
      };
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>;
        fields: Prisma.WorkflowFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWorkflow>;
          };
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowGroupByOutputType>[];
          };
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number;
          };
        };
      };
      WorkflowExecution: {
        payload: Prisma.$WorkflowExecutionPayload<ExtArgs>;
        fields: Prisma.WorkflowExecutionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WorkflowExecutionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          findFirst: {
            args: Prisma.WorkflowExecutionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          findMany: {
            args: Prisma.WorkflowExecutionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[];
          };
          create: {
            args: Prisma.WorkflowExecutionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          createMany: {
            args: Prisma.WorkflowExecutionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[];
          };
          delete: {
            args: Prisma.WorkflowExecutionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          update: {
            args: Prisma.WorkflowExecutionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          deleteMany: {
            args: Prisma.WorkflowExecutionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WorkflowExecutionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[];
          };
          upsert: {
            args: Prisma.WorkflowExecutionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>;
          };
          aggregate: {
            args: Prisma.WorkflowExecutionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWorkflowExecution>;
          };
          groupBy: {
            args: Prisma.WorkflowExecutionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowExecutionGroupByOutputType>[];
          };
          count: {
            args: Prisma.WorkflowExecutionCountArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowExecutionCountAggregateOutputType> | number;
          };
        };
      };
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>;
        fields: Prisma.WebhookFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[];
          };
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[];
          };
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[];
          };
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>;
          };
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWebhook>;
          };
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WebhookGroupByOutputType>[];
          };
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>;
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>;
        fields: Prisma.ServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateService>;
          };
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number;
          };
        };
      };
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>;
        fields: Prisma.ApplicationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApplicationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApplication>;
          };
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApplicationGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>;
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number;
          };
        };
      };
      ApiActivityLog: {
        payload: Prisma.$ApiActivityLogPayload<ExtArgs>;
        fields: Prisma.ApiActivityLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApiActivityLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApiActivityLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          findFirst: {
            args: Prisma.ApiActivityLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApiActivityLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          findMany: {
            args: Prisma.ApiActivityLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          create: {
            args: Prisma.ApiActivityLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          createMany: {
            args: Prisma.ApiActivityLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApiActivityLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          delete: {
            args: Prisma.ApiActivityLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          update: {
            args: Prisma.ApiActivityLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          deleteMany: {
            args: Prisma.ApiActivityLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApiActivityLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApiActivityLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          upsert: {
            args: Prisma.ApiActivityLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          aggregate: {
            args: Prisma.ApiActivityLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApiActivityLog>;
          };
          groupBy: {
            args: Prisma.ApiActivityLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApiActivityLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApiActivityLogCountArgs<ExtArgs>;
            result: $Utils.Optional<ApiActivityLogCountAggregateOutputType> | number;
          };
        };
      };
      DatabaseObject: {
        payload: Prisma.$DatabaseObjectPayload<ExtArgs>;
        fields: Prisma.DatabaseObjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DatabaseObjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DatabaseObjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          findFirst: {
            args: Prisma.DatabaseObjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DatabaseObjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          findMany: {
            args: Prisma.DatabaseObjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          create: {
            args: Prisma.DatabaseObjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          createMany: {
            args: Prisma.DatabaseObjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DatabaseObjectCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          delete: {
            args: Prisma.DatabaseObjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          update: {
            args: Prisma.DatabaseObjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          deleteMany: {
            args: Prisma.DatabaseObjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DatabaseObjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DatabaseObjectUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          upsert: {
            args: Prisma.DatabaseObjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          aggregate: {
            args: Prisma.DatabaseObjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDatabaseObject>;
          };
          groupBy: {
            args: Prisma.DatabaseObjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseObjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.DatabaseObjectCountArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseObjectCountAggregateOutputType> | number;
          };
        };
      };
      ExposedEntity: {
        payload: Prisma.$ExposedEntityPayload<ExtArgs>;
        fields: Prisma.ExposedEntityFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExposedEntityFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExposedEntityFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          findFirst: {
            args: Prisma.ExposedEntityFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExposedEntityFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          findMany: {
            args: Prisma.ExposedEntityFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>[];
          };
          create: {
            args: Prisma.ExposedEntityCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          createMany: {
            args: Prisma.ExposedEntityCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExposedEntityCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>[];
          };
          delete: {
            args: Prisma.ExposedEntityDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          update: {
            args: Prisma.ExposedEntityUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          deleteMany: {
            args: Prisma.ExposedEntityDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExposedEntityUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExposedEntityUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>[];
          };
          upsert: {
            args: Prisma.ExposedEntityUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedEntityPayload>;
          };
          aggregate: {
            args: Prisma.ExposedEntityAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExposedEntity>;
          };
          groupBy: {
            args: Prisma.ExposedEntityGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExposedEntityGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExposedEntityCountArgs<ExtArgs>;
            result: $Utils.Optional<ExposedEntityCountAggregateOutputType> | number;
          };
        };
      };
      ExposedFieldPolicy: {
        payload: Prisma.$ExposedFieldPolicyPayload<ExtArgs>;
        fields: Prisma.ExposedFieldPolicyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExposedFieldPolicyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExposedFieldPolicyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          findFirst: {
            args: Prisma.ExposedFieldPolicyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExposedFieldPolicyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          findMany: {
            args: Prisma.ExposedFieldPolicyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>[];
          };
          create: {
            args: Prisma.ExposedFieldPolicyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          createMany: {
            args: Prisma.ExposedFieldPolicyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExposedFieldPolicyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>[];
          };
          delete: {
            args: Prisma.ExposedFieldPolicyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          update: {
            args: Prisma.ExposedFieldPolicyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          deleteMany: {
            args: Prisma.ExposedFieldPolicyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExposedFieldPolicyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExposedFieldPolicyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>[];
          };
          upsert: {
            args: Prisma.ExposedFieldPolicyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedFieldPolicyPayload>;
          };
          aggregate: {
            args: Prisma.ExposedFieldPolicyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExposedFieldPolicy>;
          };
          groupBy: {
            args: Prisma.ExposedFieldPolicyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExposedFieldPolicyGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExposedFieldPolicyCountArgs<ExtArgs>;
            result: $Utils.Optional<ExposedFieldPolicyCountAggregateOutputType> | number;
          };
        };
      };
      ExposedRowPolicy: {
        payload: Prisma.$ExposedRowPolicyPayload<ExtArgs>;
        fields: Prisma.ExposedRowPolicyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExposedRowPolicyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExposedRowPolicyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          findFirst: {
            args: Prisma.ExposedRowPolicyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExposedRowPolicyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          findMany: {
            args: Prisma.ExposedRowPolicyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>[];
          };
          create: {
            args: Prisma.ExposedRowPolicyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          createMany: {
            args: Prisma.ExposedRowPolicyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExposedRowPolicyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>[];
          };
          delete: {
            args: Prisma.ExposedRowPolicyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          update: {
            args: Prisma.ExposedRowPolicyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          deleteMany: {
            args: Prisma.ExposedRowPolicyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExposedRowPolicyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExposedRowPolicyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>[];
          };
          upsert: {
            args: Prisma.ExposedRowPolicyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExposedRowPolicyPayload>;
          };
          aggregate: {
            args: Prisma.ExposedRowPolicyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExposedRowPolicy>;
          };
          groupBy: {
            args: Prisma.ExposedRowPolicyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExposedRowPolicyGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExposedRowPolicyCountArgs<ExtArgs>;
            result: $Utils.Optional<ExposedRowPolicyCountAggregateOutputType> | number;
          };
        };
      };
      TermsAndConditions: {
        payload: Prisma.$TermsAndConditionsPayload<ExtArgs>;
        fields: Prisma.TermsAndConditionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TermsAndConditionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TermsAndConditionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          findFirst: {
            args: Prisma.TermsAndConditionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TermsAndConditionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          findMany: {
            args: Prisma.TermsAndConditionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>[];
          };
          create: {
            args: Prisma.TermsAndConditionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          createMany: {
            args: Prisma.TermsAndConditionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TermsAndConditionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>[];
          };
          delete: {
            args: Prisma.TermsAndConditionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          update: {
            args: Prisma.TermsAndConditionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          deleteMany: {
            args: Prisma.TermsAndConditionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TermsAndConditionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TermsAndConditionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>[];
          };
          upsert: {
            args: Prisma.TermsAndConditionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAndConditionsPayload>;
          };
          aggregate: {
            args: Prisma.TermsAndConditionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTermsAndConditions>;
          };
          groupBy: {
            args: Prisma.TermsAndConditionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TermsAndConditionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.TermsAndConditionsCountArgs<ExtArgs>;
            result: $Utils.Optional<TermsAndConditionsCountAggregateOutputType> | number;
          };
        };
      };
      TermsAcceptance: {
        payload: Prisma.$TermsAcceptancePayload<ExtArgs>;
        fields: Prisma.TermsAcceptanceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TermsAcceptanceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TermsAcceptanceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          findFirst: {
            args: Prisma.TermsAcceptanceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TermsAcceptanceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          findMany: {
            args: Prisma.TermsAcceptanceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>[];
          };
          create: {
            args: Prisma.TermsAcceptanceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          createMany: {
            args: Prisma.TermsAcceptanceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TermsAcceptanceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>[];
          };
          delete: {
            args: Prisma.TermsAcceptanceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          update: {
            args: Prisma.TermsAcceptanceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          deleteMany: {
            args: Prisma.TermsAcceptanceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TermsAcceptanceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TermsAcceptanceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>[];
          };
          upsert: {
            args: Prisma.TermsAcceptanceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermsAcceptancePayload>;
          };
          aggregate: {
            args: Prisma.TermsAcceptanceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTermsAcceptance>;
          };
          groupBy: {
            args: Prisma.TermsAcceptanceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TermsAcceptanceGroupByOutputType>[];
          };
          count: {
            args: Prisma.TermsAcceptanceCountArgs<ExtArgs>;
            result: $Utils.Optional<TermsAcceptanceCountAggregateOutputType> | number;
          };
        };
      };
      RateLimitConfig: {
        payload: Prisma.$RateLimitConfigPayload<ExtArgs>;
        fields: Prisma.RateLimitConfigFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RateLimitConfigFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RateLimitConfigFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          findFirst: {
            args: Prisma.RateLimitConfigFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RateLimitConfigFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          findMany: {
            args: Prisma.RateLimitConfigFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          create: {
            args: Prisma.RateLimitConfigCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          createMany: {
            args: Prisma.RateLimitConfigCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RateLimitConfigCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          delete: {
            args: Prisma.RateLimitConfigDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          update: {
            args: Prisma.RateLimitConfigUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          deleteMany: {
            args: Prisma.RateLimitConfigDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RateLimitConfigUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RateLimitConfigUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          upsert: {
            args: Prisma.RateLimitConfigUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          aggregate: {
            args: Prisma.RateLimitConfigAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRateLimitConfig>;
          };
          groupBy: {
            args: Prisma.RateLimitConfigGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitConfigGroupByOutputType>[];
          };
          count: {
            args: Prisma.RateLimitConfigCountArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitConfigCountAggregateOutputType> | number;
          };
        };
      };
      RateLimitUsage: {
        payload: Prisma.$RateLimitUsagePayload<ExtArgs>;
        fields: Prisma.RateLimitUsageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RateLimitUsageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RateLimitUsageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          findFirst: {
            args: Prisma.RateLimitUsageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RateLimitUsageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          findMany: {
            args: Prisma.RateLimitUsageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>[];
          };
          create: {
            args: Prisma.RateLimitUsageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          createMany: {
            args: Prisma.RateLimitUsageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RateLimitUsageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>[];
          };
          delete: {
            args: Prisma.RateLimitUsageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          update: {
            args: Prisma.RateLimitUsageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          deleteMany: {
            args: Prisma.RateLimitUsageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RateLimitUsageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RateLimitUsageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>[];
          };
          upsert: {
            args: Prisma.RateLimitUsageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitUsagePayload>;
          };
          aggregate: {
            args: Prisma.RateLimitUsageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRateLimitUsage>;
          };
          groupBy: {
            args: Prisma.RateLimitUsageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitUsageGroupByOutputType>[];
          };
          count: {
            args: Prisma.RateLimitUsageCountArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitUsageCountAggregateOutputType> | number;
          };
        };
      };
      SocialAccount: {
        payload: Prisma.$SocialAccountPayload<ExtArgs>;
        fields: Prisma.SocialAccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SocialAccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SocialAccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          findFirst: {
            args: Prisma.SocialAccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SocialAccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          findMany: {
            args: Prisma.SocialAccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[];
          };
          create: {
            args: Prisma.SocialAccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          createMany: {
            args: Prisma.SocialAccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SocialAccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[];
          };
          delete: {
            args: Prisma.SocialAccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          update: {
            args: Prisma.SocialAccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          deleteMany: {
            args: Prisma.SocialAccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SocialAccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SocialAccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[];
          };
          upsert: {
            args: Prisma.SocialAccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>;
          };
          aggregate: {
            args: Prisma.SocialAccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSocialAccount>;
          };
          groupBy: {
            args: Prisma.SocialAccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SocialAccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.SocialAccountCountArgs<ExtArgs>;
            result: $Utils.Optional<SocialAccountCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit;
    user?: UserOmit;
    membership?: MembershipOmit;
    invitation?: InvitationOmit;
    emailVerificationToken?: EmailVerificationTokenOmit;
    billingEvent?: BillingEventOmit;
    subscription?: SubscriptionOmit;
    invoice?: InvoiceOmit;
    databaseConnection?: DatabaseConnectionOmit;
    endpoint?: EndpointOmit;
    apiKey?: ApiKeyOmit;
    usageMetric?: UsageMetricOmit;
    workflow?: WorkflowOmit;
    workflowExecution?: WorkflowExecutionOmit;
    webhook?: WebhookOmit;
    auditLog?: AuditLogOmit;
    service?: ServiceOmit;
    application?: ApplicationOmit;
    role?: RoleOmit;
    notification?: NotificationOmit;
    apiActivityLog?: ApiActivityLogOmit;
    databaseObject?: DatabaseObjectOmit;
    exposedEntity?: ExposedEntityOmit;
    exposedFieldPolicy?: ExposedFieldPolicyOmit;
    exposedRowPolicy?: ExposedRowPolicyOmit;
    termsAndConditions?: TermsAndConditionsOmit;
    termsAcceptance?: TermsAcceptanceOmit;
    rateLimitConfig?: RateLimitConfigOmit;
    rateLimitUsage?: RateLimitUsageOmit;
    socialAccount?: SocialAccountOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    apiActivityLogs: number;
    apiKeys: number;
    applications: number;
    auditLogs: number;
    databaseConnections: number;
    databaseObjects: number;
    endpoints: number;
    exposedEntities: number;
    invitations: number;
    memberships: number;
    notifications: number;
    roles: number;
    services: number;
    termsAcceptances: number;
    usageMetrics: number;
    webhooks: number;
    workflows: number;
    rateLimitConfigs: number;
    rateLimitUsage: number;
    billingEvents: number;
  };

  export type OrganizationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiActivityLogs?: boolean | OrganizationCountOutputTypeCountApiActivityLogsArgs;
    apiKeys?: boolean | OrganizationCountOutputTypeCountApiKeysArgs;
    applications?: boolean | OrganizationCountOutputTypeCountApplicationsArgs;
    auditLogs?: boolean | OrganizationCountOutputTypeCountAuditLogsArgs;
    databaseConnections?: boolean | OrganizationCountOutputTypeCountDatabaseConnectionsArgs;
    databaseObjects?: boolean | OrganizationCountOutputTypeCountDatabaseObjectsArgs;
    endpoints?: boolean | OrganizationCountOutputTypeCountEndpointsArgs;
    exposedEntities?: boolean | OrganizationCountOutputTypeCountExposedEntitiesArgs;
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs;
    memberships?: boolean | OrganizationCountOutputTypeCountMembershipsArgs;
    notifications?: boolean | OrganizationCountOutputTypeCountNotificationsArgs;
    roles?: boolean | OrganizationCountOutputTypeCountRolesArgs;
    services?: boolean | OrganizationCountOutputTypeCountServicesArgs;
    termsAcceptances?: boolean | OrganizationCountOutputTypeCountTermsAcceptancesArgs;
    usageMetrics?: boolean | OrganizationCountOutputTypeCountUsageMetricsArgs;
    webhooks?: boolean | OrganizationCountOutputTypeCountWebhooksArgs;
    workflows?: boolean | OrganizationCountOutputTypeCountWorkflowsArgs;
    rateLimitConfigs?: boolean | OrganizationCountOutputTypeCountRateLimitConfigsArgs;
    rateLimitUsage?: boolean | OrganizationCountOutputTypeCountRateLimitUsageArgs;
    billingEvents?: boolean | OrganizationCountOutputTypeCountBillingEventsArgs;
  };

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApiKeysArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiKeyWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountApplicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDatabaseConnectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseConnectionWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDatabaseObjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseObjectWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEndpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountExposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedEntityWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvitationWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTermsAcceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermsAcceptanceWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsageMetricWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountWebhooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WebhookWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountWorkflowsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRateLimitConfigsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitConfigWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRateLimitUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitUsageWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountBillingEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BillingEventWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apiActivityLogs: number;
    apiKeysCreated: number;
    applicationsCreated: number;
    auditLogs: number;
    databaseConnectionsCreated: number;
    endpointsCreated: number;
    exposedEntitiesCreated: number;
    invitationsSent: number;
    memberships: number;
    notifications: number;
    rolesCreated: number;
    servicesCreated: number;
    termsAcceptances: number;
    workflowsCreated: number;
    rateLimitCreated: number;
    rateLimitUpdated: number;
    socialAccounts: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiActivityLogs?: boolean | UserCountOutputTypeCountApiActivityLogsArgs;
    apiKeysCreated?: boolean | UserCountOutputTypeCountApiKeysCreatedArgs;
    applicationsCreated?: boolean | UserCountOutputTypeCountApplicationsCreatedArgs;
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs;
    databaseConnectionsCreated?: boolean | UserCountOutputTypeCountDatabaseConnectionsCreatedArgs;
    endpointsCreated?: boolean | UserCountOutputTypeCountEndpointsCreatedArgs;
    exposedEntitiesCreated?: boolean | UserCountOutputTypeCountExposedEntitiesCreatedArgs;
    invitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs;
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    rolesCreated?: boolean | UserCountOutputTypeCountRolesCreatedArgs;
    servicesCreated?: boolean | UserCountOutputTypeCountServicesCreatedArgs;
    termsAcceptances?: boolean | UserCountOutputTypeCountTermsAcceptancesArgs;
    workflowsCreated?: boolean | UserCountOutputTypeCountWorkflowsCreatedArgs;
    rateLimitCreated?: boolean | UserCountOutputTypeCountRateLimitCreatedArgs;
    rateLimitUpdated?: boolean | UserCountOutputTypeCountRateLimitUpdatedArgs;
    socialAccounts?: boolean | UserCountOutputTypeCountSocialAccountsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiKeyWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDatabaseConnectionsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseConnectionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEndpointsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExposedEntitiesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedEntityWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvitationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTermsAcceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermsAcceptanceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRateLimitCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitConfigWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRateLimitUpdatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitConfigWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SocialAccountWhereInput;
  };

  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number;
    billingEvents: number;
  };

  export type SubscriptionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs;
    billingEvents?: boolean | SubscriptionCountOutputTypeCountBillingEventsArgs;
  };

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceWhereInput;
  };

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountBillingEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BillingEventWhereInput;
  };

  /**
   * Count Type DatabaseConnectionCountOutputType
   */

  export type DatabaseConnectionCountOutputType = {
    endpoints: number;
    exposedEntities: number;
    services: number;
  };

  export type DatabaseConnectionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    endpoints?: boolean | DatabaseConnectionCountOutputTypeCountEndpointsArgs;
    exposedEntities?: boolean | DatabaseConnectionCountOutputTypeCountExposedEntitiesArgs;
    services?: boolean | DatabaseConnectionCountOutputTypeCountServicesArgs;
  };

  // Custom InputTypes
  /**
   * DatabaseConnectionCountOutputType without action
   */
  export type DatabaseConnectionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnectionCountOutputType
     */
    select?: DatabaseConnectionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * DatabaseConnectionCountOutputType without action
   */
  export type DatabaseConnectionCountOutputTypeCountEndpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * DatabaseConnectionCountOutputType without action
   */
  export type DatabaseConnectionCountOutputTypeCountExposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedEntityWhereInput;
  };

  /**
   * DatabaseConnectionCountOutputType without action
   */
  export type DatabaseConnectionCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * Count Type EndpointCountOutputType
   */

  export type EndpointCountOutputType = {
    usageLogs: number;
  };

  export type EndpointCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usageLogs?: boolean | EndpointCountOutputTypeCountUsageLogsArgs;
  };

  // Custom InputTypes
  /**
   * EndpointCountOutputType without action
   */
  export type EndpointCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EndpointCountOutputType
     */
    select?: EndpointCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * EndpointCountOutputType without action
   */
  export type EndpointCountOutputTypeCountUsageLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
  };

  /**
   * Count Type ApiKeyCountOutputType
   */

  export type ApiKeyCountOutputType = {
    usageMetrics: number;
  };

  export type ApiKeyCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    usageMetrics?: boolean | ApiKeyCountOutputTypeCountUsageMetricsArgs;
  };

  // Custom InputTypes
  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKeyCountOutputType
     */
    select?: ApiKeyCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsageMetricWhereInput;
  };

  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    executions: number;
  };

  export type WorkflowCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    executions?: boolean | WorkflowCountOutputTypeCountExecutionsArgs;
  };

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountExecutionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowExecutionWhereInput;
  };

  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    databaseObjects: number;
    exposedEntities: number;
    roles: number;
  };

  export type ServiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    databaseObjects?: boolean | ServiceCountOutputTypeCountDatabaseObjectsArgs;
    exposedEntities?: boolean | ServiceCountOutputTypeCountExposedEntitiesArgs;
    roles?: boolean | ServiceCountOutputTypeCountRolesArgs;
  };

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountDatabaseObjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseObjectWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountExposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedEntityWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    applications: number;
    exposedFieldPolicies: number;
    exposedRowPolicies: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    applications?: boolean | RoleCountOutputTypeCountApplicationsArgs;
    exposedFieldPolicies?: boolean | RoleCountOutputTypeCountExposedFieldPoliciesArgs;
    exposedRowPolicies?: boolean | RoleCountOutputTypeCountExposedRowPoliciesArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountApplicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountExposedFieldPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedFieldPolicyWhereInput;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountExposedRowPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedRowPolicyWhereInput;
  };

  /**
   * Count Type ExposedEntityCountOutputType
   */

  export type ExposedEntityCountOutputType = {
    fieldPolicies: number;
    rowPolicies: number;
  };

  export type ExposedEntityCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    fieldPolicies?: boolean | ExposedEntityCountOutputTypeCountFieldPoliciesArgs;
    rowPolicies?: boolean | ExposedEntityCountOutputTypeCountRowPoliciesArgs;
  };

  // Custom InputTypes
  /**
   * ExposedEntityCountOutputType without action
   */
  export type ExposedEntityCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntityCountOutputType
     */
    select?: ExposedEntityCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ExposedEntityCountOutputType without action
   */
  export type ExposedEntityCountOutputTypeCountFieldPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedFieldPolicyWhereInput;
  };

  /**
   * ExposedEntityCountOutputType without action
   */
  export type ExposedEntityCountOutputTypeCountRowPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedRowPolicyWhereInput;
  };

  /**
   * Count Type TermsAndConditionsCountOutputType
   */

  export type TermsAndConditionsCountOutputType = {
    acceptances: number;
  };

  export type TermsAndConditionsCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acceptances?: boolean | TermsAndConditionsCountOutputTypeCountAcceptancesArgs;
  };

  // Custom InputTypes
  /**
   * TermsAndConditionsCountOutputType without action
   */
  export type TermsAndConditionsCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditionsCountOutputType
     */
    select?: TermsAndConditionsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TermsAndConditionsCountOutputType without action
   */
  export type TermsAndConditionsCountOutputTypeCountAcceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermsAcceptanceWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  export type OrganizationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    domain: string | null;
    logo: string | null;
    website: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastTermsPromptedAt: Date | null;
    requiresTermsAcceptance: boolean | null;
  };

  export type OrganizationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    domain: string | null;
    logo: string | null;
    website: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastTermsPromptedAt: Date | null;
    requiresTermsAcceptance: boolean | null;
  };

  export type OrganizationCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    domain: number;
    logo: number;
    website: number;
    createdAt: number;
    updatedAt: number;
    lastTermsPromptedAt: number;
    requiresTermsAcceptance: number;
    _all: number;
  };

  export type OrganizationMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    domain?: true;
    logo?: true;
    website?: true;
    createdAt?: true;
    updatedAt?: true;
    lastTermsPromptedAt?: true;
    requiresTermsAcceptance?: true;
  };

  export type OrganizationMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    domain?: true;
    logo?: true;
    website?: true;
    createdAt?: true;
    updatedAt?: true;
    lastTermsPromptedAt?: true;
    requiresTermsAcceptance?: true;
  };

  export type OrganizationCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    domain?: true;
    logo?: true;
    website?: true;
    createdAt?: true;
    updatedAt?: true;
    lastTermsPromptedAt?: true;
    requiresTermsAcceptance?: true;
    _all?: true;
  };

  export type OrganizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Organizations
     **/
    _count?: true | OrganizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrganizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrganizationMaxAggregateInputType;
  };

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
    [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>;
  };

  export type OrganizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrganizationWhereInput;
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[];
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum;
    having?: OrganizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrganizationCountAggregateInputType | true;
    _min?: OrganizationMinAggregateInputType;
    _max?: OrganizationMaxAggregateInputType;
  };

  export type OrganizationGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    domain: string | null;
    logo: string | null;
    website: string | null;
    createdAt: Date;
    updatedAt: Date;
    lastTermsPromptedAt: Date | null;
    requiresTermsAcceptance: boolean;
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof OrganizationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
          : GetScalarType<T[P], OrganizationGroupByOutputType[P]>;
      }
    >
  >;

  export type OrganizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      domain?: boolean;
      logo?: boolean;
      website?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastTermsPromptedAt?: boolean;
      requiresTermsAcceptance?: boolean;
      apiActivityLogs?: boolean | Organization$apiActivityLogsArgs<ExtArgs>;
      apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>;
      applications?: boolean | Organization$applicationsArgs<ExtArgs>;
      auditLogs?: boolean | Organization$auditLogsArgs<ExtArgs>;
      databaseConnections?: boolean | Organization$databaseConnectionsArgs<ExtArgs>;
      databaseObjects?: boolean | Organization$databaseObjectsArgs<ExtArgs>;
      endpoints?: boolean | Organization$endpointsArgs<ExtArgs>;
      exposedEntities?: boolean | Organization$exposedEntitiesArgs<ExtArgs>;
      invitations?: boolean | Organization$invitationsArgs<ExtArgs>;
      memberships?: boolean | Organization$membershipsArgs<ExtArgs>;
      notifications?: boolean | Organization$notificationsArgs<ExtArgs>;
      roles?: boolean | Organization$rolesArgs<ExtArgs>;
      services?: boolean | Organization$servicesArgs<ExtArgs>;
      subscription?: boolean | Organization$subscriptionArgs<ExtArgs>;
      termsAcceptances?: boolean | Organization$termsAcceptancesArgs<ExtArgs>;
      usageMetrics?: boolean | Organization$usageMetricsArgs<ExtArgs>;
      webhooks?: boolean | Organization$webhooksArgs<ExtArgs>;
      workflows?: boolean | Organization$workflowsArgs<ExtArgs>;
      rateLimitConfigs?: boolean | Organization$rateLimitConfigsArgs<ExtArgs>;
      rateLimitUsage?: boolean | Organization$rateLimitUsageArgs<ExtArgs>;
      billingEvents?: boolean | Organization$billingEventsArgs<ExtArgs>;
      _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      domain?: boolean;
      logo?: boolean;
      website?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastTermsPromptedAt?: boolean;
      requiresTermsAcceptance?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      domain?: boolean;
      logo?: boolean;
      website?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastTermsPromptedAt?: boolean;
      requiresTermsAcceptance?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    domain?: boolean;
    logo?: boolean;
    website?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    lastTermsPromptedAt?: boolean;
    requiresTermsAcceptance?: boolean;
  };

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'slug'
      | 'domain'
      | 'logo'
      | 'website'
      | 'createdAt'
      | 'updatedAt'
      | 'lastTermsPromptedAt'
      | 'requiresTermsAcceptance',
      ExtArgs['result']['organization']
    >;
  export type OrganizationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiActivityLogs?: boolean | Organization$apiActivityLogsArgs<ExtArgs>;
    apiKeys?: boolean | Organization$apiKeysArgs<ExtArgs>;
    applications?: boolean | Organization$applicationsArgs<ExtArgs>;
    auditLogs?: boolean | Organization$auditLogsArgs<ExtArgs>;
    databaseConnections?: boolean | Organization$databaseConnectionsArgs<ExtArgs>;
    databaseObjects?: boolean | Organization$databaseObjectsArgs<ExtArgs>;
    endpoints?: boolean | Organization$endpointsArgs<ExtArgs>;
    exposedEntities?: boolean | Organization$exposedEntitiesArgs<ExtArgs>;
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>;
    memberships?: boolean | Organization$membershipsArgs<ExtArgs>;
    notifications?: boolean | Organization$notificationsArgs<ExtArgs>;
    roles?: boolean | Organization$rolesArgs<ExtArgs>;
    services?: boolean | Organization$servicesArgs<ExtArgs>;
    subscription?: boolean | Organization$subscriptionArgs<ExtArgs>;
    termsAcceptances?: boolean | Organization$termsAcceptancesArgs<ExtArgs>;
    usageMetrics?: boolean | Organization$usageMetricsArgs<ExtArgs>;
    webhooks?: boolean | Organization$webhooksArgs<ExtArgs>;
    workflows?: boolean | Organization$workflowsArgs<ExtArgs>;
    rateLimitConfigs?: boolean | Organization$rateLimitConfigsArgs<ExtArgs>;
    rateLimitUsage?: boolean | Organization$rateLimitUsageArgs<ExtArgs>;
    billingEvents?: boolean | Organization$billingEventsArgs<ExtArgs>;
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrganizationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type OrganizationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $OrganizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Organization';
    objects: {
      apiActivityLogs: Prisma.$ApiActivityLogPayload<ExtArgs>[];
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[];
      applications: Prisma.$ApplicationPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      databaseConnections: Prisma.$DatabaseConnectionPayload<ExtArgs>[];
      databaseObjects: Prisma.$DatabaseObjectPayload<ExtArgs>[];
      endpoints: Prisma.$EndpointPayload<ExtArgs>[];
      exposedEntities: Prisma.$ExposedEntityPayload<ExtArgs>[];
      invitations: Prisma.$InvitationPayload<ExtArgs>[];
      memberships: Prisma.$MembershipPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      roles: Prisma.$RolePayload<ExtArgs>[];
      services: Prisma.$ServicePayload<ExtArgs>[];
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null;
      termsAcceptances: Prisma.$TermsAcceptancePayload<ExtArgs>[];
      usageMetrics: Prisma.$UsageMetricPayload<ExtArgs>[];
      webhooks: Prisma.$WebhookPayload<ExtArgs>[];
      workflows: Prisma.$WorkflowPayload<ExtArgs>[];
      rateLimitConfigs: Prisma.$RateLimitConfigPayload<ExtArgs>[];
      rateLimitUsage: Prisma.$RateLimitUsagePayload<ExtArgs>[];
      billingEvents: Prisma.$BillingEventPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        domain: string | null;
        logo: string | null;
        website: string | null;
        createdAt: Date;
        updatedAt: Date;
        lastTermsPromptedAt: Date | null;
        requiresTermsAcceptance: boolean;
      },
      ExtArgs['result']['organization']
    >;
    composites: {};
  };

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> =
    $Result.GetResult<Prisma.$OrganizationPayload, S>;

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true;
    };

  export interface OrganizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Organization'];
      meta: { name: 'Organization' };
    };
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     *
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     *
     */
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     *
     */
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
     **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrganizationAggregateArgs>(
      args: Subset<T, OrganizationAggregateArgs>
    ): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>;

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetOrganizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Organization model
     */
    readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    apiActivityLogs<T extends Organization$apiActivityLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$apiActivityLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    apiKeys<T extends Organization$apiKeysArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$apiKeysArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    applications<T extends Organization$applicationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$applicationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    auditLogs<T extends Organization$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    databaseConnections<T extends Organization$databaseConnectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$databaseConnectionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$DatabaseConnectionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    databaseObjects<T extends Organization$databaseObjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$databaseObjectsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    endpoints<T extends Organization$endpointsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$endpointsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    exposedEntities<T extends Organization$exposedEntitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$exposedEntitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$invitationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    memberships<T extends Organization$membershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$membershipsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    notifications<T extends Organization$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    roles<T extends Organization$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    services<T extends Organization$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    subscription<T extends Organization$subscriptionArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$subscriptionArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    termsAcceptances<T extends Organization$termsAcceptancesArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$termsAcceptancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    usageMetrics<T extends Organization$usageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$usageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    webhooks<T extends Organization$webhooksArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$webhooksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    workflows<T extends Organization$workflowsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$workflowsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    rateLimitConfigs<T extends Organization$rateLimitConfigsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$rateLimitConfigsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    rateLimitUsage<T extends Organization$rateLimitUsageArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$rateLimitUsageArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    billingEvents<T extends Organization$billingEventsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$billingEventsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<'Organization', 'String'>;
    readonly name: FieldRef<'Organization', 'String'>;
    readonly slug: FieldRef<'Organization', 'String'>;
    readonly domain: FieldRef<'Organization', 'String'>;
    readonly logo: FieldRef<'Organization', 'String'>;
    readonly website: FieldRef<'Organization', 'String'>;
    readonly createdAt: FieldRef<'Organization', 'DateTime'>;
    readonly updatedAt: FieldRef<'Organization', 'DateTime'>;
    readonly lastTermsPromptedAt: FieldRef<'Organization', 'DateTime'>;
    readonly requiresTermsAcceptance: FieldRef<'Organization', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
  };

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput;
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
  };

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number;
  };

  /**
   * Organization.apiActivityLogs
   */
  export type Organization$apiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    where?: ApiActivityLogWhereInput;
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    cursor?: ApiActivityLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * Organization.apiKeys
   */
  export type Organization$apiKeysArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    where?: ApiKeyWhereInput;
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    cursor?: ApiKeyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * Organization.applications
   */
  export type Organization$applicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    cursor?: ApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Organization.auditLogs
   */
  export type Organization$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * Organization.databaseConnections
   */
  export type Organization$databaseConnectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    where?: DatabaseConnectionWhereInput;
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    cursor?: DatabaseConnectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DatabaseConnectionScalarFieldEnum | DatabaseConnectionScalarFieldEnum[];
  };

  /**
   * Organization.databaseObjects
   */
  export type Organization$databaseObjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    where?: DatabaseObjectWhereInput;
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    cursor?: DatabaseObjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * Organization.endpoints
   */
  export type Organization$endpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Organization.exposedEntities
   */
  export type Organization$exposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    where?: ExposedEntityWhereInput;
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    cursor?: ExposedEntityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    cursor?: InvitationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[];
  };

  /**
   * Organization.memberships
   */
  export type Organization$membershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    cursor?: MembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Organization.notifications
   */
  export type Organization$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Organization.roles
   */
  export type Organization$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    cursor?: RoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Organization.services
   */
  export type Organization$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Organization.subscription
   */
  export type Organization$subscriptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    where?: SubscriptionWhereInput;
  };

  /**
   * Organization.termsAcceptances
   */
  export type Organization$termsAcceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    where?: TermsAcceptanceWhereInput;
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    cursor?: TermsAcceptanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * Organization.usageMetrics
   */
  export type Organization$usageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    where?: UsageMetricWhereInput;
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    cursor?: UsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[];
  };

  /**
   * Organization.webhooks
   */
  export type Organization$webhooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    where?: WebhookWhereInput;
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[];
    cursor?: WebhookWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[];
  };

  /**
   * Organization.workflows
   */
  export type Organization$workflowsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    cursor?: WorkflowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Organization.rateLimitConfigs
   */
  export type Organization$rateLimitConfigsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    where?: RateLimitConfigWhereInput;
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    cursor?: RateLimitConfigWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * Organization.rateLimitUsage
   */
  export type Organization$rateLimitUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    where?: RateLimitUsageWhereInput;
    orderBy?: RateLimitUsageOrderByWithRelationInput | RateLimitUsageOrderByWithRelationInput[];
    cursor?: RateLimitUsageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RateLimitUsageScalarFieldEnum | RateLimitUsageScalarFieldEnum[];
  };

  /**
   * Organization.billingEvents
   */
  export type Organization$billingEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    where?: BillingEventWhereInput;
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    cursor?: BillingEventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[];
  };

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    passwordHash: string | null;
    firstName: string | null;
    lastName: string | null;
    avatarUrl: string | null;
    isActive: boolean | null;
    emailVerified: boolean | null;
    emailVerifiedAt: Date | null;
    lastLoginAt: Date | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    phoneNumber: string | null;
    phoneCarrier: string | null;
    isSuperAdmin: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    passwordHash: string | null;
    firstName: string | null;
    lastName: string | null;
    avatarUrl: string | null;
    isActive: boolean | null;
    emailVerified: boolean | null;
    emailVerifiedAt: Date | null;
    lastLoginAt: Date | null;
    twoFactorEnabled: boolean | null;
    twoFactorSecret: string | null;
    phoneNumber: string | null;
    phoneCarrier: string | null;
    isSuperAdmin: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    passwordHash: number;
    firstName: number;
    lastName: number;
    avatarUrl: number;
    isActive: number;
    emailVerified: number;
    emailVerifiedAt: number;
    lastLoginAt: number;
    twoFactorEnabled: number;
    twoFactorSecret: number;
    phoneNumber: number;
    phoneCarrier: number;
    isSuperAdmin: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatarUrl?: true;
    isActive?: true;
    emailVerified?: true;
    emailVerifiedAt?: true;
    lastLoginAt?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    phoneNumber?: true;
    phoneCarrier?: true;
    isSuperAdmin?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatarUrl?: true;
    isActive?: true;
    emailVerified?: true;
    emailVerifiedAt?: true;
    lastLoginAt?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    phoneNumber?: true;
    phoneCarrier?: true;
    isSuperAdmin?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatarUrl?: true;
    isActive?: true;
    emailVerified?: true;
    emailVerifiedAt?: true;
    lastLoginAt?: true;
    twoFactorEnabled?: true;
    twoFactorSecret?: true;
    phoneNumber?: true;
    phoneCarrier?: true;
    isSuperAdmin?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    passwordHash: string | null;
    firstName: string;
    lastName: string;
    avatarUrl: string | null;
    isActive: boolean;
    emailVerified: boolean;
    emailVerifiedAt: Date | null;
    lastLoginAt: Date | null;
    twoFactorEnabled: boolean;
    twoFactorSecret: string | null;
    phoneNumber: string | null;
    phoneCarrier: string | null;
    isSuperAdmin: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        passwordHash?: boolean;
        firstName?: boolean;
        lastName?: boolean;
        avatarUrl?: boolean;
        isActive?: boolean;
        emailVerified?: boolean;
        emailVerifiedAt?: boolean;
        lastLoginAt?: boolean;
        twoFactorEnabled?: boolean;
        twoFactorSecret?: boolean;
        phoneNumber?: boolean;
        phoneCarrier?: boolean;
        isSuperAdmin?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        apiActivityLogs?: boolean | User$apiActivityLogsArgs<ExtArgs>;
        apiKeysCreated?: boolean | User$apiKeysCreatedArgs<ExtArgs>;
        applicationsCreated?: boolean | User$applicationsCreatedArgs<ExtArgs>;
        auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
        databaseConnectionsCreated?: boolean | User$databaseConnectionsCreatedArgs<ExtArgs>;
        endpointsCreated?: boolean | User$endpointsCreatedArgs<ExtArgs>;
        exposedEntitiesCreated?: boolean | User$exposedEntitiesCreatedArgs<ExtArgs>;
        invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>;
        memberships?: boolean | User$membershipsArgs<ExtArgs>;
        notifications?: boolean | User$notificationsArgs<ExtArgs>;
        rolesCreated?: boolean | User$rolesCreatedArgs<ExtArgs>;
        servicesCreated?: boolean | User$servicesCreatedArgs<ExtArgs>;
        termsAcceptances?: boolean | User$termsAcceptancesArgs<ExtArgs>;
        workflowsCreated?: boolean | User$workflowsCreatedArgs<ExtArgs>;
        rateLimitCreated?: boolean | User$rateLimitCreatedArgs<ExtArgs>;
        rateLimitUpdated?: boolean | User$rateLimitUpdatedArgs<ExtArgs>;
        socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      passwordHash?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      avatarUrl?: boolean;
      isActive?: boolean;
      emailVerified?: boolean;
      emailVerifiedAt?: boolean;
      lastLoginAt?: boolean;
      twoFactorEnabled?: boolean;
      twoFactorSecret?: boolean;
      phoneNumber?: boolean;
      phoneCarrier?: boolean;
      isSuperAdmin?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      passwordHash?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      avatarUrl?: boolean;
      isActive?: boolean;
      emailVerified?: boolean;
      emailVerifiedAt?: boolean;
      lastLoginAt?: boolean;
      twoFactorEnabled?: boolean;
      twoFactorSecret?: boolean;
      phoneNumber?: boolean;
      phoneCarrier?: boolean;
      isSuperAdmin?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    passwordHash?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    avatarUrl?: boolean;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: boolean;
    lastLoginAt?: boolean;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: boolean;
    phoneNumber?: boolean;
    phoneCarrier?: boolean;
    isSuperAdmin?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'email'
      | 'passwordHash'
      | 'firstName'
      | 'lastName'
      | 'avatarUrl'
      | 'isActive'
      | 'emailVerified'
      | 'emailVerifiedAt'
      | 'lastLoginAt'
      | 'twoFactorEnabled'
      | 'twoFactorSecret'
      | 'phoneNumber'
      | 'phoneCarrier'
      | 'isSuperAdmin'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['user']
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiActivityLogs?: boolean | User$apiActivityLogsArgs<ExtArgs>;
    apiKeysCreated?: boolean | User$apiKeysCreatedArgs<ExtArgs>;
    applicationsCreated?: boolean | User$applicationsCreatedArgs<ExtArgs>;
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
    databaseConnectionsCreated?: boolean | User$databaseConnectionsCreatedArgs<ExtArgs>;
    endpointsCreated?: boolean | User$endpointsCreatedArgs<ExtArgs>;
    exposedEntitiesCreated?: boolean | User$exposedEntitiesCreatedArgs<ExtArgs>;
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>;
    memberships?: boolean | User$membershipsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    rolesCreated?: boolean | User$rolesCreatedArgs<ExtArgs>;
    servicesCreated?: boolean | User$servicesCreatedArgs<ExtArgs>;
    termsAcceptances?: boolean | User$termsAcceptancesArgs<ExtArgs>;
    workflowsCreated?: boolean | User$workflowsCreatedArgs<ExtArgs>;
    rateLimitCreated?: boolean | User$rateLimitCreatedArgs<ExtArgs>;
    rateLimitUpdated?: boolean | User$rateLimitUpdatedArgs<ExtArgs>;
    socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      apiActivityLogs: Prisma.$ApiActivityLogPayload<ExtArgs>[];
      apiKeysCreated: Prisma.$ApiKeyPayload<ExtArgs>[];
      applicationsCreated: Prisma.$ApplicationPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      databaseConnectionsCreated: Prisma.$DatabaseConnectionPayload<ExtArgs>[];
      endpointsCreated: Prisma.$EndpointPayload<ExtArgs>[];
      exposedEntitiesCreated: Prisma.$ExposedEntityPayload<ExtArgs>[];
      invitationsSent: Prisma.$InvitationPayload<ExtArgs>[];
      memberships: Prisma.$MembershipPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      rolesCreated: Prisma.$RolePayload<ExtArgs>[];
      servicesCreated: Prisma.$ServicePayload<ExtArgs>[];
      termsAcceptances: Prisma.$TermsAcceptancePayload<ExtArgs>[];
      workflowsCreated: Prisma.$WorkflowPayload<ExtArgs>[];
      rateLimitCreated: Prisma.$RateLimitConfigPayload<ExtArgs>[];
      rateLimitUpdated: Prisma.$RateLimitConfigPayload<ExtArgs>[];
      socialAccounts: Prisma.$SocialAccountPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        passwordHash: string | null;
        firstName: string;
        lastName: string;
        avatarUrl: string | null;
        isActive: boolean;
        emailVerified: boolean;
        emailVerifiedAt: Date | null;
        lastLoginAt: Date | null;
        twoFactorEnabled: boolean;
        twoFactorSecret: string | null;
        phoneNumber: string | null;
        phoneCarrier: string | null;
        isSuperAdmin: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    apiActivityLogs<T extends User$apiActivityLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$apiActivityLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    apiKeysCreated<T extends User$apiKeysCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$apiKeysCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    applicationsCreated<T extends User$applicationsCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$applicationsCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    databaseConnectionsCreated<T extends User$databaseConnectionsCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$databaseConnectionsCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$DatabaseConnectionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    endpointsCreated<T extends User$endpointsCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$endpointsCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    exposedEntitiesCreated<T extends User$exposedEntitiesCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$exposedEntitiesCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    invitationsSent<T extends User$invitationsSentArgs<ExtArgs> = {}>(
      args?: Subset<T, User$invitationsSentArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$membershipsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    rolesCreated<T extends User$rolesCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$rolesCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    servicesCreated<T extends User$servicesCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$servicesCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    termsAcceptances<T extends User$termsAcceptancesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$termsAcceptancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    workflowsCreated<T extends User$workflowsCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$workflowsCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    rateLimitCreated<T extends User$rateLimitCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$rateLimitCreatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    rateLimitUpdated<T extends User$rateLimitUpdatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$rateLimitUpdatedArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    socialAccounts<T extends User$socialAccountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$socialAccountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly firstName: FieldRef<'User', 'String'>;
    readonly lastName: FieldRef<'User', 'String'>;
    readonly avatarUrl: FieldRef<'User', 'String'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly emailVerified: FieldRef<'User', 'Boolean'>;
    readonly emailVerifiedAt: FieldRef<'User', 'DateTime'>;
    readonly lastLoginAt: FieldRef<'User', 'DateTime'>;
    readonly twoFactorEnabled: FieldRef<'User', 'Boolean'>;
    readonly twoFactorSecret: FieldRef<'User', 'String'>;
    readonly phoneNumber: FieldRef<'User', 'String'>;
    readonly phoneCarrier: FieldRef<'User', 'String'>;
    readonly isSuperAdmin: FieldRef<'User', 'Boolean'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.apiActivityLogs
   */
  export type User$apiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    where?: ApiActivityLogWhereInput;
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    cursor?: ApiActivityLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * User.apiKeysCreated
   */
  export type User$apiKeysCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    where?: ApiKeyWhereInput;
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    cursor?: ApiKeyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * User.applicationsCreated
   */
  export type User$applicationsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    cursor?: ApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.databaseConnectionsCreated
   */
  export type User$databaseConnectionsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    where?: DatabaseConnectionWhereInput;
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    cursor?: DatabaseConnectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DatabaseConnectionScalarFieldEnum | DatabaseConnectionScalarFieldEnum[];
  };

  /**
   * User.endpointsCreated
   */
  export type User$endpointsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * User.exposedEntitiesCreated
   */
  export type User$exposedEntitiesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    where?: ExposedEntityWhereInput;
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    cursor?: ExposedEntityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * User.invitationsSent
   */
  export type User$invitationsSentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    cursor?: InvitationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[];
  };

  /**
   * User.memberships
   */
  export type User$membershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    cursor?: MembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.rolesCreated
   */
  export type User$rolesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    cursor?: RoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * User.servicesCreated
   */
  export type User$servicesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * User.termsAcceptances
   */
  export type User$termsAcceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    where?: TermsAcceptanceWhereInput;
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    cursor?: TermsAcceptanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * User.workflowsCreated
   */
  export type User$workflowsCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    cursor?: WorkflowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * User.rateLimitCreated
   */
  export type User$rateLimitCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    where?: RateLimitConfigWhereInput;
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    cursor?: RateLimitConfigWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * User.rateLimitUpdated
   */
  export type User$rateLimitUpdatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    where?: RateLimitConfigWhereInput;
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    cursor?: RateLimitConfigWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * User.socialAccounts
   */
  export type User$socialAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    where?: SocialAccountWhereInput;
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[];
    cursor?: SocialAccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null;
    _min: MembershipMinAggregateOutputType | null;
    _max: MembershipMaxAggregateOutputType | null;
  };

  export type MembershipMinAggregateOutputType = {
    id: string | null;
    role: $Enums.MemberRole | null;
    joinedAt: Date | null;
    userId: string | null;
    organizationId: string | null;
  };

  export type MembershipMaxAggregateOutputType = {
    id: string | null;
    role: $Enums.MemberRole | null;
    joinedAt: Date | null;
    userId: string | null;
    organizationId: string | null;
  };

  export type MembershipCountAggregateOutputType = {
    id: number;
    role: number;
    joinedAt: number;
    userId: number;
    organizationId: number;
    _all: number;
  };

  export type MembershipMinAggregateInputType = {
    id?: true;
    role?: true;
    joinedAt?: true;
    userId?: true;
    organizationId?: true;
  };

  export type MembershipMaxAggregateInputType = {
    id?: true;
    role?: true;
    joinedAt?: true;
    userId?: true;
    organizationId?: true;
  };

  export type MembershipCountAggregateInputType = {
    id?: true;
    role?: true;
    joinedAt?: true;
    userId?: true;
    organizationId?: true;
    _all?: true;
  };

  export type MembershipAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Memberships
     **/
    _count?: true | MembershipCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MembershipMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MembershipMaxAggregateInputType;
  };

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
    [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>;
  };

  export type MembershipGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[];
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum;
    having?: MembershipScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MembershipCountAggregateInputType | true;
    _min?: MembershipMinAggregateInputType;
    _max?: MembershipMaxAggregateInputType;
  };

  export type MembershipGroupByOutputType = {
    id: string;
    role: $Enums.MemberRole;
    joinedAt: Date;
    userId: string;
    organizationId: string;
    _count: MembershipCountAggregateOutputType | null;
    _min: MembershipMinAggregateOutputType | null;
    _max: MembershipMaxAggregateOutputType | null;
  };

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> & {
        [P in keyof T & keyof MembershipGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
          : GetScalarType<T[P], MembershipGroupByOutputType[P]>;
      }
    >
  >;

  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        role?: boolean;
        joinedAt?: boolean;
        userId?: boolean;
        organizationId?: boolean;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['membership']
    >;

  export type MembershipSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      role?: boolean;
      joinedAt?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['membership']
  >;

  export type MembershipSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      role?: boolean;
      joinedAt?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['membership']
  >;

  export type MembershipSelectScalar = {
    id?: boolean;
    role?: boolean;
    joinedAt?: boolean;
    userId?: boolean;
    organizationId?: boolean;
  };

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'role' | 'joinedAt' | 'userId' | 'organizationId',
      ExtArgs['result']['membership']
    >;
  export type MembershipInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type MembershipIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type MembershipIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $MembershipPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Membership';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        role: $Enums.MemberRole;
        joinedAt: Date;
        userId: string;
        organizationId: string;
      },
      ExtArgs['result']['membership']
    >;
    composites: {};
  };

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> =
    $Result.GetResult<Prisma.$MembershipPayload, S>;

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true;
    };

  export interface MembershipDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Membership'];
      meta: { name: 'Membership' };
    };
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(
      args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(
      args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     *
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MembershipFindManyArgs>(
      args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     *
     */
    create<T extends MembershipCreateArgs>(
      args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MembershipCreateManyArgs>(
      args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     *
     */
    delete<T extends MembershipDeleteArgs>(
      args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MembershipUpdateArgs>(
      args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MembershipDeleteManyArgs>(
      args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MembershipUpdateManyArgs>(
      args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MembershipPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(
      args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>
    ): Prisma__MembershipClient<
      $Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
     **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MembershipAggregateArgs>(
      args: Subset<T, MembershipAggregateArgs>
    ): Prisma.PrismaPromise<GetMembershipAggregateType<T>>;

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Membership model
     */
    readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<'Membership', 'String'>;
    readonly role: FieldRef<'Membership', 'MemberRole'>;
    readonly joinedAt: FieldRef<'Membership', 'DateTime'>;
    readonly userId: FieldRef<'Membership', 'String'>;
    readonly organizationId: FieldRef<'Membership', 'String'>;
  }

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Memberships.
     */
    skip?: number;
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[];
  };

  /**
   * Membership create
   */
  export type MembershipCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>;
  };

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>;
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>;
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to update.
     */
    limit?: number;
  };

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>;
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput;
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>;
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>;
  };

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput;
  };

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput;
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number;
  };

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null;
  };

  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null;
    _min: InvitationMinAggregateOutputType | null;
    _max: InvitationMaxAggregateOutputType | null;
  };

  export type InvitationMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    role: $Enums.MemberRole | null;
    token: string | null;
    expiresAt: Date | null;
    acceptedAt: Date | null;
    createdAt: Date | null;
    organizationId: string | null;
    invitedById: string | null;
  };

  export type InvitationMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    role: $Enums.MemberRole | null;
    token: string | null;
    expiresAt: Date | null;
    acceptedAt: Date | null;
    createdAt: Date | null;
    organizationId: string | null;
    invitedById: string | null;
  };

  export type InvitationCountAggregateOutputType = {
    id: number;
    email: number;
    role: number;
    token: number;
    expiresAt: number;
    acceptedAt: number;
    createdAt: number;
    organizationId: number;
    invitedById: number;
    _all: number;
  };

  export type InvitationMinAggregateInputType = {
    id?: true;
    email?: true;
    role?: true;
    token?: true;
    expiresAt?: true;
    acceptedAt?: true;
    createdAt?: true;
    organizationId?: true;
    invitedById?: true;
  };

  export type InvitationMaxAggregateInputType = {
    id?: true;
    email?: true;
    role?: true;
    token?: true;
    expiresAt?: true;
    acceptedAt?: true;
    createdAt?: true;
    organizationId?: true;
    invitedById?: true;
  };

  export type InvitationCountAggregateInputType = {
    id?: true;
    email?: true;
    role?: true;
    token?: true;
    expiresAt?: true;
    acceptedAt?: true;
    createdAt?: true;
    organizationId?: true;
    invitedById?: true;
    _all?: true;
  };

  export type InvitationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invitations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Invitations
     **/
    _count?: true | InvitationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InvitationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InvitationMaxAggregateInputType;
  };

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
    [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>;
  };

  export type InvitationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[];
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum;
    having?: InvitationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InvitationCountAggregateInputType | true;
    _min?: InvitationMinAggregateInputType;
    _max?: InvitationMaxAggregateInputType;
  };

  export type InvitationGroupByOutputType = {
    id: string;
    email: string;
    role: $Enums.MemberRole;
    token: string;
    expiresAt: Date;
    acceptedAt: Date | null;
    createdAt: Date;
    organizationId: string;
    invitedById: string;
    _count: InvitationCountAggregateOutputType | null;
    _min: InvitationMinAggregateOutputType | null;
    _max: InvitationMaxAggregateOutputType | null;
  };

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof InvitationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
          : GetScalarType<T[P], InvitationGroupByOutputType[P]>;
      }
    >
  >;

  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        role?: boolean;
        token?: boolean;
        expiresAt?: boolean;
        acceptedAt?: boolean;
        createdAt?: boolean;
        organizationId?: boolean;
        invitedById?: boolean;
        invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['invitation']
    >;

  export type InvitationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      role?: boolean;
      token?: boolean;
      expiresAt?: boolean;
      acceptedAt?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      invitedById?: boolean;
      invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invitation']
  >;

  export type InvitationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      role?: boolean;
      token?: boolean;
      expiresAt?: boolean;
      acceptedAt?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      invitedById?: boolean;
      invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invitation']
  >;

  export type InvitationSelectScalar = {
    id?: boolean;
    email?: boolean;
    role?: boolean;
    token?: boolean;
    expiresAt?: boolean;
    acceptedAt?: boolean;
    createdAt?: boolean;
    organizationId?: boolean;
    invitedById?: boolean;
  };

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'email'
      | 'role'
      | 'token'
      | 'expiresAt'
      | 'acceptedAt'
      | 'createdAt'
      | 'organizationId'
      | 'invitedById',
      ExtArgs['result']['invitation']
    >;
  export type InvitationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type InvitationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type InvitationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $InvitationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Invitation';
    objects: {
      invitedBy: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        role: $Enums.MemberRole;
        token: string;
        expiresAt: Date;
        acceptedAt: Date | null;
        createdAt: Date;
        organizationId: string;
        invitedById: string;
      },
      ExtArgs['result']['invitation']
    >;
    composites: {};
  };

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> =
    $Result.GetResult<Prisma.$InvitationPayload, S>;

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true;
    };

  export interface InvitationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Invitation'];
      meta: { name: 'Invitation' };
    };
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(
      args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(
      args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     *
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InvitationFindManyArgs>(
      args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     *
     */
    create<T extends InvitationCreateArgs>(
      args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InvitationCreateManyArgs>(
      args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     *
     */
    delete<T extends InvitationDeleteArgs>(
      args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InvitationUpdateArgs>(
      args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InvitationDeleteManyArgs>(
      args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InvitationUpdateManyArgs>(
      args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvitationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(
      args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>
    ): Prisma__InvitationClient<
      $Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
     **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InvitationAggregateArgs>(
      args: Subset<T, InvitationAggregateArgs>
    ): Prisma.PrismaPromise<GetInvitationAggregateType<T>>;

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Invitation model
     */
    readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    invitedBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<'Invitation', 'String'>;
    readonly email: FieldRef<'Invitation', 'String'>;
    readonly role: FieldRef<'Invitation', 'MemberRole'>;
    readonly token: FieldRef<'Invitation', 'String'>;
    readonly expiresAt: FieldRef<'Invitation', 'DateTime'>;
    readonly acceptedAt: FieldRef<'Invitation', 'DateTime'>;
    readonly createdAt: FieldRef<'Invitation', 'DateTime'>;
    readonly organizationId: FieldRef<'Invitation', 'String'>;
    readonly invitedById: FieldRef<'Invitation', 'String'>;
  }

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput;
  };

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput;
  };

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invitations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[];
  };

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invitations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[];
  };

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invitations.
     */
    skip?: number;
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[];
  };

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>;
  };

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>;
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput;
  };

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>;
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput;
    /**
     * Limit how many Invitations to update.
     */
    limit?: number;
  };

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>;
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput;
    /**
     * Limit how many Invitations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput;
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>;
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>;
  };

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput;
  };

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput;
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number;
  };

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null;
  };

  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null;
    token: string | null;
    email: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null;
    token: string | null;
    email: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number;
    token: number;
    email: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true;
    token?: true;
    email?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true;
    token?: true;
    email?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true;
    token?: true;
    email?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type EmailVerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EmailVerificationTokens
     **/
    _count?: true | EmailVerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EmailVerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type GetEmailVerificationTokenAggregateType<
    T extends EmailVerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateEmailVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>;
  };

  export type EmailVerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EmailVerificationTokenWhereInput;
    orderBy?:
      | EmailVerificationTokenOrderByWithAggregationInput
      | EmailVerificationTokenOrderByWithAggregationInput[];
    by: EmailVerificationTokenScalarFieldEnum[] | EmailVerificationTokenScalarFieldEnum;
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EmailVerificationTokenCountAggregateInputType | true;
    _min?: EmailVerificationTokenMinAggregateInputType;
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type EmailVerificationTokenGroupByOutputType = {
    id: string;
    token: string;
    email: string;
    expiresAt: Date;
    createdAt: Date;
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  type GetEmailVerificationTokenGroupByPayload<T extends EmailVerificationTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof EmailVerificationTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type EmailVerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      email?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['emailVerificationToken']
  >;

  export type EmailVerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      email?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['emailVerificationToken']
  >;

  export type EmailVerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      email?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['emailVerificationToken']
  >;

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean;
    token?: boolean;
    email?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type EmailVerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'token' | 'email' | 'expiresAt' | 'createdAt',
    ExtArgs['result']['emailVerificationToken']
  >;

  export type $EmailVerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'EmailVerificationToken';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        token: string;
        email: string;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['emailVerificationToken']
    >;
    composites: {};
  };

  type EmailVerificationTokenGetPayload<
    S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>;

  type EmailVerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<EmailVerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EmailVerificationTokenCountAggregateInputType | true;
  };

  export interface EmailVerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'];
      meta: { name: 'EmailVerificationToken' };
    };
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     *
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     *
     */
    create<T extends EmailVerificationTokenCreateArgs>(
      args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends EmailVerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     *
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(
      args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EmailVerificationTokenUpdateArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends EmailVerificationTokenUpdateManyAndReturnArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(
      args: Subset<T, EmailVerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>;

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EmailVerificationTokenGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetEmailVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the EmailVerificationToken model
     */
    readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<'EmailVerificationToken', 'String'>;
    readonly token: FieldRef<'EmailVerificationToken', 'String'>;
    readonly email: FieldRef<'EmailVerificationToken', 'String'>;
    readonly expiresAt: FieldRef<'EmailVerificationToken', 'DateTime'>;
    readonly createdAt: FieldRef<'EmailVerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    distinct?: EmailVerificationTokenScalarFieldEnum | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>;
  };

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data: EmailVerificationTokenCreateManyInput | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>;
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput;
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<EmailVerificationTokenCreateInput, EmailVerificationTokenUncheckedCreateInput>;
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationTokenUpdateInput, EmailVerificationTokenUncheckedUpdateInput>;
  };

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Model BillingEvent
   */

  export type AggregateBillingEvent = {
    _count: BillingEventCountAggregateOutputType | null;
    _min: BillingEventMinAggregateOutputType | null;
    _max: BillingEventMaxAggregateOutputType | null;
  };

  export type BillingEventMinAggregateOutputType = {
    id: string | null;
    eventType: string | null;
    stripeEventId: string | null;
    createdAt: Date | null;
    organizationId: string | null;
    subscriptionId: string | null;
  };

  export type BillingEventMaxAggregateOutputType = {
    id: string | null;
    eventType: string | null;
    stripeEventId: string | null;
    createdAt: Date | null;
    organizationId: string | null;
    subscriptionId: string | null;
  };

  export type BillingEventCountAggregateOutputType = {
    id: number;
    eventType: number;
    stripeEventId: number;
    metadata: number;
    createdAt: number;
    organizationId: number;
    subscriptionId: number;
    _all: number;
  };

  export type BillingEventMinAggregateInputType = {
    id?: true;
    eventType?: true;
    stripeEventId?: true;
    createdAt?: true;
    organizationId?: true;
    subscriptionId?: true;
  };

  export type BillingEventMaxAggregateInputType = {
    id?: true;
    eventType?: true;
    stripeEventId?: true;
    createdAt?: true;
    organizationId?: true;
    subscriptionId?: true;
  };

  export type BillingEventCountAggregateInputType = {
    id?: true;
    eventType?: true;
    stripeEventId?: true;
    metadata?: true;
    createdAt?: true;
    organizationId?: true;
    subscriptionId?: true;
    _all?: true;
  };

  export type BillingEventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BillingEvent to aggregate.
     */
    where?: BillingEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BillingEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BillingEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BillingEvents
     **/
    _count?: true | BillingEventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BillingEventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BillingEventMaxAggregateInputType;
  };

  export type GetBillingEventAggregateType<T extends BillingEventAggregateArgs> = {
    [P in keyof T & keyof AggregateBillingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingEvent[P]>
      : GetScalarType<T[P], AggregateBillingEvent[P]>;
  };

  export type BillingEventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BillingEventWhereInput;
    orderBy?: BillingEventOrderByWithAggregationInput | BillingEventOrderByWithAggregationInput[];
    by: BillingEventScalarFieldEnum[] | BillingEventScalarFieldEnum;
    having?: BillingEventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BillingEventCountAggregateInputType | true;
    _min?: BillingEventMinAggregateInputType;
    _max?: BillingEventMaxAggregateInputType;
  };

  export type BillingEventGroupByOutputType = {
    id: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonValue;
    createdAt: Date;
    organizationId: string | null;
    subscriptionId: string | null;
    _count: BillingEventCountAggregateOutputType | null;
    _min: BillingEventMinAggregateOutputType | null;
    _max: BillingEventMaxAggregateOutputType | null;
  };

  type GetBillingEventGroupByPayload<T extends BillingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingEventGroupByOutputType, T['by']> & {
        [P in keyof T & keyof BillingEventGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], BillingEventGroupByOutputType[P]>
          : GetScalarType<T[P], BillingEventGroupByOutputType[P]>;
      }
    >
  >;

  export type BillingEventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventType?: boolean;
      stripeEventId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      subscriptionId?: boolean;
      organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
      subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
    },
    ExtArgs['result']['billingEvent']
  >;

  export type BillingEventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventType?: boolean;
      stripeEventId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      subscriptionId?: boolean;
      organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
      subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
    },
    ExtArgs['result']['billingEvent']
  >;

  export type BillingEventSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventType?: boolean;
      stripeEventId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      subscriptionId?: boolean;
      organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
      subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
    },
    ExtArgs['result']['billingEvent']
  >;

  export type BillingEventSelectScalar = {
    id?: boolean;
    eventType?: boolean;
    stripeEventId?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    organizationId?: boolean;
    subscriptionId?: boolean;
  };

  export type BillingEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'eventType'
      | 'stripeEventId'
      | 'metadata'
      | 'createdAt'
      | 'organizationId'
      | 'subscriptionId',
      ExtArgs['result']['billingEvent']
    >;
  export type BillingEventInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
    subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
  };
  export type BillingEventIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
    subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
  };
  export type BillingEventIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | BillingEvent$organizationArgs<ExtArgs>;
    subscription?: boolean | BillingEvent$subscriptionArgs<ExtArgs>;
  };

  export type $BillingEventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'BillingEvent';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null;
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventType: string;
        stripeEventId: string;
        metadata: Prisma.JsonValue;
        createdAt: Date;
        organizationId: string | null;
        subscriptionId: string | null;
      },
      ExtArgs['result']['billingEvent']
    >;
    composites: {};
  };

  type BillingEventGetPayload<S extends boolean | null | undefined | BillingEventDefaultArgs> =
    $Result.GetResult<Prisma.$BillingEventPayload, S>;

  type BillingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingEventCountAggregateInputType | true;
    };

  export interface BillingEventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['BillingEvent'];
      meta: { name: 'BillingEvent' };
    };
    /**
     * Find zero or one BillingEvent that matches the filter.
     * @param {BillingEventFindUniqueArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingEventFindUniqueArgs>(
      args: SelectSubset<T, BillingEventFindUniqueArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one BillingEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingEventFindUniqueOrThrowArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingEventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BillingEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BillingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindFirstArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingEventFindFirstArgs>(
      args?: SelectSubset<T, BillingEventFindFirstArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BillingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindFirstOrThrowArgs} args - Arguments to find a BillingEvent
     * @example
     * // Get one BillingEvent
     * const billingEvent = await prisma.billingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BillingEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more BillingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingEvents
     * const billingEvents = await prisma.billingEvent.findMany()
     *
     * // Get first 10 BillingEvents
     * const billingEvents = await prisma.billingEvent.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const billingEventWithIdOnly = await prisma.billingEvent.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BillingEventFindManyArgs>(
      args?: SelectSubset<T, BillingEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a BillingEvent.
     * @param {BillingEventCreateArgs} args - Arguments to create a BillingEvent.
     * @example
     * // Create one BillingEvent
     * const BillingEvent = await prisma.billingEvent.create({
     *   data: {
     *     // ... data to create a BillingEvent
     *   }
     * })
     *
     */
    create<T extends BillingEventCreateArgs>(
      args: SelectSubset<T, BillingEventCreateArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many BillingEvents.
     * @param {BillingEventCreateManyArgs} args - Arguments to create many BillingEvents.
     * @example
     * // Create many BillingEvents
     * const billingEvent = await prisma.billingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BillingEventCreateManyArgs>(
      args?: SelectSubset<T, BillingEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many BillingEvents and returns the data saved in the database.
     * @param {BillingEventCreateManyAndReturnArgs} args - Arguments to create many BillingEvents.
     * @example
     * // Create many BillingEvents
     * const billingEvent = await prisma.billingEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many BillingEvents and only return the `id`
     * const billingEventWithIdOnly = await prisma.billingEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BillingEventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BillingEventCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a BillingEvent.
     * @param {BillingEventDeleteArgs} args - Arguments to delete one BillingEvent.
     * @example
     * // Delete one BillingEvent
     * const BillingEvent = await prisma.billingEvent.delete({
     *   where: {
     *     // ... filter to delete one BillingEvent
     *   }
     * })
     *
     */
    delete<T extends BillingEventDeleteArgs>(
      args: SelectSubset<T, BillingEventDeleteArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one BillingEvent.
     * @param {BillingEventUpdateArgs} args - Arguments to update one BillingEvent.
     * @example
     * // Update one BillingEvent
     * const billingEvent = await prisma.billingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BillingEventUpdateArgs>(
      args: SelectSubset<T, BillingEventUpdateArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more BillingEvents.
     * @param {BillingEventDeleteManyArgs} args - Arguments to filter BillingEvents to delete.
     * @example
     * // Delete a few BillingEvents
     * const { count } = await prisma.billingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BillingEventDeleteManyArgs>(
      args?: SelectSubset<T, BillingEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BillingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingEvents
     * const billingEvent = await prisma.billingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BillingEventUpdateManyArgs>(
      args: SelectSubset<T, BillingEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BillingEvents and returns the data updated in the database.
     * @param {BillingEventUpdateManyAndReturnArgs} args - Arguments to update many BillingEvents.
     * @example
     * // Update many BillingEvents
     * const billingEvent = await prisma.billingEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more BillingEvents and only return the `id`
     * const billingEventWithIdOnly = await prisma.billingEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BillingEventUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BillingEventUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BillingEventPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one BillingEvent.
     * @param {BillingEventUpsertArgs} args - Arguments to update or create a BillingEvent.
     * @example
     * // Update or create a BillingEvent
     * const billingEvent = await prisma.billingEvent.upsert({
     *   create: {
     *     // ... data to create a BillingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingEvent we want to update
     *   }
     * })
     */
    upsert<T extends BillingEventUpsertArgs>(
      args: SelectSubset<T, BillingEventUpsertArgs<ExtArgs>>
    ): Prisma__BillingEventClient<
      $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of BillingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventCountArgs} args - Arguments to filter BillingEvents to count.
     * @example
     * // Count the number of BillingEvents
     * const count = await prisma.billingEvent.count({
     *   where: {
     *     // ... the filter for the BillingEvents we want to count
     *   }
     * })
     **/
    count<T extends BillingEventCountArgs>(
      args?: Subset<T, BillingEventCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingEventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a BillingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BillingEventAggregateArgs>(
      args: Subset<T, BillingEventAggregateArgs>
    ): Prisma.PrismaPromise<GetBillingEventAggregateType<T>>;

    /**
     * Group by BillingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BillingEventGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingEventGroupByArgs['orderBy'] }
        : { orderBy?: BillingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BillingEventGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetBillingEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the BillingEvent model
     */
    readonly fields: BillingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingEventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends BillingEvent$organizationArgs<ExtArgs> = {}>(
      args?: Subset<T, BillingEvent$organizationArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subscription<T extends BillingEvent$subscriptionArgs<ExtArgs> = {}>(
      args?: Subset<T, BillingEvent$subscriptionArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the BillingEvent model
   */
  interface BillingEventFieldRefs {
    readonly id: FieldRef<'BillingEvent', 'String'>;
    readonly eventType: FieldRef<'BillingEvent', 'String'>;
    readonly stripeEventId: FieldRef<'BillingEvent', 'String'>;
    readonly metadata: FieldRef<'BillingEvent', 'Json'>;
    readonly createdAt: FieldRef<'BillingEvent', 'DateTime'>;
    readonly organizationId: FieldRef<'BillingEvent', 'String'>;
    readonly subscriptionId: FieldRef<'BillingEvent', 'String'>;
  }

  // Custom InputTypes
  /**
   * BillingEvent findUnique
   */
  export type BillingEventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter, which BillingEvent to fetch.
     */
    where: BillingEventWhereUniqueInput;
  };

  /**
   * BillingEvent findUniqueOrThrow
   */
  export type BillingEventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter, which BillingEvent to fetch.
     */
    where: BillingEventWhereUniqueInput;
  };

  /**
   * BillingEvent findFirst
   */
  export type BillingEventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter, which BillingEvent to fetch.
     */
    where?: BillingEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BillingEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BillingEvents.
     */
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[];
  };

  /**
   * BillingEvent findFirstOrThrow
   */
  export type BillingEventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter, which BillingEvent to fetch.
     */
    where?: BillingEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BillingEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BillingEvents.
     */
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[];
  };

  /**
   * BillingEvent findMany
   */
  export type BillingEventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter, which BillingEvents to fetch.
     */
    where?: BillingEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BillingEvents to fetch.
     */
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BillingEvents.
     */
    cursor?: BillingEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BillingEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BillingEvents.
     */
    skip?: number;
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[];
  };

  /**
   * BillingEvent create
   */
  export type BillingEventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * The data needed to create a BillingEvent.
     */
    data: XOR<BillingEventCreateInput, BillingEventUncheckedCreateInput>;
  };

  /**
   * BillingEvent createMany
   */
  export type BillingEventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many BillingEvents.
     */
    data: BillingEventCreateManyInput | BillingEventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * BillingEvent createManyAndReturn
   */
  export type BillingEventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * The data used to create many BillingEvents.
     */
    data: BillingEventCreateManyInput | BillingEventCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BillingEvent update
   */
  export type BillingEventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * The data needed to update a BillingEvent.
     */
    data: XOR<BillingEventUpdateInput, BillingEventUncheckedUpdateInput>;
    /**
     * Choose, which BillingEvent to update.
     */
    where: BillingEventWhereUniqueInput;
  };

  /**
   * BillingEvent updateMany
   */
  export type BillingEventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update BillingEvents.
     */
    data: XOR<BillingEventUpdateManyMutationInput, BillingEventUncheckedUpdateManyInput>;
    /**
     * Filter which BillingEvents to update
     */
    where?: BillingEventWhereInput;
    /**
     * Limit how many BillingEvents to update.
     */
    limit?: number;
  };

  /**
   * BillingEvent updateManyAndReturn
   */
  export type BillingEventUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * The data used to update BillingEvents.
     */
    data: XOR<BillingEventUpdateManyMutationInput, BillingEventUncheckedUpdateManyInput>;
    /**
     * Filter which BillingEvents to update
     */
    where?: BillingEventWhereInput;
    /**
     * Limit how many BillingEvents to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BillingEvent upsert
   */
  export type BillingEventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * The filter to search for the BillingEvent to update in case it exists.
     */
    where: BillingEventWhereUniqueInput;
    /**
     * In case the BillingEvent found by the `where` argument doesn't exist, create a new BillingEvent with this data.
     */
    create: XOR<BillingEventCreateInput, BillingEventUncheckedCreateInput>;
    /**
     * In case the BillingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingEventUpdateInput, BillingEventUncheckedUpdateInput>;
  };

  /**
   * BillingEvent delete
   */
  export type BillingEventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    /**
     * Filter which BillingEvent to delete.
     */
    where: BillingEventWhereUniqueInput;
  };

  /**
   * BillingEvent deleteMany
   */
  export type BillingEventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BillingEvents to delete
     */
    where?: BillingEventWhereInput;
    /**
     * Limit how many BillingEvents to delete.
     */
    limit?: number;
  };

  /**
   * BillingEvent.organization
   */
  export type BillingEvent$organizationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    where?: OrganizationWhereInput;
  };

  /**
   * BillingEvent.subscription
   */
  export type BillingEvent$subscriptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    where?: SubscriptionWhereInput;
  };

  /**
   * BillingEvent without action
   */
  export type BillingEventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
  };

  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null;
    _avg: SubscriptionAvgAggregateOutputType | null;
    _sum: SubscriptionSumAggregateOutputType | null;
    _min: SubscriptionMinAggregateOutputType | null;
    _max: SubscriptionMaxAggregateOutputType | null;
  };

  export type SubscriptionAvgAggregateOutputType = {
    maxDatabaseConnections: number | null;
    maxApiCallsPerMonth: number | null;
    maxUsersPerOrg: number | null;
    maxWorkflows: number | null;
  };

  export type SubscriptionSumAggregateOutputType = {
    maxDatabaseConnections: number | null;
    maxApiCallsPerMonth: number | null;
    maxUsersPerOrg: number | null;
    maxWorkflows: number | null;
  };

  export type SubscriptionMinAggregateOutputType = {
    id: string | null;
    plan: $Enums.SubscriptionPlan | null;
    status: $Enums.SubscriptionStatus | null;
    trialEndsAt: Date | null;
    currentPeriodStart: Date | null;
    currentPeriodEnd: Date | null;
    canceledAt: Date | null;
    stripeCustomerId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    maxDatabaseConnections: number | null;
    maxApiCallsPerMonth: number | null;
    maxUsersPerOrg: number | null;
    maxWorkflows: number | null;
    organizationId: string | null;
  };

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null;
    plan: $Enums.SubscriptionPlan | null;
    status: $Enums.SubscriptionStatus | null;
    trialEndsAt: Date | null;
    currentPeriodStart: Date | null;
    currentPeriodEnd: Date | null;
    canceledAt: Date | null;
    stripeCustomerId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    maxDatabaseConnections: number | null;
    maxApiCallsPerMonth: number | null;
    maxUsersPerOrg: number | null;
    maxWorkflows: number | null;
    organizationId: string | null;
  };

  export type SubscriptionCountAggregateOutputType = {
    id: number;
    plan: number;
    status: number;
    trialEndsAt: number;
    currentPeriodStart: number;
    currentPeriodEnd: number;
    canceledAt: number;
    stripeCustomerId: number;
    stripeSubscriptionId: number;
    stripePriceId: number;
    createdAt: number;
    updatedAt: number;
    maxDatabaseConnections: number;
    maxApiCallsPerMonth: number;
    maxUsersPerOrg: number;
    maxWorkflows: number;
    organizationId: number;
    _all: number;
  };

  export type SubscriptionAvgAggregateInputType = {
    maxDatabaseConnections?: true;
    maxApiCallsPerMonth?: true;
    maxUsersPerOrg?: true;
    maxWorkflows?: true;
  };

  export type SubscriptionSumAggregateInputType = {
    maxDatabaseConnections?: true;
    maxApiCallsPerMonth?: true;
    maxUsersPerOrg?: true;
    maxWorkflows?: true;
  };

  export type SubscriptionMinAggregateInputType = {
    id?: true;
    plan?: true;
    status?: true;
    trialEndsAt?: true;
    currentPeriodStart?: true;
    currentPeriodEnd?: true;
    canceledAt?: true;
    stripeCustomerId?: true;
    stripeSubscriptionId?: true;
    stripePriceId?: true;
    createdAt?: true;
    updatedAt?: true;
    maxDatabaseConnections?: true;
    maxApiCallsPerMonth?: true;
    maxUsersPerOrg?: true;
    maxWorkflows?: true;
    organizationId?: true;
  };

  export type SubscriptionMaxAggregateInputType = {
    id?: true;
    plan?: true;
    status?: true;
    trialEndsAt?: true;
    currentPeriodStart?: true;
    currentPeriodEnd?: true;
    canceledAt?: true;
    stripeCustomerId?: true;
    stripeSubscriptionId?: true;
    stripePriceId?: true;
    createdAt?: true;
    updatedAt?: true;
    maxDatabaseConnections?: true;
    maxApiCallsPerMonth?: true;
    maxUsersPerOrg?: true;
    maxWorkflows?: true;
    organizationId?: true;
  };

  export type SubscriptionCountAggregateInputType = {
    id?: true;
    plan?: true;
    status?: true;
    trialEndsAt?: true;
    currentPeriodStart?: true;
    currentPeriodEnd?: true;
    canceledAt?: true;
    stripeCustomerId?: true;
    stripeSubscriptionId?: true;
    stripePriceId?: true;
    createdAt?: true;
    updatedAt?: true;
    maxDatabaseConnections?: true;
    maxApiCallsPerMonth?: true;
    maxUsersPerOrg?: true;
    maxWorkflows?: true;
    organizationId?: true;
    _all?: true;
  };

  export type SubscriptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Subscriptions
     **/
    _count?: true | SubscriptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SubscriptionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SubscriptionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubscriptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubscriptionMaxAggregateInputType;
  };

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
    [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>;
  };

  export type SubscriptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubscriptionWhereInput;
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[];
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum;
    having?: SubscriptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubscriptionCountAggregateInputType | true;
    _avg?: SubscriptionAvgAggregateInputType;
    _sum?: SubscriptionSumAggregateInputType;
    _min?: SubscriptionMinAggregateInputType;
    _max?: SubscriptionMaxAggregateInputType;
  };

  export type SubscriptionGroupByOutputType = {
    id: string;
    plan: $Enums.SubscriptionPlan;
    status: $Enums.SubscriptionStatus;
    trialEndsAt: Date | null;
    currentPeriodStart: Date;
    currentPeriodEnd: Date;
    canceledAt: Date | null;
    stripeCustomerId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    createdAt: Date;
    updatedAt: Date;
    maxDatabaseConnections: number;
    maxApiCallsPerMonth: number;
    maxUsersPerOrg: number;
    maxWorkflows: number;
    organizationId: string;
    _count: SubscriptionCountAggregateOutputType | null;
    _avg: SubscriptionAvgAggregateOutputType | null;
    _sum: SubscriptionSumAggregateOutputType | null;
    _min: SubscriptionMinAggregateOutputType | null;
    _max: SubscriptionMaxAggregateOutputType | null;
  };

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SubscriptionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
          : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>;
      }
    >
  >;

  export type SubscriptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      plan?: boolean;
      status?: boolean;
      trialEndsAt?: boolean;
      currentPeriodStart?: boolean;
      currentPeriodEnd?: boolean;
      canceledAt?: boolean;
      stripeCustomerId?: boolean;
      stripeSubscriptionId?: boolean;
      stripePriceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      maxDatabaseConnections?: boolean;
      maxApiCallsPerMonth?: boolean;
      maxUsersPerOrg?: boolean;
      maxWorkflows?: boolean;
      organizationId?: boolean;
      invoices?: boolean | Subscription$invoicesArgs<ExtArgs>;
      billingEvents?: boolean | Subscription$billingEventsArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      plan?: boolean;
      status?: boolean;
      trialEndsAt?: boolean;
      currentPeriodStart?: boolean;
      currentPeriodEnd?: boolean;
      canceledAt?: boolean;
      stripeCustomerId?: boolean;
      stripeSubscriptionId?: boolean;
      stripePriceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      maxDatabaseConnections?: boolean;
      maxApiCallsPerMonth?: boolean;
      maxUsersPerOrg?: boolean;
      maxWorkflows?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      plan?: boolean;
      status?: boolean;
      trialEndsAt?: boolean;
      currentPeriodStart?: boolean;
      currentPeriodEnd?: boolean;
      canceledAt?: boolean;
      stripeCustomerId?: boolean;
      stripeSubscriptionId?: boolean;
      stripePriceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      maxDatabaseConnections?: boolean;
      maxApiCallsPerMonth?: boolean;
      maxUsersPerOrg?: boolean;
      maxWorkflows?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['subscription']
  >;

  export type SubscriptionSelectScalar = {
    id?: boolean;
    plan?: boolean;
    status?: boolean;
    trialEndsAt?: boolean;
    currentPeriodStart?: boolean;
    currentPeriodEnd?: boolean;
    canceledAt?: boolean;
    stripeCustomerId?: boolean;
    stripeSubscriptionId?: boolean;
    stripePriceId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    maxDatabaseConnections?: boolean;
    maxApiCallsPerMonth?: boolean;
    maxUsersPerOrg?: boolean;
    maxWorkflows?: boolean;
    organizationId?: boolean;
  };

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'plan'
      | 'status'
      | 'trialEndsAt'
      | 'currentPeriodStart'
      | 'currentPeriodEnd'
      | 'canceledAt'
      | 'stripeCustomerId'
      | 'stripeSubscriptionId'
      | 'stripePriceId'
      | 'createdAt'
      | 'updatedAt'
      | 'maxDatabaseConnections'
      | 'maxApiCallsPerMonth'
      | 'maxUsersPerOrg'
      | 'maxWorkflows'
      | 'organizationId',
      ExtArgs['result']['subscription']
    >;
  export type SubscriptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>;
    billingEvents?: boolean | Subscription$billingEventsArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SubscriptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type SubscriptionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $SubscriptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Subscription';
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[];
      billingEvents: Prisma.$BillingEventPayload<ExtArgs>[];
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        plan: $Enums.SubscriptionPlan;
        status: $Enums.SubscriptionStatus;
        trialEndsAt: Date | null;
        currentPeriodStart: Date;
        currentPeriodEnd: Date;
        canceledAt: Date | null;
        stripeCustomerId: string | null;
        stripeSubscriptionId: string | null;
        stripePriceId: string | null;
        createdAt: Date;
        updatedAt: Date;
        maxDatabaseConnections: number;
        maxApiCallsPerMonth: number;
        maxUsersPerOrg: number;
        maxWorkflows: number;
        organizationId: string;
      },
      ExtArgs['result']['subscription']
    >;
    composites: {};
  };

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> =
    $Result.GetResult<Prisma.$SubscriptionPayload, S>;

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true;
    };

  export interface SubscriptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Subscription'];
      meta: { name: 'Subscription' };
    };
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     *
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     *
     */
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     *
     */
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      $Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
     **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubscriptionAggregateArgs>(
      args: Subset<T, SubscriptionAggregateArgs>
    ): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>;

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSubscriptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Subscription model
     */
    readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    billingEvents<T extends Subscription$billingEventsArgs<ExtArgs> = {}>(
      args?: Subset<T, Subscription$billingEventsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$BillingEventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<'Subscription', 'String'>;
    readonly plan: FieldRef<'Subscription', 'SubscriptionPlan'>;
    readonly status: FieldRef<'Subscription', 'SubscriptionStatus'>;
    readonly trialEndsAt: FieldRef<'Subscription', 'DateTime'>;
    readonly currentPeriodStart: FieldRef<'Subscription', 'DateTime'>;
    readonly currentPeriodEnd: FieldRef<'Subscription', 'DateTime'>;
    readonly canceledAt: FieldRef<'Subscription', 'DateTime'>;
    readonly stripeCustomerId: FieldRef<'Subscription', 'String'>;
    readonly stripeSubscriptionId: FieldRef<'Subscription', 'String'>;
    readonly stripePriceId: FieldRef<'Subscription', 'String'>;
    readonly createdAt: FieldRef<'Subscription', 'DateTime'>;
    readonly updatedAt: FieldRef<'Subscription', 'DateTime'>;
    readonly maxDatabaseConnections: FieldRef<'Subscription', 'Int'>;
    readonly maxApiCallsPerMonth: FieldRef<'Subscription', 'Int'>;
    readonly maxUsersPerOrg: FieldRef<'Subscription', 'Int'>;
    readonly maxWorkflows: FieldRef<'Subscription', 'Int'>;
    readonly organizationId: FieldRef<'Subscription', 'String'>;
  }

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subscriptions.
     */
    skip?: number;
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[];
  };

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>;
  };

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>;
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>;
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number;
  };

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>;
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput;
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>;
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>;
  };

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput;
  };

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput;
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number;
  };

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    cursor?: InvoiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Subscription.billingEvents
   */
  export type Subscription$billingEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BillingEvent
     */
    select?: BillingEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BillingEvent
     */
    omit?: BillingEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingEventInclude<ExtArgs> | null;
    where?: BillingEventWhereInput;
    orderBy?: BillingEventOrderByWithRelationInput | BillingEventOrderByWithRelationInput[];
    cursor?: BillingEventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BillingEventScalarFieldEnum | BillingEventScalarFieldEnum[];
  };

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null;
  };

  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null;
    _avg: InvoiceAvgAggregateOutputType | null;
    _sum: InvoiceSumAggregateOutputType | null;
    _min: InvoiceMinAggregateOutputType | null;
    _max: InvoiceMaxAggregateOutputType | null;
  };

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null;
  };

  export type InvoiceSumAggregateOutputType = {
    amount: number | null;
  };

  export type InvoiceMinAggregateOutputType = {
    id: string | null;
    invoiceNumber: string | null;
    amount: number | null;
    currency: string | null;
    status: $Enums.InvoiceStatus | null;
    dueDate: Date | null;
    paidAt: Date | null;
    stripeInvoiceId: string | null;
    stripePaymentIntentId: string | null;
    hostedInvoiceUrl: string | null;
    createdAt: Date | null;
    subscriptionId: string | null;
  };

  export type InvoiceMaxAggregateOutputType = {
    id: string | null;
    invoiceNumber: string | null;
    amount: number | null;
    currency: string | null;
    status: $Enums.InvoiceStatus | null;
    dueDate: Date | null;
    paidAt: Date | null;
    stripeInvoiceId: string | null;
    stripePaymentIntentId: string | null;
    hostedInvoiceUrl: string | null;
    createdAt: Date | null;
    subscriptionId: string | null;
  };

  export type InvoiceCountAggregateOutputType = {
    id: number;
    invoiceNumber: number;
    amount: number;
    currency: number;
    status: number;
    dueDate: number;
    paidAt: number;
    stripeInvoiceId: number;
    stripePaymentIntentId: number;
    hostedInvoiceUrl: number;
    createdAt: number;
    subscriptionId: number;
    _all: number;
  };

  export type InvoiceAvgAggregateInputType = {
    amount?: true;
  };

  export type InvoiceSumAggregateInputType = {
    amount?: true;
  };

  export type InvoiceMinAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    amount?: true;
    currency?: true;
    status?: true;
    dueDate?: true;
    paidAt?: true;
    stripeInvoiceId?: true;
    stripePaymentIntentId?: true;
    hostedInvoiceUrl?: true;
    createdAt?: true;
    subscriptionId?: true;
  };

  export type InvoiceMaxAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    amount?: true;
    currency?: true;
    status?: true;
    dueDate?: true;
    paidAt?: true;
    stripeInvoiceId?: true;
    stripePaymentIntentId?: true;
    hostedInvoiceUrl?: true;
    createdAt?: true;
    subscriptionId?: true;
  };

  export type InvoiceCountAggregateInputType = {
    id?: true;
    invoiceNumber?: true;
    amount?: true;
    currency?: true;
    status?: true;
    dueDate?: true;
    paidAt?: true;
    stripeInvoiceId?: true;
    stripePaymentIntentId?: true;
    hostedInvoiceUrl?: true;
    createdAt?: true;
    subscriptionId?: true;
    _all?: true;
  };

  export type InvoiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Invoices
     **/
    _count?: true | InvoiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InvoiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InvoiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InvoiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InvoiceMaxAggregateInputType;
  };

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
    [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>;
  };

  export type InvoiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[];
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum;
    having?: InvoiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InvoiceCountAggregateInputType | true;
    _avg?: InvoiceAvgAggregateInputType;
    _sum?: InvoiceSumAggregateInputType;
    _min?: InvoiceMinAggregateInputType;
    _max?: InvoiceMaxAggregateInputType;
  };

  export type InvoiceGroupByOutputType = {
    id: string;
    invoiceNumber: string;
    amount: number;
    currency: string;
    status: $Enums.InvoiceStatus;
    dueDate: Date;
    paidAt: Date | null;
    stripeInvoiceId: string | null;
    stripePaymentIntentId: string | null;
    hostedInvoiceUrl: string | null;
    createdAt: Date;
    subscriptionId: string;
    _count: InvoiceCountAggregateOutputType | null;
    _avg: InvoiceAvgAggregateOutputType | null;
    _sum: InvoiceSumAggregateOutputType | null;
    _min: InvoiceMinAggregateOutputType | null;
    _max: InvoiceMaxAggregateOutputType | null;
  };

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof InvoiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
          : GetScalarType<T[P], InvoiceGroupByOutputType[P]>;
      }
    >
  >;

  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        invoiceNumber?: boolean;
        amount?: boolean;
        currency?: boolean;
        status?: boolean;
        dueDate?: boolean;
        paidAt?: boolean;
        stripeInvoiceId?: boolean;
        stripePaymentIntentId?: boolean;
        hostedInvoiceUrl?: boolean;
        createdAt?: boolean;
        subscriptionId?: boolean;
        subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['invoice']
    >;

  export type InvoiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceNumber?: boolean;
      amount?: boolean;
      currency?: boolean;
      status?: boolean;
      dueDate?: boolean;
      paidAt?: boolean;
      stripeInvoiceId?: boolean;
      stripePaymentIntentId?: boolean;
      hostedInvoiceUrl?: boolean;
      createdAt?: boolean;
      subscriptionId?: boolean;
      subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invoice']
  >;

  export type InvoiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      invoiceNumber?: boolean;
      amount?: boolean;
      currency?: boolean;
      status?: boolean;
      dueDate?: boolean;
      paidAt?: boolean;
      stripeInvoiceId?: boolean;
      stripePaymentIntentId?: boolean;
      hostedInvoiceUrl?: boolean;
      createdAt?: boolean;
      subscriptionId?: boolean;
      subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['invoice']
  >;

  export type InvoiceSelectScalar = {
    id?: boolean;
    invoiceNumber?: boolean;
    amount?: boolean;
    currency?: boolean;
    status?: boolean;
    dueDate?: boolean;
    paidAt?: boolean;
    stripeInvoiceId?: boolean;
    stripePaymentIntentId?: boolean;
    hostedInvoiceUrl?: boolean;
    createdAt?: boolean;
    subscriptionId?: boolean;
  };

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'invoiceNumber'
      | 'amount'
      | 'currency'
      | 'status'
      | 'dueDate'
      | 'paidAt'
      | 'stripeInvoiceId'
      | 'stripePaymentIntentId'
      | 'hostedInvoiceUrl'
      | 'createdAt'
      | 'subscriptionId',
      ExtArgs['result']['invoice']
    >;
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };
  export type InvoiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };
  export type InvoiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>;
  };

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Invoice';
      objects: {
        subscription: Prisma.$SubscriptionPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          invoiceNumber: string;
          amount: number;
          currency: string;
          status: $Enums.InvoiceStatus;
          dueDate: Date;
          paidAt: Date | null;
          stripeInvoiceId: string | null;
          stripePaymentIntentId: string | null;
          hostedInvoiceUrl: string | null;
          createdAt: Date;
          subscriptionId: string;
        },
        ExtArgs['result']['invoice']
      >;
      composites: {};
    };

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> =
    $Result.GetResult<Prisma.$InvoicePayload, S>;

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    InvoiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: InvoiceCountAggregateInputType | true;
  };

  export interface InvoiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice']; meta: { name: 'Invoice' } };
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     *
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InvoiceFindManyArgs>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     *
     */
    create<T extends InvoiceCreateArgs>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InvoiceCreateManyArgs>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     *
     */
    delete<T extends InvoiceDeleteArgs>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InvoiceUpdateArgs>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InvoiceUpdateManyArgs>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InvoicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<
      $Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
     **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InvoiceAggregateArgs>(
      args: Subset<T, InvoiceAggregateArgs>
    ): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>;

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Invoice model
     */
    readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<
      | $Result.GetResult<
          Prisma.$SubscriptionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<'Invoice', 'String'>;
    readonly invoiceNumber: FieldRef<'Invoice', 'String'>;
    readonly amount: FieldRef<'Invoice', 'Float'>;
    readonly currency: FieldRef<'Invoice', 'String'>;
    readonly status: FieldRef<'Invoice', 'InvoiceStatus'>;
    readonly dueDate: FieldRef<'Invoice', 'DateTime'>;
    readonly paidAt: FieldRef<'Invoice', 'DateTime'>;
    readonly stripeInvoiceId: FieldRef<'Invoice', 'String'>;
    readonly stripePaymentIntentId: FieldRef<'Invoice', 'String'>;
    readonly hostedInvoiceUrl: FieldRef<'Invoice', 'String'>;
    readonly createdAt: FieldRef<'Invoice', 'DateTime'>;
    readonly subscriptionId: FieldRef<'Invoice', 'String'>;
  }

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Invoices.
     */
    skip?: number;
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[];
  };

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>;
  };

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>;
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>;
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to update.
     */
    limit?: number;
  };

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>;
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput;
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>;
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>;
  };

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput;
  };

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput;
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number;
  };

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null;
  };

  /**
   * Model DatabaseConnection
   */

  export type AggregateDatabaseConnection = {
    _count: DatabaseConnectionCountAggregateOutputType | null;
    _avg: DatabaseConnectionAvgAggregateOutputType | null;
    _sum: DatabaseConnectionSumAggregateOutputType | null;
    _min: DatabaseConnectionMinAggregateOutputType | null;
    _max: DatabaseConnectionMaxAggregateOutputType | null;
  };

  export type DatabaseConnectionAvgAggregateOutputType = {
    port: number | null;
  };

  export type DatabaseConnectionSumAggregateOutputType = {
    port: number | null;
  };

  export type DatabaseConnectionMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: $Enums.DatabaseType | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    passwordEncrypted: string | null;
    sslEnabled: boolean | null;
    isActive: boolean | null;
    lastTestedAt: Date | null;
    lastTestResult: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
  };

  export type DatabaseConnectionMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: $Enums.DatabaseType | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    passwordEncrypted: string | null;
    sslEnabled: boolean | null;
    isActive: boolean | null;
    lastTestedAt: Date | null;
    lastTestResult: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
  };

  export type DatabaseConnectionCountAggregateOutputType = {
    id: number;
    name: number;
    type: number;
    host: number;
    port: number;
    database: number;
    username: number;
    passwordEncrypted: number;
    sslEnabled: number;
    isActive: number;
    lastTestedAt: number;
    lastTestResult: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    createdBy: number;
    databases: number;
    _all: number;
  };

  export type DatabaseConnectionAvgAggregateInputType = {
    port?: true;
  };

  export type DatabaseConnectionSumAggregateInputType = {
    port?: true;
  };

  export type DatabaseConnectionMinAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    sslEnabled?: true;
    isActive?: true;
    lastTestedAt?: true;
    lastTestResult?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
  };

  export type DatabaseConnectionMaxAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    sslEnabled?: true;
    isActive?: true;
    lastTestedAt?: true;
    lastTestResult?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
  };

  export type DatabaseConnectionCountAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    sslEnabled?: true;
    isActive?: true;
    lastTestedAt?: true;
    lastTestResult?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    databases?: true;
    _all?: true;
  };

  export type DatabaseConnectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseConnection to aggregate.
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DatabaseConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DatabaseConnections
     **/
    _count?: true | DatabaseConnectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DatabaseConnectionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DatabaseConnectionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DatabaseConnectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DatabaseConnectionMaxAggregateInputType;
  };

  export type GetDatabaseConnectionAggregateType<T extends DatabaseConnectionAggregateArgs> = {
    [P in keyof T & keyof AggregateDatabaseConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseConnection[P]>
      : GetScalarType<T[P], AggregateDatabaseConnection[P]>;
  };

  export type DatabaseConnectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseConnectionWhereInput;
    orderBy?:
      | DatabaseConnectionOrderByWithAggregationInput
      | DatabaseConnectionOrderByWithAggregationInput[];
    by: DatabaseConnectionScalarFieldEnum[] | DatabaseConnectionScalarFieldEnum;
    having?: DatabaseConnectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DatabaseConnectionCountAggregateInputType | true;
    _avg?: DatabaseConnectionAvgAggregateInputType;
    _sum?: DatabaseConnectionSumAggregateInputType;
    _min?: DatabaseConnectionMinAggregateInputType;
    _max?: DatabaseConnectionMaxAggregateInputType;
  };

  export type DatabaseConnectionGroupByOutputType = {
    id: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled: boolean;
    isActive: boolean;
    lastTestedAt: Date | null;
    lastTestResult: boolean | null;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    createdBy: string | null;
    databases: JsonValue | null;
    _count: DatabaseConnectionCountAggregateOutputType | null;
    _avg: DatabaseConnectionAvgAggregateOutputType | null;
    _sum: DatabaseConnectionSumAggregateOutputType | null;
    _min: DatabaseConnectionMinAggregateOutputType | null;
    _max: DatabaseConnectionMaxAggregateOutputType | null;
  };

  type GetDatabaseConnectionGroupByPayload<T extends DatabaseConnectionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DatabaseConnectionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DatabaseConnectionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseConnectionGroupByOutputType[P]>;
        }
      >
    >;

  export type DatabaseConnectionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      passwordEncrypted?: boolean;
      sslEnabled?: boolean;
      isActive?: boolean;
      lastTestedAt?: boolean;
      lastTestResult?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      databases?: boolean;
      creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      endpoints?: boolean | DatabaseConnection$endpointsArgs<ExtArgs>;
      exposedEntities?: boolean | DatabaseConnection$exposedEntitiesArgs<ExtArgs>;
      services?: boolean | DatabaseConnection$servicesArgs<ExtArgs>;
      _count?: boolean | DatabaseConnectionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseConnection']
  >;

  export type DatabaseConnectionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      passwordEncrypted?: boolean;
      sslEnabled?: boolean;
      isActive?: boolean;
      lastTestedAt?: boolean;
      lastTestResult?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      databases?: boolean;
      creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseConnection']
  >;

  export type DatabaseConnectionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      passwordEncrypted?: boolean;
      sslEnabled?: boolean;
      isActive?: boolean;
      lastTestedAt?: boolean;
      lastTestResult?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      databases?: boolean;
      creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseConnection']
  >;

  export type DatabaseConnectionSelectScalar = {
    id?: boolean;
    name?: boolean;
    type?: boolean;
    host?: boolean;
    port?: boolean;
    database?: boolean;
    username?: boolean;
    passwordEncrypted?: boolean;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: boolean;
    lastTestResult?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
    databases?: boolean;
  };

  export type DatabaseConnectionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'type'
    | 'host'
    | 'port'
    | 'database'
    | 'username'
    | 'passwordEncrypted'
    | 'sslEnabled'
    | 'isActive'
    | 'lastTestedAt'
    | 'lastTestResult'
    | 'createdAt'
    | 'updatedAt'
    | 'organizationId'
    | 'createdBy'
    | 'databases',
    ExtArgs['result']['databaseConnection']
  >;
  export type DatabaseConnectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    endpoints?: boolean | DatabaseConnection$endpointsArgs<ExtArgs>;
    exposedEntities?: boolean | DatabaseConnection$exposedEntitiesArgs<ExtArgs>;
    services?: boolean | DatabaseConnection$servicesArgs<ExtArgs>;
    _count?: boolean | DatabaseConnectionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type DatabaseConnectionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type DatabaseConnectionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | DatabaseConnection$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $DatabaseConnectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DatabaseConnection';
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      endpoints: Prisma.$EndpointPayload<ExtArgs>[];
      exposedEntities: Prisma.$ExposedEntityPayload<ExtArgs>[];
      services: Prisma.$ServicePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        type: $Enums.DatabaseType;
        host: string;
        port: number;
        database: string;
        username: string;
        passwordEncrypted: string;
        sslEnabled: boolean;
        isActive: boolean;
        lastTestedAt: Date | null;
        lastTestResult: boolean | null;
        createdAt: Date;
        updatedAt: Date;
        organizationId: string;
        createdBy: string | null;
        databases: Prisma.JsonValue | null;
      },
      ExtArgs['result']['databaseConnection']
    >;
    composites: {};
  };

  type DatabaseConnectionGetPayload<
    S extends boolean | null | undefined | DatabaseConnectionDefaultArgs,
  > = $Result.GetResult<Prisma.$DatabaseConnectionPayload, S>;

  type DatabaseConnectionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DatabaseConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DatabaseConnectionCountAggregateInputType | true;
  };

  export interface DatabaseConnectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DatabaseConnection'];
      meta: { name: 'DatabaseConnection' };
    };
    /**
     * Find zero or one DatabaseConnection that matches the filter.
     * @param {DatabaseConnectionFindUniqueArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseConnectionFindUniqueArgs>(
      args: SelectSubset<T, DatabaseConnectionFindUniqueArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DatabaseConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseConnectionFindUniqueOrThrowArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseConnectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DatabaseConnectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindFirstArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseConnectionFindFirstArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindFirstArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindFirstOrThrowArgs} args - Arguments to find a DatabaseConnection
     * @example
     * // Get one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseConnectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DatabaseConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseConnections
     * const databaseConnections = await prisma.databaseConnection.findMany()
     *
     * // Get first 10 DatabaseConnections
     * const databaseConnections = await prisma.databaseConnection.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const databaseConnectionWithIdOnly = await prisma.databaseConnection.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DatabaseConnectionFindManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a DatabaseConnection.
     * @param {DatabaseConnectionCreateArgs} args - Arguments to create a DatabaseConnection.
     * @example
     * // Create one DatabaseConnection
     * const DatabaseConnection = await prisma.databaseConnection.create({
     *   data: {
     *     // ... data to create a DatabaseConnection
     *   }
     * })
     *
     */
    create<T extends DatabaseConnectionCreateArgs>(
      args: SelectSubset<T, DatabaseConnectionCreateArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<Prisma.$DatabaseConnectionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DatabaseConnections.
     * @param {DatabaseConnectionCreateManyArgs} args - Arguments to create many DatabaseConnections.
     * @example
     * // Create many DatabaseConnections
     * const databaseConnection = await prisma.databaseConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DatabaseConnectionCreateManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DatabaseConnections and returns the data saved in the database.
     * @param {DatabaseConnectionCreateManyAndReturnArgs} args - Arguments to create many DatabaseConnections.
     * @example
     * // Create many DatabaseConnections
     * const databaseConnection = await prisma.databaseConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DatabaseConnections and only return the `id`
     * const databaseConnectionWithIdOnly = await prisma.databaseConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DatabaseConnectionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DatabaseConnectionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DatabaseConnection.
     * @param {DatabaseConnectionDeleteArgs} args - Arguments to delete one DatabaseConnection.
     * @example
     * // Delete one DatabaseConnection
     * const DatabaseConnection = await prisma.databaseConnection.delete({
     *   where: {
     *     // ... filter to delete one DatabaseConnection
     *   }
     * })
     *
     */
    delete<T extends DatabaseConnectionDeleteArgs>(
      args: SelectSubset<T, DatabaseConnectionDeleteArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<Prisma.$DatabaseConnectionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DatabaseConnection.
     * @param {DatabaseConnectionUpdateArgs} args - Arguments to update one DatabaseConnection.
     * @example
     * // Update one DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DatabaseConnectionUpdateArgs>(
      args: SelectSubset<T, DatabaseConnectionUpdateArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<Prisma.$DatabaseConnectionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DatabaseConnections.
     * @param {DatabaseConnectionDeleteManyArgs} args - Arguments to filter DatabaseConnections to delete.
     * @example
     * // Delete a few DatabaseConnections
     * const { count } = await prisma.databaseConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DatabaseConnectionDeleteManyArgs>(
      args?: SelectSubset<T, DatabaseConnectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseConnections
     * const databaseConnection = await prisma.databaseConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DatabaseConnectionUpdateManyArgs>(
      args: SelectSubset<T, DatabaseConnectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseConnections and returns the data updated in the database.
     * @param {DatabaseConnectionUpdateManyAndReturnArgs} args - Arguments to update many DatabaseConnections.
     * @example
     * // Update many DatabaseConnections
     * const databaseConnection = await prisma.databaseConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DatabaseConnections and only return the `id`
     * const databaseConnectionWithIdOnly = await prisma.databaseConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DatabaseConnectionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DatabaseConnectionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DatabaseConnection.
     * @param {DatabaseConnectionUpsertArgs} args - Arguments to update or create a DatabaseConnection.
     * @example
     * // Update or create a DatabaseConnection
     * const databaseConnection = await prisma.databaseConnection.upsert({
     *   create: {
     *     // ... data to create a DatabaseConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseConnection we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseConnectionUpsertArgs>(
      args: SelectSubset<T, DatabaseConnectionUpsertArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<Prisma.$DatabaseConnectionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DatabaseConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionCountArgs} args - Arguments to filter DatabaseConnections to count.
     * @example
     * // Count the number of DatabaseConnections
     * const count = await prisma.databaseConnection.count({
     *   where: {
     *     // ... the filter for the DatabaseConnections we want to count
     *   }
     * })
     **/
    count<T extends DatabaseConnectionCountArgs>(
      args?: Subset<T, DatabaseConnectionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseConnectionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DatabaseConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DatabaseConnectionAggregateArgs>(
      args: Subset<T, DatabaseConnectionAggregateArgs>
    ): Prisma.PrismaPromise<GetDatabaseConnectionAggregateType<T>>;

    /**
     * Group by DatabaseConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DatabaseConnectionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseConnectionGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DatabaseConnectionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDatabaseConnectionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DatabaseConnection model
     */
    readonly fields: DatabaseConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseConnectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    creator<T extends DatabaseConnection$creatorArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseConnection$creatorArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    endpoints<T extends DatabaseConnection$endpointsArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseConnection$endpointsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    exposedEntities<T extends DatabaseConnection$exposedEntitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseConnection$exposedEntitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    services<T extends DatabaseConnection$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseConnection$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DatabaseConnection model
   */
  interface DatabaseConnectionFieldRefs {
    readonly id: FieldRef<'DatabaseConnection', 'String'>;
    readonly name: FieldRef<'DatabaseConnection', 'String'>;
    readonly type: FieldRef<'DatabaseConnection', 'DatabaseType'>;
    readonly host: FieldRef<'DatabaseConnection', 'String'>;
    readonly port: FieldRef<'DatabaseConnection', 'Int'>;
    readonly database: FieldRef<'DatabaseConnection', 'String'>;
    readonly username: FieldRef<'DatabaseConnection', 'String'>;
    readonly passwordEncrypted: FieldRef<'DatabaseConnection', 'String'>;
    readonly sslEnabled: FieldRef<'DatabaseConnection', 'Boolean'>;
    readonly isActive: FieldRef<'DatabaseConnection', 'Boolean'>;
    readonly lastTestedAt: FieldRef<'DatabaseConnection', 'DateTime'>;
    readonly lastTestResult: FieldRef<'DatabaseConnection', 'Boolean'>;
    readonly createdAt: FieldRef<'DatabaseConnection', 'DateTime'>;
    readonly updatedAt: FieldRef<'DatabaseConnection', 'DateTime'>;
    readonly organizationId: FieldRef<'DatabaseConnection', 'String'>;
    readonly createdBy: FieldRef<'DatabaseConnection', 'String'>;
    readonly databases: FieldRef<'DatabaseConnection', 'Json'>;
  }

  // Custom InputTypes
  /**
   * DatabaseConnection findUnique
   */
  export type DatabaseConnectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where: DatabaseConnectionWhereUniqueInput;
  };

  /**
   * DatabaseConnection findUniqueOrThrow
   */
  export type DatabaseConnectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where: DatabaseConnectionWhereUniqueInput;
  };

  /**
   * DatabaseConnection findFirst
   */
  export type DatabaseConnectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseConnections.
     */
    distinct?: DatabaseConnectionScalarFieldEnum | DatabaseConnectionScalarFieldEnum[];
  };

  /**
   * DatabaseConnection findFirstOrThrow
   */
  export type DatabaseConnectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseConnection to fetch.
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseConnections.
     */
    distinct?: DatabaseConnectionScalarFieldEnum | DatabaseConnectionScalarFieldEnum[];
  };

  /**
   * DatabaseConnection findMany
   */
  export type DatabaseConnectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseConnections to fetch.
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseConnections to fetch.
     */
    orderBy?:
      | DatabaseConnectionOrderByWithRelationInput
      | DatabaseConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DatabaseConnections.
     */
    cursor?: DatabaseConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseConnections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseConnections.
     */
    skip?: number;
    distinct?: DatabaseConnectionScalarFieldEnum | DatabaseConnectionScalarFieldEnum[];
  };

  /**
   * DatabaseConnection create
   */
  export type DatabaseConnectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a DatabaseConnection.
     */
    data: XOR<DatabaseConnectionCreateInput, DatabaseConnectionUncheckedCreateInput>;
  };

  /**
   * DatabaseConnection createMany
   */
  export type DatabaseConnectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DatabaseConnections.
     */
    data: DatabaseConnectionCreateManyInput | DatabaseConnectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DatabaseConnection createManyAndReturn
   */
  export type DatabaseConnectionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * The data used to create many DatabaseConnections.
     */
    data: DatabaseConnectionCreateManyInput | DatabaseConnectionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DatabaseConnection update
   */
  export type DatabaseConnectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a DatabaseConnection.
     */
    data: XOR<DatabaseConnectionUpdateInput, DatabaseConnectionUncheckedUpdateInput>;
    /**
     * Choose, which DatabaseConnection to update.
     */
    where: DatabaseConnectionWhereUniqueInput;
  };

  /**
   * DatabaseConnection updateMany
   */
  export type DatabaseConnectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DatabaseConnections.
     */
    data: XOR<
      DatabaseConnectionUpdateManyMutationInput,
      DatabaseConnectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which DatabaseConnections to update
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * Limit how many DatabaseConnections to update.
     */
    limit?: number;
  };

  /**
   * DatabaseConnection updateManyAndReturn
   */
  export type DatabaseConnectionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * The data used to update DatabaseConnections.
     */
    data: XOR<
      DatabaseConnectionUpdateManyMutationInput,
      DatabaseConnectionUncheckedUpdateManyInput
    >;
    /**
     * Filter which DatabaseConnections to update
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * Limit how many DatabaseConnections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DatabaseConnection upsert
   */
  export type DatabaseConnectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the DatabaseConnection to update in case it exists.
     */
    where: DatabaseConnectionWhereUniqueInput;
    /**
     * In case the DatabaseConnection found by the `where` argument doesn't exist, create a new DatabaseConnection with this data.
     */
    create: XOR<DatabaseConnectionCreateInput, DatabaseConnectionUncheckedCreateInput>;
    /**
     * In case the DatabaseConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseConnectionUpdateInput, DatabaseConnectionUncheckedUpdateInput>;
  };

  /**
   * DatabaseConnection delete
   */
  export type DatabaseConnectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    /**
     * Filter which DatabaseConnection to delete.
     */
    where: DatabaseConnectionWhereUniqueInput;
  };

  /**
   * DatabaseConnection deleteMany
   */
  export type DatabaseConnectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseConnections to delete
     */
    where?: DatabaseConnectionWhereInput;
    /**
     * Limit how many DatabaseConnections to delete.
     */
    limit?: number;
  };

  /**
   * DatabaseConnection.creator
   */
  export type DatabaseConnection$creatorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * DatabaseConnection.endpoints
   */
  export type DatabaseConnection$endpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * DatabaseConnection.exposedEntities
   */
  export type DatabaseConnection$exposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    where?: ExposedEntityWhereInput;
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    cursor?: ExposedEntityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * DatabaseConnection.services
   */
  export type DatabaseConnection$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * DatabaseConnection without action
   */
  export type DatabaseConnectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
  };

  /**
   * Model Endpoint
   */

  export type AggregateEndpoint = {
    _count: EndpointCountAggregateOutputType | null;
    _avg: EndpointAvgAggregateOutputType | null;
    _sum: EndpointSumAggregateOutputType | null;
    _min: EndpointMinAggregateOutputType | null;
    _max: EndpointMaxAggregateOutputType | null;
  };

  export type EndpointAvgAggregateOutputType = {
    rateLimitPerMinute: number | null;
  };

  export type EndpointSumAggregateOutputType = {
    rateLimitPerMinute: number | null;
  };

  export type EndpointMinAggregateOutputType = {
    id: string | null;
    path: string | null;
    method: $Enums.HttpMethod | null;
    name: string | null;
    description: string | null;
    query: string | null;
    apiKey: string | null;
    isActive: boolean | null;
    rateLimitPerMinute: number | null;
    requiresAuth: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    connectionId: string | null;
  };

  export type EndpointMaxAggregateOutputType = {
    id: string | null;
    path: string | null;
    method: $Enums.HttpMethod | null;
    name: string | null;
    description: string | null;
    query: string | null;
    apiKey: string | null;
    isActive: boolean | null;
    rateLimitPerMinute: number | null;
    requiresAuth: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    connectionId: string | null;
  };

  export type EndpointCountAggregateOutputType = {
    id: number;
    path: number;
    method: number;
    name: number;
    description: number;
    query: number;
    queryParams: number;
    bodySchema: number;
    responseSchema: number;
    apiKey: number;
    isActive: number;
    rateLimitPerMinute: number;
    requiresAuth: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    createdBy: number;
    connectionId: number;
    _all: number;
  };

  export type EndpointAvgAggregateInputType = {
    rateLimitPerMinute?: true;
  };

  export type EndpointSumAggregateInputType = {
    rateLimitPerMinute?: true;
  };

  export type EndpointMinAggregateInputType = {
    id?: true;
    path?: true;
    method?: true;
    name?: true;
    description?: true;
    query?: true;
    apiKey?: true;
    isActive?: true;
    rateLimitPerMinute?: true;
    requiresAuth?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
  };

  export type EndpointMaxAggregateInputType = {
    id?: true;
    path?: true;
    method?: true;
    name?: true;
    description?: true;
    query?: true;
    apiKey?: true;
    isActive?: true;
    rateLimitPerMinute?: true;
    requiresAuth?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
  };

  export type EndpointCountAggregateInputType = {
    id?: true;
    path?: true;
    method?: true;
    name?: true;
    description?: true;
    query?: true;
    queryParams?: true;
    bodySchema?: true;
    responseSchema?: true;
    apiKey?: true;
    isActive?: true;
    rateLimitPerMinute?: true;
    requiresAuth?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
    _all?: true;
  };

  export type EndpointAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Endpoint to aggregate.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Endpoints
     **/
    _count?: true | EndpointCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EndpointAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EndpointSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EndpointMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EndpointMaxAggregateInputType;
  };

  export type GetEndpointAggregateType<T extends EndpointAggregateArgs> = {
    [P in keyof T & keyof AggregateEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndpoint[P]>
      : GetScalarType<T[P], AggregateEndpoint[P]>;
  };

  export type EndpointGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithAggregationInput | EndpointOrderByWithAggregationInput[];
    by: EndpointScalarFieldEnum[] | EndpointScalarFieldEnum;
    having?: EndpointScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EndpointCountAggregateInputType | true;
    _avg?: EndpointAvgAggregateInputType;
    _sum?: EndpointSumAggregateInputType;
    _min?: EndpointMinAggregateInputType;
    _max?: EndpointMaxAggregateInputType;
  };

  export type EndpointGroupByOutputType = {
    id: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description: string | null;
    query: string;
    queryParams: JsonValue | null;
    bodySchema: JsonValue | null;
    responseSchema: JsonValue | null;
    apiKey: string;
    isActive: boolean;
    rateLimitPerMinute: number;
    requiresAuth: boolean;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    createdBy: string;
    connectionId: string | null;
    _count: EndpointCountAggregateOutputType | null;
    _avg: EndpointAvgAggregateOutputType | null;
    _sum: EndpointSumAggregateOutputType | null;
    _min: EndpointMinAggregateOutputType | null;
    _max: EndpointMaxAggregateOutputType | null;
  };

  type GetEndpointGroupByPayload<T extends EndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EndpointGroupByOutputType, T['by']> & {
        [P in keyof T & keyof EndpointGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EndpointGroupByOutputType[P]>
          : GetScalarType<T[P], EndpointGroupByOutputType[P]>;
      }
    >
  >;

  export type EndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        path?: boolean;
        method?: boolean;
        name?: boolean;
        description?: boolean;
        query?: boolean;
        queryParams?: boolean;
        bodySchema?: boolean;
        responseSchema?: boolean;
        apiKey?: boolean;
        isActive?: boolean;
        rateLimitPerMinute?: boolean;
        requiresAuth?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        organizationId?: boolean;
        createdBy?: boolean;
        connectionId?: boolean;
        usageLogs?: boolean | Endpoint$usageLogsArgs<ExtArgs>;
        connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
        creator?: boolean | UserDefaultArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        _count?: boolean | EndpointCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['endpoint']
    >;

  export type EndpointSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      path?: boolean;
      method?: boolean;
      name?: boolean;
      description?: boolean;
      query?: boolean;
      queryParams?: boolean;
      bodySchema?: boolean;
      responseSchema?: boolean;
      apiKey?: boolean;
      isActive?: boolean;
      rateLimitPerMinute?: boolean;
      requiresAuth?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      connectionId?: boolean;
      connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['endpoint']
  >;

  export type EndpointSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      path?: boolean;
      method?: boolean;
      name?: boolean;
      description?: boolean;
      query?: boolean;
      queryParams?: boolean;
      bodySchema?: boolean;
      responseSchema?: boolean;
      apiKey?: boolean;
      isActive?: boolean;
      rateLimitPerMinute?: boolean;
      requiresAuth?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      connectionId?: boolean;
      connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['endpoint']
  >;

  export type EndpointSelectScalar = {
    id?: boolean;
    path?: boolean;
    method?: boolean;
    name?: boolean;
    description?: boolean;
    query?: boolean;
    queryParams?: boolean;
    bodySchema?: boolean;
    responseSchema?: boolean;
    apiKey?: boolean;
    isActive?: boolean;
    rateLimitPerMinute?: boolean;
    requiresAuth?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
    connectionId?: boolean;
  };

  export type EndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'path'
      | 'method'
      | 'name'
      | 'description'
      | 'query'
      | 'queryParams'
      | 'bodySchema'
      | 'responseSchema'
      | 'apiKey'
      | 'isActive'
      | 'rateLimitPerMinute'
      | 'requiresAuth'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId'
      | 'createdBy'
      | 'connectionId',
      ExtArgs['result']['endpoint']
    >;
  export type EndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      usageLogs?: boolean | Endpoint$usageLogsArgs<ExtArgs>;
      connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      _count?: boolean | EndpointCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type EndpointIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type EndpointIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Endpoint$connectionArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $EndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Endpoint';
      objects: {
        usageLogs: Prisma.$ApiActivityLogPayload<ExtArgs>[];
        connection: Prisma.$DatabaseConnectionPayload<ExtArgs> | null;
        creator: Prisma.$UserPayload<ExtArgs>;
        organization: Prisma.$OrganizationPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          path: string;
          method: $Enums.HttpMethod;
          name: string;
          description: string | null;
          query: string;
          queryParams: Prisma.JsonValue | null;
          bodySchema: Prisma.JsonValue | null;
          responseSchema: Prisma.JsonValue | null;
          apiKey: string;
          isActive: boolean;
          rateLimitPerMinute: number;
          requiresAuth: boolean;
          createdAt: Date;
          updatedAt: Date;
          organizationId: string;
          createdBy: string;
          connectionId: string | null;
        },
        ExtArgs['result']['endpoint']
      >;
      composites: {};
    };

  type EndpointGetPayload<S extends boolean | null | undefined | EndpointDefaultArgs> =
    $Result.GetResult<Prisma.$EndpointPayload, S>;

  type EndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    EndpointFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: EndpointCountAggregateInputType | true;
  };

  export interface EndpointDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Endpoint'];
      meta: { name: 'Endpoint' };
    };
    /**
     * Find zero or one Endpoint that matches the filter.
     * @param {EndpointFindUniqueArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EndpointFindUniqueArgs>(
      args: SelectSubset<T, EndpointFindUniqueArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Endpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EndpointFindUniqueOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EndpointFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EndpointFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Endpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EndpointFindFirstArgs>(
      args?: SelectSubset<T, EndpointFindFirstArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Endpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EndpointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EndpointFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Endpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endpoints
     * const endpoints = await prisma.endpoint.findMany()
     *
     * // Get first 10 Endpoints
     * const endpoints = await prisma.endpoint.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const endpointWithIdOnly = await prisma.endpoint.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EndpointFindManyArgs>(
      args?: SelectSubset<T, EndpointFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Endpoint.
     * @param {EndpointCreateArgs} args - Arguments to create a Endpoint.
     * @example
     * // Create one Endpoint
     * const Endpoint = await prisma.endpoint.create({
     *   data: {
     *     // ... data to create a Endpoint
     *   }
     * })
     *
     */
    create<T extends EndpointCreateArgs>(
      args: SelectSubset<T, EndpointCreateArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Endpoints.
     * @param {EndpointCreateManyArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EndpointCreateManyArgs>(
      args?: SelectSubset<T, EndpointCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Endpoints and returns the data saved in the database.
     * @param {EndpointCreateManyAndReturnArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends EndpointCreateManyAndReturnArgs>(
      args?: SelectSubset<T, EndpointCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Endpoint.
     * @param {EndpointDeleteArgs} args - Arguments to delete one Endpoint.
     * @example
     * // Delete one Endpoint
     * const Endpoint = await prisma.endpoint.delete({
     *   where: {
     *     // ... filter to delete one Endpoint
     *   }
     * })
     *
     */
    delete<T extends EndpointDeleteArgs>(
      args: SelectSubset<T, EndpointDeleteArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Endpoint.
     * @param {EndpointUpdateArgs} args - Arguments to update one Endpoint.
     * @example
     * // Update one Endpoint
     * const endpoint = await prisma.endpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EndpointUpdateArgs>(
      args: SelectSubset<T, EndpointUpdateArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Endpoints.
     * @param {EndpointDeleteManyArgs} args - Arguments to filter Endpoints to delete.
     * @example
     * // Delete a few Endpoints
     * const { count } = await prisma.endpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EndpointDeleteManyArgs>(
      args?: SelectSubset<T, EndpointDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EndpointUpdateManyArgs>(
      args: SelectSubset<T, EndpointUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Endpoints and returns the data updated in the database.
     * @param {EndpointUpdateManyAndReturnArgs} args - Arguments to update many Endpoints.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends EndpointUpdateManyAndReturnArgs>(
      args: SelectSubset<T, EndpointUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Endpoint.
     * @param {EndpointUpsertArgs} args - Arguments to update or create a Endpoint.
     * @example
     * // Update or create a Endpoint
     * const endpoint = await prisma.endpoint.upsert({
     *   create: {
     *     // ... data to create a Endpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endpoint we want to update
     *   }
     * })
     */
    upsert<T extends EndpointUpsertArgs>(
      args: SelectSubset<T, EndpointUpsertArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointCountArgs} args - Arguments to filter Endpoints to count.
     * @example
     * // Count the number of Endpoints
     * const count = await prisma.endpoint.count({
     *   where: {
     *     // ... the filter for the Endpoints we want to count
     *   }
     * })
     **/
    count<T extends EndpointCountArgs>(
      args?: Subset<T, EndpointCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndpointCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EndpointAggregateArgs>(
      args: Subset<T, EndpointAggregateArgs>
    ): Prisma.PrismaPromise<GetEndpointAggregateType<T>>;

    /**
     * Group by Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EndpointGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndpointGroupByArgs['orderBy'] }
        : { orderBy?: EndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EndpointGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Endpoint model
     */
    readonly fields: EndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EndpointClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    usageLogs<T extends Endpoint$usageLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Endpoint$usageLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    connection<T extends Endpoint$connectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Endpoint$connectionArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Endpoint model
   */
  interface EndpointFieldRefs {
    readonly id: FieldRef<'Endpoint', 'String'>;
    readonly path: FieldRef<'Endpoint', 'String'>;
    readonly method: FieldRef<'Endpoint', 'HttpMethod'>;
    readonly name: FieldRef<'Endpoint', 'String'>;
    readonly description: FieldRef<'Endpoint', 'String'>;
    readonly query: FieldRef<'Endpoint', 'String'>;
    readonly queryParams: FieldRef<'Endpoint', 'Json'>;
    readonly bodySchema: FieldRef<'Endpoint', 'Json'>;
    readonly responseSchema: FieldRef<'Endpoint', 'Json'>;
    readonly apiKey: FieldRef<'Endpoint', 'String'>;
    readonly isActive: FieldRef<'Endpoint', 'Boolean'>;
    readonly rateLimitPerMinute: FieldRef<'Endpoint', 'Int'>;
    readonly requiresAuth: FieldRef<'Endpoint', 'Boolean'>;
    readonly createdAt: FieldRef<'Endpoint', 'DateTime'>;
    readonly updatedAt: FieldRef<'Endpoint', 'DateTime'>;
    readonly organizationId: FieldRef<'Endpoint', 'String'>;
    readonly createdBy: FieldRef<'Endpoint', 'String'>;
    readonly connectionId: FieldRef<'Endpoint', 'String'>;
  }

  // Custom InputTypes
  /**
   * Endpoint findUnique
   */
  export type EndpointFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint findUniqueOrThrow
   */
  export type EndpointFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint findFirst
   */
  export type EndpointFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint findFirstOrThrow
   */
  export type EndpointFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint findMany
   */
  export type EndpointFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoints to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint create
   */
  export type EndpointCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The data needed to create a Endpoint.
     */
    data: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>;
  };

  /**
   * Endpoint createMany
   */
  export type EndpointCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Endpoint createManyAndReturn
   */
  export type EndpointCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Endpoint update
   */
  export type EndpointUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The data needed to update a Endpoint.
     */
    data: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>;
    /**
     * Choose, which Endpoint to update.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint updateMany
   */
  export type EndpointUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>;
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number;
  };

  /**
   * Endpoint updateManyAndReturn
   */
  export type EndpointUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>;
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Endpoint upsert
   */
  export type EndpointUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The filter to search for the Endpoint to update in case it exists.
     */
    where: EndpointWhereUniqueInput;
    /**
     * In case the Endpoint found by the `where` argument doesn't exist, create a new Endpoint with this data.
     */
    create: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>;
    /**
     * In case the Endpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>;
  };

  /**
   * Endpoint delete
   */
  export type EndpointDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter which Endpoint to delete.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint deleteMany
   */
  export type EndpointDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Endpoints to delete
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to delete.
     */
    limit?: number;
  };

  /**
   * Endpoint.usageLogs
   */
  export type Endpoint$usageLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    where?: ApiActivityLogWhereInput;
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    cursor?: ApiActivityLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * Endpoint.connection
   */
  export type Endpoint$connectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    where?: DatabaseConnectionWhereInput;
  };

  /**
   * Endpoint without action
   */
  export type EndpointDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
  };

  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null;
    _min: ApiKeyMinAggregateOutputType | null;
    _max: ApiKeyMaxAggregateOutputType | null;
  };

  export type ApiKeyMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    keyHash: string | null;
    keyPrefix: string | null;
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    isActive: boolean | null;
    createdAt: Date | null;
    organizationId: string | null;
    createdById: string | null;
  };

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    keyHash: string | null;
    keyPrefix: string | null;
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    isActive: boolean | null;
    createdAt: Date | null;
    organizationId: string | null;
    createdById: string | null;
  };

  export type ApiKeyCountAggregateOutputType = {
    id: number;
    name: number;
    keyHash: number;
    keyPrefix: number;
    lastUsedAt: number;
    expiresAt: number;
    isActive: number;
    permissions: number;
    createdAt: number;
    organizationId: number;
    createdById: number;
    _all: number;
  };

  export type ApiKeyMinAggregateInputType = {
    id?: true;
    name?: true;
    keyHash?: true;
    keyPrefix?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    isActive?: true;
    createdAt?: true;
    organizationId?: true;
    createdById?: true;
  };

  export type ApiKeyMaxAggregateInputType = {
    id?: true;
    name?: true;
    keyHash?: true;
    keyPrefix?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    isActive?: true;
    createdAt?: true;
    organizationId?: true;
    createdById?: true;
  };

  export type ApiKeyCountAggregateInputType = {
    id?: true;
    name?: true;
    keyHash?: true;
    keyPrefix?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    isActive?: true;
    permissions?: true;
    createdAt?: true;
    organizationId?: true;
    createdById?: true;
    _all?: true;
  };

  export type ApiKeyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApiKeys
     **/
    _count?: true | ApiKeyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApiKeyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApiKeyMaxAggregateInputType;
  };

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
    [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>;
  };

  export type ApiKeyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiKeyWhereInput;
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[];
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum;
    having?: ApiKeyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApiKeyCountAggregateInputType | true;
    _min?: ApiKeyMinAggregateInputType;
    _max?: ApiKeyMaxAggregateInputType;
  };

  export type ApiKeyGroupByOutputType = {
    id: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    isActive: boolean;
    permissions: string[];
    createdAt: Date;
    organizationId: string;
    createdById: string;
    _count: ApiKeyCountAggregateOutputType | null;
    _min: ApiKeyMinAggregateOutputType | null;
    _max: ApiKeyMaxAggregateOutputType | null;
  };

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApiKeyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
          : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>;
      }
    >
  >;

  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        keyHash?: boolean;
        keyPrefix?: boolean;
        lastUsedAt?: boolean;
        expiresAt?: boolean;
        isActive?: boolean;
        permissions?: boolean;
        createdAt?: boolean;
        organizationId?: boolean;
        createdById?: boolean;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        usageMetrics?: boolean | ApiKey$usageMetricsArgs<ExtArgs>;
        _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['apiKey']
    >;

  export type ApiKeySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      keyHash?: boolean;
      keyPrefix?: boolean;
      lastUsedAt?: boolean;
      expiresAt?: boolean;
      isActive?: boolean;
      permissions?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      createdById?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiKey']
  >;

  export type ApiKeySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      keyHash?: boolean;
      keyPrefix?: boolean;
      lastUsedAt?: boolean;
      expiresAt?: boolean;
      isActive?: boolean;
      permissions?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      createdById?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiKey']
  >;

  export type ApiKeySelectScalar = {
    id?: boolean;
    name?: boolean;
    keyHash?: boolean;
    keyPrefix?: boolean;
    lastUsedAt?: boolean;
    expiresAt?: boolean;
    isActive?: boolean;
    permissions?: boolean;
    createdAt?: boolean;
    organizationId?: boolean;
    createdById?: boolean;
  };

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'keyHash'
      | 'keyPrefix'
      | 'lastUsedAt'
      | 'expiresAt'
      | 'isActive'
      | 'permissions'
      | 'createdAt'
      | 'organizationId'
      | 'createdById',
      ExtArgs['result']['apiKey']
    >;
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    usageMetrics?: boolean | ApiKey$usageMetricsArgs<ExtArgs>;
    _count?: boolean | ApiKeyCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ApiKeyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type ApiKeyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'ApiKey';
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      usageMetrics: Prisma.$UsageMetricPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        keyHash: string;
        keyPrefix: string;
        lastUsedAt: Date | null;
        expiresAt: Date | null;
        isActive: boolean;
        permissions: string[];
        createdAt: Date;
        organizationId: string;
        createdById: string;
      },
      ExtArgs['result']['apiKey']
    >;
    composites: {};
  };

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> =
    $Result.GetResult<Prisma.$ApiKeyPayload, S>;

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ApiKeyFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ApiKeyCountAggregateInputType | true;
  };

  export interface ApiKeyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey']; meta: { name: 'ApiKey' } };
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     *
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApiKeyFindManyArgs>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     *
     */
    create<T extends ApiKeyCreateArgs>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApiKeyCreateManyArgs>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     *
     */
    delete<T extends ApiKeyDeleteArgs>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApiKeyUpdateArgs>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
     **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApiKeyAggregateArgs>(
      args: Subset<T, ApiKeyAggregateArgs>
    ): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>;

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApiKey model
     */
    readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usageMetrics<T extends ApiKey$usageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, ApiKey$usageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<'ApiKey', 'String'>;
    readonly name: FieldRef<'ApiKey', 'String'>;
    readonly keyHash: FieldRef<'ApiKey', 'String'>;
    readonly keyPrefix: FieldRef<'ApiKey', 'String'>;
    readonly lastUsedAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly expiresAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly isActive: FieldRef<'ApiKey', 'Boolean'>;
    readonly permissions: FieldRef<'ApiKey', 'String[]'>;
    readonly createdAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly organizationId: FieldRef<'ApiKey', 'String'>;
    readonly createdById: FieldRef<'ApiKey', 'String'>;
  }

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput;
  };

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput;
  };

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ApiKey
       */
      omit?: ApiKeyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The data needed to create a ApiKey.
       */
      data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>;
    };

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ApiKey
       */
      omit?: ApiKeyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The data needed to update a ApiKey.
       */
      data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>;
      /**
       * Choose, which ApiKey to update.
       */
      where: ApiKeyWhereUniqueInput;
    };

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>;
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput;
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number;
  };

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>;
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput;
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ApiKey
       */
      omit?: ApiKeyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The filter to search for the ApiKey to update in case it exists.
       */
      where: ApiKeyWhereUniqueInput;
      /**
       * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
       */
      create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>;
      /**
       * In case the ApiKey was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>;
    };

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the ApiKey
       */
      omit?: ApiKeyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * Filter which ApiKey to delete.
       */
      where: ApiKeyWhereUniqueInput;
    };

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput;
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number;
  };

  /**
   * ApiKey.usageMetrics
   */
  export type ApiKey$usageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    where?: UsageMetricWhereInput;
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    cursor?: UsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[];
  };

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
  };

  /**
   * Model UsageMetric
   */

  export type AggregateUsageMetric = {
    _count: UsageMetricCountAggregateOutputType | null;
    _avg: UsageMetricAvgAggregateOutputType | null;
    _sum: UsageMetricSumAggregateOutputType | null;
    _min: UsageMetricMinAggregateOutputType | null;
    _max: UsageMetricMaxAggregateOutputType | null;
  };

  export type UsageMetricAvgAggregateOutputType = {
    statusCode: number | null;
    responseTimeMs: number | null;
  };

  export type UsageMetricSumAggregateOutputType = {
    statusCode: number | null;
    responseTimeMs: number | null;
  };

  export type UsageMetricMinAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    method: string | null;
    statusCode: number | null;
    responseTimeMs: number | null;
    timestamp: Date | null;
    organizationId: string | null;
    apiKeyId: string | null;
  };

  export type UsageMetricMaxAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    method: string | null;
    statusCode: number | null;
    responseTimeMs: number | null;
    timestamp: Date | null;
    organizationId: string | null;
    apiKeyId: string | null;
  };

  export type UsageMetricCountAggregateOutputType = {
    id: number;
    endpoint: number;
    method: number;
    statusCode: number;
    responseTimeMs: number;
    timestamp: number;
    organizationId: number;
    apiKeyId: number;
    _all: number;
  };

  export type UsageMetricAvgAggregateInputType = {
    statusCode?: true;
    responseTimeMs?: true;
  };

  export type UsageMetricSumAggregateInputType = {
    statusCode?: true;
    responseTimeMs?: true;
  };

  export type UsageMetricMinAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    statusCode?: true;
    responseTimeMs?: true;
    timestamp?: true;
    organizationId?: true;
    apiKeyId?: true;
  };

  export type UsageMetricMaxAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    statusCode?: true;
    responseTimeMs?: true;
    timestamp?: true;
    organizationId?: true;
    apiKeyId?: true;
  };

  export type UsageMetricCountAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    statusCode?: true;
    responseTimeMs?: true;
    timestamp?: true;
    organizationId?: true;
    apiKeyId?: true;
    _all?: true;
  };

  export type UsageMetricAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UsageMetric to aggregate.
     */
    where?: UsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UsageMetrics
     **/
    _count?: true | UsageMetricCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsageMetricAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsageMetricSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsageMetricMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsageMetricMaxAggregateInputType;
  };

  export type GetUsageMetricAggregateType<T extends UsageMetricAggregateArgs> = {
    [P in keyof T & keyof AggregateUsageMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageMetric[P]>
      : GetScalarType<T[P], AggregateUsageMetric[P]>;
  };

  export type UsageMetricGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UsageMetricWhereInput;
    orderBy?: UsageMetricOrderByWithAggregationInput | UsageMetricOrderByWithAggregationInput[];
    by: UsageMetricScalarFieldEnum[] | UsageMetricScalarFieldEnum;
    having?: UsageMetricScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsageMetricCountAggregateInputType | true;
    _avg?: UsageMetricAvgAggregateInputType;
    _sum?: UsageMetricSumAggregateInputType;
    _min?: UsageMetricMinAggregateInputType;
    _max?: UsageMetricMaxAggregateInputType;
  };

  export type UsageMetricGroupByOutputType = {
    id: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp: Date;
    organizationId: string;
    apiKeyId: string | null;
    _count: UsageMetricCountAggregateOutputType | null;
    _avg: UsageMetricAvgAggregateOutputType | null;
    _sum: UsageMetricSumAggregateOutputType | null;
    _min: UsageMetricMinAggregateOutputType | null;
    _max: UsageMetricMaxAggregateOutputType | null;
  };

  type GetUsageMetricGroupByPayload<T extends UsageMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageMetricGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UsageMetricGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>
          : GetScalarType<T[P], UsageMetricGroupByOutputType[P]>;
      }
    >
  >;

  export type UsageMetricSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      method?: boolean;
      statusCode?: boolean;
      responseTimeMs?: boolean;
      timestamp?: boolean;
      organizationId?: boolean;
      apiKeyId?: boolean;
      apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usageMetric']
  >;

  export type UsageMetricSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      method?: boolean;
      statusCode?: boolean;
      responseTimeMs?: boolean;
      timestamp?: boolean;
      organizationId?: boolean;
      apiKeyId?: boolean;
      apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usageMetric']
  >;

  export type UsageMetricSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      method?: boolean;
      statusCode?: boolean;
      responseTimeMs?: boolean;
      timestamp?: boolean;
      organizationId?: boolean;
      apiKeyId?: boolean;
      apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usageMetric']
  >;

  export type UsageMetricSelectScalar = {
    id?: boolean;
    endpoint?: boolean;
    method?: boolean;
    statusCode?: boolean;
    responseTimeMs?: boolean;
    timestamp?: boolean;
    organizationId?: boolean;
    apiKeyId?: boolean;
  };

  export type UsageMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'endpoint'
      | 'method'
      | 'statusCode'
      | 'responseTimeMs'
      | 'timestamp'
      | 'organizationId'
      | 'apiKeyId',
      ExtArgs['result']['usageMetric']
    >;
  export type UsageMetricInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type UsageMetricIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type UsageMetricIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiKey?: boolean | UsageMetric$apiKeyArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $UsageMetricPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UsageMetric';
    objects: {
      apiKey: Prisma.$ApiKeyPayload<ExtArgs> | null;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        endpoint: string;
        method: string;
        statusCode: number;
        responseTimeMs: number;
        timestamp: Date;
        organizationId: string;
        apiKeyId: string | null;
      },
      ExtArgs['result']['usageMetric']
    >;
    composites: {};
  };

  type UsageMetricGetPayload<S extends boolean | null | undefined | UsageMetricDefaultArgs> =
    $Result.GetResult<Prisma.$UsageMetricPayload, S>;

  type UsageMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageMetricCountAggregateInputType | true;
    };

  export interface UsageMetricDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UsageMetric'];
      meta: { name: 'UsageMetric' };
    };
    /**
     * Find zero or one UsageMetric that matches the filter.
     * @param {UsageMetricFindUniqueArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageMetricFindUniqueArgs>(
      args: SelectSubset<T, UsageMetricFindUniqueArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UsageMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageMetricFindUniqueOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageMetricFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UsageMetricFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UsageMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageMetricFindFirstArgs>(
      args?: SelectSubset<T, UsageMetricFindFirstArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UsageMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindFirstOrThrowArgs} args - Arguments to find a UsageMetric
     * @example
     * // Get one UsageMetric
     * const usageMetric = await prisma.usageMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageMetricFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsageMetricFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany()
     *
     * // Get first 10 UsageMetrics
     * const usageMetrics = await prisma.usageMetric.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UsageMetricFindManyArgs>(
      args?: SelectSubset<T, UsageMetricFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a UsageMetric.
     * @param {UsageMetricCreateArgs} args - Arguments to create a UsageMetric.
     * @example
     * // Create one UsageMetric
     * const UsageMetric = await prisma.usageMetric.create({
     *   data: {
     *     // ... data to create a UsageMetric
     *   }
     * })
     *
     */
    create<T extends UsageMetricCreateArgs>(
      args: SelectSubset<T, UsageMetricCreateArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UsageMetrics.
     * @param {UsageMetricCreateManyArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UsageMetricCreateManyArgs>(
      args?: SelectSubset<T, UsageMetricCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UsageMetrics and returns the data saved in the database.
     * @param {UsageMetricCreateManyAndReturnArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetric = await prisma.usageMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UsageMetrics and only return the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UsageMetricCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UsageMetricCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UsageMetric.
     * @param {UsageMetricDeleteArgs} args - Arguments to delete one UsageMetric.
     * @example
     * // Delete one UsageMetric
     * const UsageMetric = await prisma.usageMetric.delete({
     *   where: {
     *     // ... filter to delete one UsageMetric
     *   }
     * })
     *
     */
    delete<T extends UsageMetricDeleteArgs>(
      args: SelectSubset<T, UsageMetricDeleteArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UsageMetric.
     * @param {UsageMetricUpdateArgs} args - Arguments to update one UsageMetric.
     * @example
     * // Update one UsageMetric
     * const usageMetric = await prisma.usageMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UsageMetricUpdateArgs>(
      args: SelectSubset<T, UsageMetricUpdateArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UsageMetrics.
     * @param {UsageMetricDeleteManyArgs} args - Arguments to filter UsageMetrics to delete.
     * @example
     * // Delete a few UsageMetrics
     * const { count } = await prisma.usageMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UsageMetricDeleteManyArgs>(
      args?: SelectSubset<T, UsageMetricDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageMetrics
     * const usageMetric = await prisma.usageMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UsageMetricUpdateManyArgs>(
      args: SelectSubset<T, UsageMetricUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UsageMetrics and returns the data updated in the database.
     * @param {UsageMetricUpdateManyAndReturnArgs} args - Arguments to update many UsageMetrics.
     * @example
     * // Update many UsageMetrics
     * const usageMetric = await prisma.usageMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UsageMetrics and only return the `id`
     * const usageMetricWithIdOnly = await prisma.usageMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UsageMetricUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UsageMetricUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UsageMetricPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UsageMetric.
     * @param {UsageMetricUpsertArgs} args - Arguments to update or create a UsageMetric.
     * @example
     * // Update or create a UsageMetric
     * const usageMetric = await prisma.usageMetric.upsert({
     *   create: {
     *     // ... data to create a UsageMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageMetric we want to update
     *   }
     * })
     */
    upsert<T extends UsageMetricUpsertArgs>(
      args: SelectSubset<T, UsageMetricUpsertArgs<ExtArgs>>
    ): Prisma__UsageMetricClient<
      $Result.GetResult<Prisma.$UsageMetricPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricCountArgs} args - Arguments to filter UsageMetrics to count.
     * @example
     * // Count the number of UsageMetrics
     * const count = await prisma.usageMetric.count({
     *   where: {
     *     // ... the filter for the UsageMetrics we want to count
     *   }
     * })
     **/
    count<T extends UsageMetricCountArgs>(
      args?: Subset<T, UsageMetricCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageMetricCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsageMetricAggregateArgs>(
      args: Subset<T, UsageMetricAggregateArgs>
    ): Prisma.PrismaPromise<GetUsageMetricAggregateType<T>>;

    /**
     * Group by UsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UsageMetricGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageMetricGroupByArgs['orderBy'] }
        : { orderBy?: UsageMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UsageMetricGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUsageMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UsageMetric model
     */
    readonly fields: UsageMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageMetricClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    apiKey<T extends UsageMetric$apiKeyArgs<ExtArgs> = {}>(
      args?: Subset<T, UsageMetric$apiKeyArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<
        Prisma.$ApiKeyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UsageMetric model
   */
  interface UsageMetricFieldRefs {
    readonly id: FieldRef<'UsageMetric', 'String'>;
    readonly endpoint: FieldRef<'UsageMetric', 'String'>;
    readonly method: FieldRef<'UsageMetric', 'String'>;
    readonly statusCode: FieldRef<'UsageMetric', 'Int'>;
    readonly responseTimeMs: FieldRef<'UsageMetric', 'Int'>;
    readonly timestamp: FieldRef<'UsageMetric', 'DateTime'>;
    readonly organizationId: FieldRef<'UsageMetric', 'String'>;
    readonly apiKeyId: FieldRef<'UsageMetric', 'String'>;
  }

  // Custom InputTypes
  /**
   * UsageMetric findUnique
   */
  export type UsageMetricFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput;
  };

  /**
   * UsageMetric findUniqueOrThrow
   */
  export type UsageMetricFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which UsageMetric to fetch.
     */
    where: UsageMetricWhereUniqueInput;
  };

  /**
   * UsageMetric findFirst
   */
  export type UsageMetricFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[];
  };

  /**
   * UsageMetric findFirstOrThrow
   */
  export type UsageMetricFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which UsageMetric to fetch.
     */
    where?: UsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[];
  };

  /**
   * UsageMetric findMany
   */
  export type UsageMetricFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricOrderByWithRelationInput | UsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UsageMetrics.
     */
    cursor?: UsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UsageMetrics.
     */
    skip?: number;
    distinct?: UsageMetricScalarFieldEnum | UsageMetricScalarFieldEnum[];
  };

  /**
   * UsageMetric create
   */
  export type UsageMetricCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * The data needed to create a UsageMetric.
     */
    data: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>;
  };

  /**
   * UsageMetric createMany
   */
  export type UsageMetricCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UsageMetric createManyAndReturn
   */
  export type UsageMetricCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricCreateManyInput | UsageMetricCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UsageMetric update
   */
  export type UsageMetricUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * The data needed to update a UsageMetric.
     */
    data: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>;
    /**
     * Choose, which UsageMetric to update.
     */
    where: UsageMetricWhereUniqueInput;
  };

  /**
   * UsageMetric updateMany
   */
  export type UsageMetricUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyInput>;
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricWhereInput;
    /**
     * Limit how many UsageMetrics to update.
     */
    limit?: number;
  };

  /**
   * UsageMetric updateManyAndReturn
   */
  export type UsageMetricUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyInput>;
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricWhereInput;
    /**
     * Limit how many UsageMetrics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UsageMetric upsert
   */
  export type UsageMetricUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * The filter to search for the UsageMetric to update in case it exists.
     */
    where: UsageMetricWhereUniqueInput;
    /**
     * In case the UsageMetric found by the `where` argument doesn't exist, create a new UsageMetric with this data.
     */
    create: XOR<UsageMetricCreateInput, UsageMetricUncheckedCreateInput>;
    /**
     * In case the UsageMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageMetricUpdateInput, UsageMetricUncheckedUpdateInput>;
  };

  /**
   * UsageMetric delete
   */
  export type UsageMetricDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
    /**
     * Filter which UsageMetric to delete.
     */
    where: UsageMetricWhereUniqueInput;
  };

  /**
   * UsageMetric deleteMany
   */
  export type UsageMetricDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UsageMetrics to delete
     */
    where?: UsageMetricWhereInput;
    /**
     * Limit how many UsageMetrics to delete.
     */
    limit?: number;
  };

  /**
   * UsageMetric.apiKey
   */
  export type UsageMetric$apiKeyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    where?: ApiKeyWhereInput;
  };

  /**
   * UsageMetric without action
   */
  export type UsageMetricDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsageMetric
     */
    select?: UsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UsageMetric
     */
    omit?: UsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricInclude<ExtArgs> | null;
  };

  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null;
    _avg: WorkflowAvgAggregateOutputType | null;
    _sum: WorkflowSumAggregateOutputType | null;
    _min: WorkflowMinAggregateOutputType | null;
    _max: WorkflowMaxAggregateOutputType | null;
  };

  export type WorkflowAvgAggregateOutputType = {
    runCount: number | null;
  };

  export type WorkflowSumAggregateOutputType = {
    runCount: number | null;
  };

  export type WorkflowMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    lastRunAt: Date | null;
    runCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
  };

  export type WorkflowMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    lastRunAt: Date | null;
    runCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
  };

  export type WorkflowCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    definition: number;
    isActive: number;
    trigger: number;
    lastRunAt: number;
    runCount: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    createdBy: number;
    _all: number;
  };

  export type WorkflowAvgAggregateInputType = {
    runCount?: true;
  };

  export type WorkflowSumAggregateInputType = {
    runCount?: true;
  };

  export type WorkflowMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    lastRunAt?: true;
    runCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
  };

  export type WorkflowMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    lastRunAt?: true;
    runCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
  };

  export type WorkflowCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    definition?: true;
    isActive?: true;
    trigger?: true;
    lastRunAt?: true;
    runCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    _all?: true;
  };

  export type WorkflowAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Workflows
     **/
    _count?: true | WorkflowCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WorkflowAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WorkflowSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WorkflowMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WorkflowMaxAggregateInputType;
  };

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
    [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>;
  };

  export type WorkflowGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[];
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum;
    having?: WorkflowScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WorkflowCountAggregateInputType | true;
    _avg?: WorkflowAvgAggregateInputType;
    _sum?: WorkflowSumAggregateInputType;
    _min?: WorkflowMinAggregateInputType;
    _max?: WorkflowMaxAggregateInputType;
  };

  export type WorkflowGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    definition: JsonValue;
    isActive: boolean;
    trigger: JsonValue;
    lastRunAt: Date | null;
    runCount: number;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    createdBy: string | null;
    _count: WorkflowCountAggregateOutputType | null;
    _avg: WorkflowAvgAggregateOutputType | null;
    _sum: WorkflowSumAggregateOutputType | null;
    _min: WorkflowMinAggregateOutputType | null;
    _max: WorkflowMaxAggregateOutputType | null;
  };

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> & {
        [P in keyof T & keyof WorkflowGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
          : GetScalarType<T[P], WorkflowGroupByOutputType[P]>;
      }
    >
  >;

  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        definition?: boolean;
        isActive?: boolean;
        trigger?: boolean;
        lastRunAt?: boolean;
        runCount?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        organizationId?: boolean;
        createdBy?: boolean;
        creator?: boolean | Workflow$creatorArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        executions?: boolean | Workflow$executionsArgs<ExtArgs>;
        _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['workflow']
    >;

  export type WorkflowSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      definition?: boolean;
      isActive?: boolean;
      trigger?: boolean;
      lastRunAt?: boolean;
      runCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      creator?: boolean | Workflow$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflow']
  >;

  export type WorkflowSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      definition?: boolean;
      isActive?: boolean;
      trigger?: boolean;
      lastRunAt?: boolean;
      runCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      creator?: boolean | Workflow$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflow']
  >;

  export type WorkflowSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    definition?: boolean;
    isActive?: boolean;
    trigger?: boolean;
    lastRunAt?: boolean;
    runCount?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
  };

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'definition'
      | 'isActive'
      | 'trigger'
      | 'lastRunAt'
      | 'runCount'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId'
      | 'createdBy',
      ExtArgs['result']['workflow']
    >;
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      creator?: boolean | Workflow$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      executions?: boolean | Workflow$executionsArgs<ExtArgs>;
      _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type WorkflowIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | Workflow$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type WorkflowIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | Workflow$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Workflow';
      objects: {
        creator: Prisma.$UserPayload<ExtArgs> | null;
        organization: Prisma.$OrganizationPayload<ExtArgs>;
        executions: Prisma.$WorkflowExecutionPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          description: string | null;
          definition: Prisma.JsonValue;
          isActive: boolean;
          trigger: Prisma.JsonValue;
          lastRunAt: Date | null;
          runCount: number;
          createdAt: Date;
          updatedAt: Date;
          organizationId: string;
          createdBy: string | null;
        },
        ExtArgs['result']['workflow']
      >;
      composites: {};
    };

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> =
    $Result.GetResult<Prisma.$WorkflowPayload, S>;

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WorkflowFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: WorkflowCountAggregateInputType | true;
  };

  export interface WorkflowDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Workflow'];
      meta: { name: 'Workflow' };
    };
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(
      args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(
      args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     *
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WorkflowFindManyArgs>(
      args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     *
     */
    create<T extends WorkflowCreateArgs>(
      args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WorkflowCreateManyArgs>(
      args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     *
     */
    delete<T extends WorkflowDeleteArgs>(
      args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WorkflowUpdateArgs>(
      args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(
      args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WorkflowUpdateManyArgs>(
      args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(
      args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
     **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WorkflowAggregateArgs>(
      args: Subset<T, WorkflowAggregateArgs>
    ): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>;

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Workflow model
     */
    readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    creator<T extends Workflow$creatorArgs<ExtArgs> = {}>(
      args?: Subset<T, Workflow$creatorArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    executions<T extends Workflow$executionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Workflow$executionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WorkflowExecutionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<'Workflow', 'String'>;
    readonly name: FieldRef<'Workflow', 'String'>;
    readonly description: FieldRef<'Workflow', 'String'>;
    readonly definition: FieldRef<'Workflow', 'Json'>;
    readonly isActive: FieldRef<'Workflow', 'Boolean'>;
    readonly trigger: FieldRef<'Workflow', 'Json'>;
    readonly lastRunAt: FieldRef<'Workflow', 'DateTime'>;
    readonly runCount: FieldRef<'Workflow', 'Int'>;
    readonly createdAt: FieldRef<'Workflow', 'DateTime'>;
    readonly updatedAt: FieldRef<'Workflow', 'DateTime'>;
    readonly organizationId: FieldRef<'Workflow', 'String'>;
    readonly createdBy: FieldRef<'Workflow', 'String'>;
  }

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>;
  };

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>;
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>;
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to update.
     */
    limit?: number;
  };

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>;
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput;
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>;
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>;
  };

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number;
  };

  /**
   * Workflow.creator
   */
  export type Workflow$creatorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Workflow.executions
   */
  export type Workflow$executionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    where?: WorkflowExecutionWhereInput;
    orderBy?:
      | WorkflowExecutionOrderByWithRelationInput
      | WorkflowExecutionOrderByWithRelationInput[];
    cursor?: WorkflowExecutionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[];
  };

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
  };

  /**
   * Model WorkflowExecution
   */

  export type AggregateWorkflowExecution = {
    _count: WorkflowExecutionCountAggregateOutputType | null;
    _min: WorkflowExecutionMinAggregateOutputType | null;
    _max: WorkflowExecutionMaxAggregateOutputType | null;
  };

  export type WorkflowExecutionMinAggregateOutputType = {
    id: string | null;
    status: $Enums.ExecutionStatus | null;
    startedAt: Date | null;
    completedAt: Date | null;
    error: string | null;
    workflowId: string | null;
  };

  export type WorkflowExecutionMaxAggregateOutputType = {
    id: string | null;
    status: $Enums.ExecutionStatus | null;
    startedAt: Date | null;
    completedAt: Date | null;
    error: string | null;
    workflowId: string | null;
  };

  export type WorkflowExecutionCountAggregateOutputType = {
    id: number;
    status: number;
    startedAt: number;
    completedAt: number;
    error: number;
    logs: number;
    workflowId: number;
    _all: number;
  };

  export type WorkflowExecutionMinAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    error?: true;
    workflowId?: true;
  };

  export type WorkflowExecutionMaxAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    error?: true;
    workflowId?: true;
  };

  export type WorkflowExecutionCountAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    error?: true;
    logs?: true;
    workflowId?: true;
    _all?: true;
  };

  export type WorkflowExecutionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WorkflowExecution to aggregate.
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?:
      | WorkflowExecutionOrderByWithRelationInput
      | WorkflowExecutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WorkflowExecutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WorkflowExecutions
     **/
    _count?: true | WorkflowExecutionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WorkflowExecutionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WorkflowExecutionMaxAggregateInputType;
  };

  export type GetWorkflowExecutionAggregateType<T extends WorkflowExecutionAggregateArgs> = {
    [P in keyof T & keyof AggregateWorkflowExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowExecution[P]>
      : GetScalarType<T[P], AggregateWorkflowExecution[P]>;
  };

  export type WorkflowExecutionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowExecutionWhereInput;
    orderBy?:
      | WorkflowExecutionOrderByWithAggregationInput
      | WorkflowExecutionOrderByWithAggregationInput[];
    by: WorkflowExecutionScalarFieldEnum[] | WorkflowExecutionScalarFieldEnum;
    having?: WorkflowExecutionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WorkflowExecutionCountAggregateInputType | true;
    _min?: WorkflowExecutionMinAggregateInputType;
    _max?: WorkflowExecutionMaxAggregateInputType;
  };

  export type WorkflowExecutionGroupByOutputType = {
    id: string;
    status: $Enums.ExecutionStatus;
    startedAt: Date;
    completedAt: Date | null;
    error: string | null;
    logs: JsonValue | null;
    workflowId: string;
    _count: WorkflowExecutionCountAggregateOutputType | null;
    _min: WorkflowExecutionMinAggregateOutputType | null;
    _max: WorkflowExecutionMaxAggregateOutputType | null;
  };

  type GetWorkflowExecutionGroupByPayload<T extends WorkflowExecutionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WorkflowExecutionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof WorkflowExecutionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>;
        }
      >
    >;

  export type WorkflowExecutionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      error?: boolean;
      logs?: boolean;
      workflowId?: boolean;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowExecution']
  >;

  export type WorkflowExecutionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      error?: boolean;
      logs?: boolean;
      workflowId?: boolean;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowExecution']
  >;

  export type WorkflowExecutionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      error?: boolean;
      logs?: boolean;
      workflowId?: boolean;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowExecution']
  >;

  export type WorkflowExecutionSelectScalar = {
    id?: boolean;
    status?: boolean;
    startedAt?: boolean;
    completedAt?: boolean;
    error?: boolean;
    logs?: boolean;
    workflowId?: boolean;
  };

  export type WorkflowExecutionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'status' | 'startedAt' | 'completedAt' | 'error' | 'logs' | 'workflowId',
    ExtArgs['result']['workflowExecution']
  >;
  export type WorkflowExecutionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };
  export type WorkflowExecutionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };
  export type WorkflowExecutionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };

  export type $WorkflowExecutionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'WorkflowExecution';
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        status: $Enums.ExecutionStatus;
        startedAt: Date;
        completedAt: Date | null;
        error: string | null;
        logs: Prisma.JsonValue | null;
        workflowId: string;
      },
      ExtArgs['result']['workflowExecution']
    >;
    composites: {};
  };

  type WorkflowExecutionGetPayload<
    S extends boolean | null | undefined | WorkflowExecutionDefaultArgs,
  > = $Result.GetResult<Prisma.$WorkflowExecutionPayload, S>;

  type WorkflowExecutionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<WorkflowExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: WorkflowExecutionCountAggregateInputType | true;
  };

  export interface WorkflowExecutionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['WorkflowExecution'];
      meta: { name: 'WorkflowExecution' };
    };
    /**
     * Find zero or one WorkflowExecution that matches the filter.
     * @param {WorkflowExecutionFindUniqueArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowExecutionFindUniqueArgs>(
      args: SelectSubset<T, WorkflowExecutionFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WorkflowExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowExecutionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowExecutionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WorkflowExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowExecutionFindFirstArgs>(
      args?: SelectSubset<T, WorkflowExecutionFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WorkflowExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowExecutionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WorkflowExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany()
     *
     * // Get first 10 WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WorkflowExecutionFindManyArgs>(
      args?: SelectSubset<T, WorkflowExecutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a WorkflowExecution.
     * @param {WorkflowExecutionCreateArgs} args - Arguments to create a WorkflowExecution.
     * @example
     * // Create one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.create({
     *   data: {
     *     // ... data to create a WorkflowExecution
     *   }
     * })
     *
     */
    create<T extends WorkflowExecutionCreateArgs>(
      args: SelectSubset<T, WorkflowExecutionCreateArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WorkflowExecutions.
     * @param {WorkflowExecutionCreateManyArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WorkflowExecutionCreateManyArgs>(
      args?: SelectSubset<T, WorkflowExecutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WorkflowExecutions and returns the data saved in the database.
     * @param {WorkflowExecutionCreateManyAndReturnArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WorkflowExecutions and only return the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WorkflowExecutionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a WorkflowExecution.
     * @param {WorkflowExecutionDeleteArgs} args - Arguments to delete one WorkflowExecution.
     * @example
     * // Delete one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.delete({
     *   where: {
     *     // ... filter to delete one WorkflowExecution
     *   }
     * })
     *
     */
    delete<T extends WorkflowExecutionDeleteArgs>(
      args: SelectSubset<T, WorkflowExecutionDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WorkflowExecution.
     * @param {WorkflowExecutionUpdateArgs} args - Arguments to update one WorkflowExecution.
     * @example
     * // Update one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WorkflowExecutionUpdateArgs>(
      args: SelectSubset<T, WorkflowExecutionUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WorkflowExecutions.
     * @param {WorkflowExecutionDeleteManyArgs} args - Arguments to filter WorkflowExecutions to delete.
     * @example
     * // Delete a few WorkflowExecutions
     * const { count } = await prisma.workflowExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WorkflowExecutionDeleteManyArgs>(
      args?: SelectSubset<T, WorkflowExecutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WorkflowExecutionUpdateManyArgs>(
      args: SelectSubset<T, WorkflowExecutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WorkflowExecutions and returns the data updated in the database.
     * @param {WorkflowExecutionUpdateManyAndReturnArgs} args - Arguments to update many WorkflowExecutions.
     * @example
     * // Update many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WorkflowExecutions and only return the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WorkflowExecutionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowExecutionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one WorkflowExecution.
     * @param {WorkflowExecutionUpsertArgs} args - Arguments to update or create a WorkflowExecution.
     * @example
     * // Update or create a WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.upsert({
     *   create: {
     *     // ... data to create a WorkflowExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowExecution we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowExecutionUpsertArgs>(
      args: SelectSubset<T, WorkflowExecutionUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowExecutionClient<
      $Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionCountArgs} args - Arguments to filter WorkflowExecutions to count.
     * @example
     * // Count the number of WorkflowExecutions
     * const count = await prisma.workflowExecution.count({
     *   where: {
     *     // ... the filter for the WorkflowExecutions we want to count
     *   }
     * })
     **/
    count<T extends WorkflowExecutionCountArgs>(
      args?: Subset<T, WorkflowExecutionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowExecutionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WorkflowExecutionAggregateArgs>(
      args: Subset<T, WorkflowExecutionAggregateArgs>
    ): Prisma.PrismaPromise<GetWorkflowExecutionAggregateType<T>>;

    /**
     * Group by WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WorkflowExecutionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WorkflowExecutionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetWorkflowExecutionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WorkflowExecution model
     */
    readonly fields: WorkflowExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowExecutionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      | $Result.GetResult<
          Prisma.$WorkflowPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WorkflowExecution model
   */
  interface WorkflowExecutionFieldRefs {
    readonly id: FieldRef<'WorkflowExecution', 'String'>;
    readonly status: FieldRef<'WorkflowExecution', 'ExecutionStatus'>;
    readonly startedAt: FieldRef<'WorkflowExecution', 'DateTime'>;
    readonly completedAt: FieldRef<'WorkflowExecution', 'DateTime'>;
    readonly error: FieldRef<'WorkflowExecution', 'String'>;
    readonly logs: FieldRef<'WorkflowExecution', 'Json'>;
    readonly workflowId: FieldRef<'WorkflowExecution', 'String'>;
  }

  // Custom InputTypes
  /**
   * WorkflowExecution findUnique
   */
  export type WorkflowExecutionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput;
  };

  /**
   * WorkflowExecution findUniqueOrThrow
   */
  export type WorkflowExecutionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput;
  };

  /**
   * WorkflowExecution findFirst
   */
  export type WorkflowExecutionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?:
      | WorkflowExecutionOrderByWithRelationInput
      | WorkflowExecutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[];
  };

  /**
   * WorkflowExecution findFirstOrThrow
   */
  export type WorkflowExecutionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?:
      | WorkflowExecutionOrderByWithRelationInput
      | WorkflowExecutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[];
  };

  /**
   * WorkflowExecution findMany
   */
  export type WorkflowExecutionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowExecutions to fetch.
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?:
      | WorkflowExecutionOrderByWithRelationInput
      | WorkflowExecutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number;
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[];
  };

  /**
   * WorkflowExecution create
   */
  export type WorkflowExecutionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * The data needed to create a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>;
  };

  /**
   * WorkflowExecution createMany
   */
  export type WorkflowExecutionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WorkflowExecution createManyAndReturn
   */
  export type WorkflowExecutionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WorkflowExecution update
   */
  export type WorkflowExecutionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * The data needed to update a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>;
    /**
     * Choose, which WorkflowExecution to update.
     */
    where: WorkflowExecutionWhereUniqueInput;
  };

  /**
   * WorkflowExecution updateMany
   */
  export type WorkflowExecutionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update WorkflowExecutions.
     */
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyInput>;
    /**
     * Filter which WorkflowExecutions to update
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * Limit how many WorkflowExecutions to update.
     */
    limit?: number;
  };

  /**
   * WorkflowExecution updateManyAndReturn
   */
  export type WorkflowExecutionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * The data used to update WorkflowExecutions.
     */
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyInput>;
    /**
     * Filter which WorkflowExecutions to update
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * Limit how many WorkflowExecutions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WorkflowExecution upsert
   */
  export type WorkflowExecutionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * The filter to search for the WorkflowExecution to update in case it exists.
     */
    where: WorkflowExecutionWhereUniqueInput;
    /**
     * In case the WorkflowExecution found by the `where` argument doesn't exist, create a new WorkflowExecution with this data.
     */
    create: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>;
    /**
     * In case the WorkflowExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>;
  };

  /**
   * WorkflowExecution delete
   */
  export type WorkflowExecutionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
    /**
     * Filter which WorkflowExecution to delete.
     */
    where: WorkflowExecutionWhereUniqueInput;
  };

  /**
   * WorkflowExecution deleteMany
   */
  export type WorkflowExecutionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WorkflowExecutions to delete
     */
    where?: WorkflowExecutionWhereInput;
    /**
     * Limit how many WorkflowExecutions to delete.
     */
    limit?: number;
  };

  /**
   * WorkflowExecution without action
   */
  export type WorkflowExecutionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null;
  };

  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null;
    _avg: WebhookAvgAggregateOutputType | null;
    _sum: WebhookSumAggregateOutputType | null;
    _min: WebhookMinAggregateOutputType | null;
    _max: WebhookMaxAggregateOutputType | null;
  };

  export type WebhookAvgAggregateOutputType = {
    failureCount: number | null;
  };

  export type WebhookSumAggregateOutputType = {
    failureCount: number | null;
  };

  export type WebhookMinAggregateOutputType = {
    id: string | null;
    url: string | null;
    secret: string | null;
    isActive: boolean | null;
    lastTriggeredAt: Date | null;
    failureCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
  };

  export type WebhookMaxAggregateOutputType = {
    id: string | null;
    url: string | null;
    secret: string | null;
    isActive: boolean | null;
    lastTriggeredAt: Date | null;
    failureCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
  };

  export type WebhookCountAggregateOutputType = {
    id: number;
    url: number;
    events: number;
    secret: number;
    isActive: number;
    lastTriggeredAt: number;
    failureCount: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    _all: number;
  };

  export type WebhookAvgAggregateInputType = {
    failureCount?: true;
  };

  export type WebhookSumAggregateInputType = {
    failureCount?: true;
  };

  export type WebhookMinAggregateInputType = {
    id?: true;
    url?: true;
    secret?: true;
    isActive?: true;
    lastTriggeredAt?: true;
    failureCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
  };

  export type WebhookMaxAggregateInputType = {
    id?: true;
    url?: true;
    secret?: true;
    isActive?: true;
    lastTriggeredAt?: true;
    failureCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
  };

  export type WebhookCountAggregateInputType = {
    id?: true;
    url?: true;
    events?: true;
    secret?: true;
    isActive?: true;
    lastTriggeredAt?: true;
    failureCount?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    _all?: true;
  };

  export type WebhookAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Webhooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Webhooks
     **/
    _count?: true | WebhookCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WebhookAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WebhookSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WebhookMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WebhookMaxAggregateInputType;
  };

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
    [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>;
  };

  export type WebhookGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WebhookWhereInput;
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[];
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum;
    having?: WebhookScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WebhookCountAggregateInputType | true;
    _avg?: WebhookAvgAggregateInputType;
    _sum?: WebhookSumAggregateInputType;
    _min?: WebhookMinAggregateInputType;
    _max?: WebhookMaxAggregateInputType;
  };

  export type WebhookGroupByOutputType = {
    id: string;
    url: string;
    events: string[];
    secret: string;
    isActive: boolean;
    lastTriggeredAt: Date | null;
    failureCount: number;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    _count: WebhookCountAggregateOutputType | null;
    _avg: WebhookAvgAggregateOutputType | null;
    _sum: WebhookSumAggregateOutputType | null;
    _min: WebhookMinAggregateOutputType | null;
    _max: WebhookMaxAggregateOutputType | null;
  };

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> & {
        [P in keyof T & keyof WebhookGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
          : GetScalarType<T[P], WebhookGroupByOutputType[P]>;
      }
    >
  >;

  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        url?: boolean;
        events?: boolean;
        secret?: boolean;
        isActive?: boolean;
        lastTriggeredAt?: boolean;
        failureCount?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        organizationId?: boolean;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['webhook']
    >;

  export type WebhookSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      events?: boolean;
      secret?: boolean;
      isActive?: boolean;
      lastTriggeredAt?: boolean;
      failureCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['webhook']
  >;

  export type WebhookSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      events?: boolean;
      secret?: boolean;
      isActive?: boolean;
      lastTriggeredAt?: boolean;
      failureCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['webhook']
  >;

  export type WebhookSelectScalar = {
    id?: boolean;
    url?: boolean;
    events?: boolean;
    secret?: boolean;
    isActive?: boolean;
    lastTriggeredAt?: boolean;
    failureCount?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
  };

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'url'
      | 'events'
      | 'secret'
      | 'isActive'
      | 'lastTriggeredAt'
      | 'failureCount'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId',
      ExtArgs['result']['webhook']
    >;
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type WebhookIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type WebhookIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Webhook';
      objects: {
        organization: Prisma.$OrganizationPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          url: string;
          events: string[];
          secret: string;
          isActive: boolean;
          lastTriggeredAt: Date | null;
          failureCount: number;
          createdAt: Date;
          updatedAt: Date;
          organizationId: string;
        },
        ExtArgs['result']['webhook']
      >;
      composites: {};
    };

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> =
    $Result.GetResult<Prisma.$WebhookPayload, S>;

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WebhookFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: WebhookCountAggregateInputType | true;
  };

  export interface WebhookDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook']; meta: { name: 'Webhook' } };
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(
      args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(
      args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     *
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WebhookFindManyArgs>(
      args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     *
     */
    create<T extends WebhookCreateArgs>(
      args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WebhookCreateManyArgs>(
      args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebhookPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     *
     */
    delete<T extends WebhookDeleteArgs>(
      args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WebhookUpdateArgs>(
      args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WebhookDeleteManyArgs>(
      args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WebhookUpdateManyArgs>(
      args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebhookPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(
      args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>
    ): Prisma__WebhookClient<
      $Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
     **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WebhookAggregateArgs>(
      args: Subset<T, WebhookAggregateArgs>
    ): Prisma.PrismaPromise<GetWebhookAggregateType<T>>;

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Webhook model
     */
    readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<'Webhook', 'String'>;
    readonly url: FieldRef<'Webhook', 'String'>;
    readonly events: FieldRef<'Webhook', 'String[]'>;
    readonly secret: FieldRef<'Webhook', 'String'>;
    readonly isActive: FieldRef<'Webhook', 'Boolean'>;
    readonly lastTriggeredAt: FieldRef<'Webhook', 'DateTime'>;
    readonly failureCount: FieldRef<'Webhook', 'Int'>;
    readonly createdAt: FieldRef<'Webhook', 'DateTime'>;
    readonly updatedAt: FieldRef<'Webhook', 'DateTime'>;
    readonly organizationId: FieldRef<'Webhook', 'String'>;
  }

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput;
  };

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput;
  };

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Webhooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[];
  };

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Webhooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[];
  };

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Webhooks.
     */
    skip?: number;
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[];
  };

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>;
  };

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>;
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput;
  };

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>;
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput;
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number;
  };

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>;
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput;
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput;
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>;
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>;
  };

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput;
  };

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput;
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number;
  };

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date | null;
    organizationId: string | null;
    userId: string | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date | null;
    organizationId: string | null;
    userId: string | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    action: number;
    entityType: number;
    entityId: number;
    metadata: number;
    ipAddress: number;
    userAgent: number;
    timestamp: number;
    organizationId: number;
    userId: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
    organizationId?: true;
    userId?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
    organizationId?: true;
    userId?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    metadata?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
    organizationId?: true;
    userId?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date;
    organizationId: string;
    userId: string | null;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
          : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
      }
    >
  >;

  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        action?: boolean;
        entityType?: boolean;
        entityId?: boolean;
        metadata?: boolean;
        ipAddress?: boolean;
        userAgent?: boolean;
        timestamp?: boolean;
        organizationId?: boolean;
        userId?: boolean;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        user?: boolean | AuditLog$userArgs<ExtArgs>;
      },
      ExtArgs['result']['auditLog']
    >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      timestamp?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      timestamp?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    action?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    metadata?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    timestamp?: boolean;
    organizationId?: boolean;
    userId?: boolean;
  };

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'action'
      | 'entityType'
      | 'entityId'
      | 'metadata'
      | 'ipAddress'
      | 'userAgent'
      | 'timestamp'
      | 'organizationId'
      | 'userId',
      ExtArgs['result']['auditLog']
    >;
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | AuditLog$userArgs<ExtArgs>;
  };
  export type AuditLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | AuditLog$userArgs<ExtArgs>;
  };

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'AuditLog';
      objects: {
        organization: Prisma.$OrganizationPayload<ExtArgs>;
        user: Prisma.$UserPayload<ExtArgs> | null;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          action: string;
          entityType: string;
          entityId: string;
          metadata: Prisma.JsonValue | null;
          ipAddress: string | null;
          userAgent: string | null;
          timestamp: Date;
          organizationId: string;
          userId: string | null;
        },
        ExtArgs['result']['auditLog']
      >;
      composites: {};
    };

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> =
    $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AuditLogFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly entityType: FieldRef<'AuditLog', 'String'>;
    readonly entityId: FieldRef<'AuditLog', 'String'>;
    readonly metadata: FieldRef<'AuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly timestamp: FieldRef<'AuditLog', 'DateTime'>;
    readonly organizationId: FieldRef<'AuditLog', 'String'>;
    readonly userId: FieldRef<'AuditLog', 'String'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  export type ServiceAvgAggregateOutputType = {
    port: number | null;
  };

  export type ServiceSumAggregateOutputType = {
    port: number | null;
  };

  export type ServiceMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    passwordEncrypted: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    connectionId: string | null;
  };

  export type ServiceMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    passwordEncrypted: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    connectionId: string | null;
  };

  export type ServiceCountAggregateOutputType = {
    id: number;
    name: number;
    label: number;
    description: number;
    host: number;
    port: number;
    database: number;
    username: number;
    passwordEncrypted: number;
    isActive: number;
    failoverHost: number;
    objects: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    createdBy: number;
    connectionId: number;
    _all: number;
  };

  export type ServiceAvgAggregateInputType = {
    port?: true;
  };

  export type ServiceSumAggregateInputType = {
    port?: true;
  };

  export type ServiceMinAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    isActive?: true;
    failoverHost?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
  };

  export type ServiceMaxAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    isActive?: true;
    failoverHost?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
  };

  export type ServiceCountAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    passwordEncrypted?: true;
    isActive?: true;
    failoverHost?: true;
    objects?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    connectionId?: true;
    _all?: true;
  };

  export type ServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Services
     **/
    _count?: true | ServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceMaxAggregateInputType;
  };

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
    [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>;
  };

  export type ServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[];
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum;
    having?: ServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceCountAggregateInputType | true;
    _avg?: ServiceAvgAggregateInputType;
    _sum?: ServiceSumAggregateInputType;
    _min?: ServiceMinAggregateInputType;
    _max?: ServiceMaxAggregateInputType;
  };

  export type ServiceGroupByOutputType = {
    id: string;
    name: string;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string;
    username: string | null;
    passwordEncrypted: string | null;
    isActive: boolean;
    failoverHost: string | null;
    objects: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    createdBy: string;
    connectionId: string | null;
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        label?: boolean;
        description?: boolean;
        host?: boolean;
        port?: boolean;
        database?: boolean;
        username?: boolean;
        passwordEncrypted?: boolean;
        isActive?: boolean;
        failoverHost?: boolean;
        objects?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        organizationId?: boolean;
        createdBy?: boolean;
        connectionId?: boolean;
        databaseObjects?: boolean | Service$databaseObjectsArgs<ExtArgs>;
        exposedEntities?: boolean | Service$exposedEntitiesArgs<ExtArgs>;
        roles?: boolean | Service$rolesArgs<ExtArgs>;
        connection?: boolean | Service$connectionArgs<ExtArgs>;
        creator?: boolean | UserDefaultArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['service']
    >;

  export type ServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      label?: boolean;
      description?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      passwordEncrypted?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      objects?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      connectionId?: boolean;
      connection?: boolean | Service$connectionArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      label?: boolean;
      description?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      passwordEncrypted?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      objects?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      connectionId?: boolean;
      connection?: boolean | Service$connectionArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectScalar = {
    id?: boolean;
    name?: boolean;
    label?: boolean;
    description?: boolean;
    host?: boolean;
    port?: boolean;
    database?: boolean;
    username?: boolean;
    passwordEncrypted?: boolean;
    isActive?: boolean;
    failoverHost?: boolean;
    objects?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
    connectionId?: boolean;
  };

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'label'
      | 'description'
      | 'host'
      | 'port'
      | 'database'
      | 'username'
      | 'passwordEncrypted'
      | 'isActive'
      | 'failoverHost'
      | 'objects'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId'
      | 'createdBy'
      | 'connectionId',
      ExtArgs['result']['service']
    >;
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    databaseObjects?: boolean | Service$databaseObjectsArgs<ExtArgs>;
    exposedEntities?: boolean | Service$exposedEntitiesArgs<ExtArgs>;
    roles?: boolean | Service$rolesArgs<ExtArgs>;
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Service';
      objects: {
        databaseObjects: Prisma.$DatabaseObjectPayload<ExtArgs>[];
        exposedEntities: Prisma.$ExposedEntityPayload<ExtArgs>[];
        roles: Prisma.$RolePayload<ExtArgs>[];
        connection: Prisma.$DatabaseConnectionPayload<ExtArgs> | null;
        creator: Prisma.$UserPayload<ExtArgs>;
        organization: Prisma.$OrganizationPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          label: string | null;
          description: string | null;
          host: string | null;
          port: number | null;
          database: string;
          username: string | null;
          passwordEncrypted: string | null;
          isActive: boolean;
          failoverHost: string | null;
          objects: Prisma.JsonValue | null;
          createdAt: Date;
          updatedAt: Date;
          organizationId: string;
          createdBy: string;
          connectionId: string | null;
        },
        ExtArgs['result']['service']
      >;
      composites: {};
    };

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> =
    $Result.GetResult<Prisma.$ServicePayload, S>;

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ServiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ServiceCountAggregateInputType | true;
  };

  export interface ServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service']; meta: { name: 'Service' } };
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     *
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     *
     */
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     *
     */
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
     **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceAggregateArgs>(
      args: Subset<T, ServiceAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceAggregateType<T>>;

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Service model
     */
    readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    databaseObjects<T extends Service$databaseObjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$databaseObjectsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    exposedEntities<T extends Service$exposedEntitiesArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$exposedEntitiesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    roles<T extends Service$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    connection<T extends Service$connectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$connectionArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      $Result.GetResult<
        Prisma.$DatabaseConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<'Service', 'String'>;
    readonly name: FieldRef<'Service', 'String'>;
    readonly label: FieldRef<'Service', 'String'>;
    readonly description: FieldRef<'Service', 'String'>;
    readonly host: FieldRef<'Service', 'String'>;
    readonly port: FieldRef<'Service', 'Int'>;
    readonly database: FieldRef<'Service', 'String'>;
    readonly username: FieldRef<'Service', 'String'>;
    readonly passwordEncrypted: FieldRef<'Service', 'String'>;
    readonly isActive: FieldRef<'Service', 'Boolean'>;
    readonly failoverHost: FieldRef<'Service', 'String'>;
    readonly objects: FieldRef<'Service', 'Json'>;
    readonly createdAt: FieldRef<'Service', 'DateTime'>;
    readonly updatedAt: FieldRef<'Service', 'DateTime'>;
    readonly organizationId: FieldRef<'Service', 'String'>;
    readonly createdBy: FieldRef<'Service', 'String'>;
    readonly connectionId: FieldRef<'Service', 'String'>;
  }

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service create
   */
  export type ServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
  };

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service update
   */
  export type ServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
  };

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput;
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
  };

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to delete.
     */
    limit?: number;
  };

  /**
   * Service.databaseObjects
   */
  export type Service$databaseObjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    where?: DatabaseObjectWhereInput;
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    cursor?: DatabaseObjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * Service.exposedEntities
   */
  export type Service$exposedEntitiesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    where?: ExposedEntityWhereInput;
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    cursor?: ExposedEntityWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * Service.roles
   */
  export type Service$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    cursor?: RoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Service.connection
   */
  export type Service$connectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseConnection
     */
    select?: DatabaseConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseConnection
     */
    omit?: DatabaseConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseConnectionInclude<ExtArgs> | null;
    where?: DatabaseConnectionWhereInput;
  };

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
  };

  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null;
    _min: ApplicationMinAggregateOutputType | null;
    _max: ApplicationMaxAggregateOutputType | null;
  };

  export type ApplicationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    apiKeyHash: string | null;
    apiKeyEncrypted: string | null;
    apiKeyPrefix: string | null;
    apiKeyHint: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    defaultRoleId: string | null;
  };

  export type ApplicationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    apiKeyHash: string | null;
    apiKeyEncrypted: string | null;
    apiKeyPrefix: string | null;
    apiKeyHint: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    createdBy: string | null;
    defaultRoleId: string | null;
  };

  export type ApplicationCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    apiKeyHash: number;
    apiKeyEncrypted: number;
    apiKeyPrefix: number;
    apiKeyHint: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    createdBy: number;
    defaultRoleId: number;
    _all: number;
  };

  export type ApplicationMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    apiKeyHash?: true;
    apiKeyEncrypted?: true;
    apiKeyPrefix?: true;
    apiKeyHint?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    defaultRoleId?: true;
  };

  export type ApplicationMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    apiKeyHash?: true;
    apiKeyEncrypted?: true;
    apiKeyPrefix?: true;
    apiKeyHint?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    defaultRoleId?: true;
  };

  export type ApplicationCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    apiKeyHash?: true;
    apiKeyEncrypted?: true;
    apiKeyPrefix?: true;
    apiKeyHint?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    createdBy?: true;
    defaultRoleId?: true;
    _all?: true;
  };

  export type ApplicationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Applications
     **/
    _count?: true | ApplicationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApplicationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApplicationMaxAggregateInputType;
  };

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
    [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>;
  };

  export type ApplicationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[];
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum;
    having?: ApplicationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApplicationCountAggregateInputType | true;
    _min?: ApplicationMinAggregateInputType;
    _max?: ApplicationMaxAggregateInputType;
  };

  export type ApplicationGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    createdBy: string;
    defaultRoleId: string;
    _count: ApplicationCountAggregateOutputType | null;
    _min: ApplicationMinAggregateOutputType | null;
    _max: ApplicationMaxAggregateOutputType | null;
  };

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApplicationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
          : GetScalarType<T[P], ApplicationGroupByOutputType[P]>;
      }
    >
  >;

  export type ApplicationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      apiKeyHash?: boolean;
      apiKeyEncrypted?: boolean;
      apiKeyPrefix?: boolean;
      apiKeyHint?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      defaultRoleId?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      apiKeyHash?: boolean;
      apiKeyEncrypted?: boolean;
      apiKeyPrefix?: boolean;
      apiKeyHint?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      defaultRoleId?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      apiKeyHash?: boolean;
      apiKeyEncrypted?: boolean;
      apiKeyPrefix?: boolean;
      apiKeyHint?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      defaultRoleId?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    apiKeyHash?: boolean;
    apiKeyEncrypted?: boolean;
    apiKeyPrefix?: boolean;
    apiKeyHint?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
    defaultRoleId?: boolean;
  };

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'apiKeyHash'
      | 'apiKeyEncrypted'
      | 'apiKeyPrefix'
      | 'apiKeyHint'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId'
      | 'createdBy'
      | 'defaultRoleId',
      ExtArgs['result']['application']
    >;
  export type ApplicationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type ApplicationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type ApplicationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    defaultRole?: boolean | RoleDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $ApplicationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Application';
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>;
      defaultRole: Prisma.$RolePayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        apiKeyHash: string;
        apiKeyEncrypted: string;
        apiKeyPrefix: string;
        apiKeyHint: string;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
        organizationId: string;
        createdBy: string;
        defaultRoleId: string;
      },
      ExtArgs['result']['application']
    >;
    composites: {};
  };

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> =
    $Result.GetResult<Prisma.$ApplicationPayload, S>;

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true;
    };

  export interface ApplicationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Application'];
      meta: { name: 'Application' };
    };
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(
      args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(
      args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     *
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApplicationFindManyArgs>(
      args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     *
     */
    create<T extends ApplicationCreateArgs>(
      args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApplicationCreateManyArgs>(
      args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     *
     */
    delete<T extends ApplicationDeleteArgs>(
      args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApplicationUpdateArgs>(
      args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(
      args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApplicationUpdateManyArgs>(
      args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {ApplicationUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApplicationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApplicationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(
      args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
     **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApplicationAggregateArgs>(
      args: Subset<T, ApplicationAggregateArgs>
    ): Prisma.PrismaPromise<GetApplicationAggregateType<T>>;

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Application model
     */
    readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    defaultRole<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>
    ): Prisma__RoleClient<
      | $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<'Application', 'String'>;
    readonly name: FieldRef<'Application', 'String'>;
    readonly description: FieldRef<'Application', 'String'>;
    readonly apiKeyHash: FieldRef<'Application', 'String'>;
    readonly apiKeyEncrypted: FieldRef<'Application', 'String'>;
    readonly apiKeyPrefix: FieldRef<'Application', 'String'>;
    readonly apiKeyHint: FieldRef<'Application', 'String'>;
    readonly isActive: FieldRef<'Application', 'Boolean'>;
    readonly createdAt: FieldRef<'Application', 'DateTime'>;
    readonly updatedAt: FieldRef<'Application', 'DateTime'>;
    readonly organizationId: FieldRef<'Application', 'String'>;
    readonly createdBy: FieldRef<'Application', 'String'>;
    readonly defaultRoleId: FieldRef<'Application', 'String'>;
  }

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application create
   */
  export type ApplicationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>;
  };

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>;
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to update.
     */
    limit?: number;
  };

  /**
   * Application updateManyAndReturn
   */
  export type ApplicationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput;
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>;
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>;
  };

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to delete.
     */
    limit?: number;
  };

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    serviceId: string | null;
    createdBy: string | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    serviceId: string | null;
    createdBy: string | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    isActive: number;
    permissions: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    serviceId: number;
    createdBy: number;
    _all: number;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
    createdBy?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
    createdBy?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    permissions?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
    createdBy?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[];
      by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
      having?: RoleScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: RoleCountAggregateInputType | true;
      _min?: RoleMinAggregateInputType;
      _max?: RoleMaxAggregateInputType;
    };

  export type RoleGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    isActive: boolean;
    permissions: JsonValue;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    serviceId: string;
    createdBy: string;
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        isActive?: boolean;
        permissions?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        organizationId?: boolean;
        serviceId?: boolean;
        createdBy?: boolean;
        applications?: boolean | Role$applicationsArgs<ExtArgs>;
        exposedFieldPolicies?: boolean | Role$exposedFieldPoliciesArgs<ExtArgs>;
        exposedRowPolicies?: boolean | Role$exposedRowPoliciesArgs<ExtArgs>;
        creator?: boolean | UserDefaultArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        service?: boolean | ServiceDefaultArgs<ExtArgs>;
        _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['role']
    >;

  export type RoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      permissions?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      createdBy?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      permissions?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      createdBy?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    isActive?: boolean;
    permissions?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    serviceId?: boolean;
    createdBy?: boolean;
  };

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'isActive'
      | 'permissions'
      | 'createdAt'
      | 'updatedAt'
      | 'organizationId'
      | 'serviceId'
      | 'createdBy',
      ExtArgs['result']['role']
    >;
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Role$applicationsArgs<ExtArgs>;
    exposedFieldPolicies?: boolean | Role$exposedFieldPoliciesArgs<ExtArgs>;
    exposedRowPolicies?: boolean | Role$exposedRowPoliciesArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Role';
    objects: {
      applications: Prisma.$ApplicationPayload<ExtArgs>[];
      exposedFieldPolicies: Prisma.$ExposedFieldPolicyPayload<ExtArgs>[];
      exposedRowPolicies: Prisma.$ExposedRowPolicyPayload<ExtArgs>[];
      creator: Prisma.$UserPayload<ExtArgs>;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        isActive: boolean;
        permissions: Prisma.JsonValue;
        createdAt: Date;
        updatedAt: Date;
        organizationId: string;
        serviceId: string;
        createdBy: string;
      },
      ExtArgs['result']['role']
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<
    Prisma.$RolePayload,
    S
  >;

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    RoleFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role']; meta: { name: 'Role' } };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    applications<T extends Role$applicationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$applicationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    exposedFieldPolicies<T extends Role$exposedFieldPoliciesArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$exposedFieldPoliciesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    exposedRowPolicies<T extends Role$exposedRowPoliciesArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$exposedRowPoliciesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExposedRowPolicyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<'Role', 'String'>;
    readonly name: FieldRef<'Role', 'String'>;
    readonly description: FieldRef<'Role', 'String'>;
    readonly isActive: FieldRef<'Role', 'Boolean'>;
    readonly permissions: FieldRef<'Role', 'Json'>;
    readonly createdAt: FieldRef<'Role', 'DateTime'>;
    readonly updatedAt: FieldRef<'Role', 'DateTime'>;
    readonly organizationId: FieldRef<'Role', 'String'>;
    readonly serviceId: FieldRef<'Role', 'String'>;
    readonly createdBy: FieldRef<'Role', 'String'>;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
      /**
       * Filter, which Roles to fetch.
       */
      where?: RoleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Roles to fetch.
       */
      orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Roles.
       */
      cursor?: RoleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Roles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Roles.
       */
      skip?: number;
      distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
    };

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to delete.
     */
    limit?: number;
  };

  /**
   * Role.applications
   */
  export type Role$applicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    cursor?: ApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Role.exposedFieldPolicies
   */
  export type Role$exposedFieldPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    where?: ExposedFieldPolicyWhereInput;
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedFieldPolicyScalarFieldEnum | ExposedFieldPolicyScalarFieldEnum[];
  };

  /**
   * Role.exposedRowPolicies
   */
  export type Role$exposedRowPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    where?: ExposedRowPolicyWhereInput;
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    cursor?: ExposedRowPolicyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedRowPolicyScalarFieldEnum | ExposedRowPolicyScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
    };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    type: $Enums.NotificationType | null;
    priority: $Enums.NotificationPriority | null;
    title: string | null;
    message: string | null;
    isRead: boolean | null;
    readAt: Date | null;
    createdAt: Date | null;
    organizationId: string | null;
    userId: string | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    type: $Enums.NotificationType | null;
    priority: $Enums.NotificationPriority | null;
    title: string | null;
    message: string | null;
    isRead: boolean | null;
    readAt: Date | null;
    createdAt: Date | null;
    organizationId: string | null;
    userId: string | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    type: number;
    priority: number;
    title: number;
    message: number;
    isRead: number;
    readAt: number;
    metadata: number;
    createdAt: number;
    organizationId: number;
    userId: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    type?: true;
    priority?: true;
    title?: true;
    message?: true;
    isRead?: true;
    readAt?: true;
    createdAt?: true;
    organizationId?: true;
    userId?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    type?: true;
    priority?: true;
    title?: true;
    message?: true;
    isRead?: true;
    readAt?: true;
    createdAt?: true;
    organizationId?: true;
    userId?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    type?: true;
    priority?: true;
    title?: true;
    message?: true;
    isRead?: true;
    readAt?: true;
    metadata?: true;
    createdAt?: true;
    organizationId?: true;
    userId?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    type: $Enums.NotificationType;
    priority: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead: boolean;
    readAt: Date | null;
    metadata: JsonValue | null;
    createdAt: Date;
    organizationId: string;
    userId: string;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      type?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      isRead?: boolean;
      readAt?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    type?: boolean;
    priority?: boolean;
    title?: boolean;
    message?: boolean;
    isRead?: boolean;
    readAt?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    organizationId?: boolean;
    userId?: boolean;
  };

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'type'
      | 'priority'
      | 'title'
      | 'message'
      | 'isRead'
      | 'readAt'
      | 'metadata'
      | 'createdAt'
      | 'organizationId'
      | 'userId',
      ExtArgs['result']['notification']
    >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        type: $Enums.NotificationType;
        priority: $Enums.NotificationPriority;
        title: string;
        message: string;
        isRead: boolean;
        readAt: Date | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        organizationId: string;
        userId: string;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> =
    $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true;
    };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'NotificationType'>;
    readonly priority: FieldRef<'Notification', 'NotificationPriority'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly isRead: FieldRef<'Notification', 'Boolean'>;
    readonly readAt: FieldRef<'Notification', 'DateTime'>;
    readonly metadata: FieldRef<'Notification', 'Json'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
    readonly organizationId: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model ApiActivityLog
   */

  export type AggregateApiActivityLog = {
    _count: ApiActivityLogCountAggregateOutputType | null;
    _avg: ApiActivityLogAvgAggregateOutputType | null;
    _sum: ApiActivityLogSumAggregateOutputType | null;
    _min: ApiActivityLogMinAggregateOutputType | null;
    _max: ApiActivityLogMaxAggregateOutputType | null;
  };

  export type ApiActivityLogAvgAggregateOutputType = {
    statusCode: number | null;
    responseTime: number | null;
  };

  export type ApiActivityLogSumAggregateOutputType = {
    statusCode: number | null;
    responseTime: number | null;
  };

  export type ApiActivityLogMinAggregateOutputType = {
    id: string | null;
    requestId: string | null;
    timestamp: Date | null;
    method: $Enums.HttpMethod | null;
    url: string | null;
    endpoint: string | null;
    statusCode: number | null;
    responseTime: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    category: string | null;
    endpointType: string | null;
    importance: string | null;
    error: string | null;
    organizationId: string | null;
    userId: string | null;
    endpointId: string | null;
  };

  export type ApiActivityLogMaxAggregateOutputType = {
    id: string | null;
    requestId: string | null;
    timestamp: Date | null;
    method: $Enums.HttpMethod | null;
    url: string | null;
    endpoint: string | null;
    statusCode: number | null;
    responseTime: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    category: string | null;
    endpointType: string | null;
    importance: string | null;
    error: string | null;
    organizationId: string | null;
    userId: string | null;
    endpointId: string | null;
  };

  export type ApiActivityLogCountAggregateOutputType = {
    id: number;
    requestId: number;
    timestamp: number;
    method: number;
    url: number;
    endpoint: number;
    statusCode: number;
    responseTime: number;
    userAgent: number;
    ipAddress: number;
    category: number;
    endpointType: number;
    importance: number;
    error: number;
    metadata: number;
    organizationId: number;
    userId: number;
    endpointId: number;
    _all: number;
  };

  export type ApiActivityLogAvgAggregateInputType = {
    statusCode?: true;
    responseTime?: true;
  };

  export type ApiActivityLogSumAggregateInputType = {
    statusCode?: true;
    responseTime?: true;
  };

  export type ApiActivityLogMinAggregateInputType = {
    id?: true;
    requestId?: true;
    timestamp?: true;
    method?: true;
    url?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    userAgent?: true;
    ipAddress?: true;
    category?: true;
    endpointType?: true;
    importance?: true;
    error?: true;
    organizationId?: true;
    userId?: true;
    endpointId?: true;
  };

  export type ApiActivityLogMaxAggregateInputType = {
    id?: true;
    requestId?: true;
    timestamp?: true;
    method?: true;
    url?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    userAgent?: true;
    ipAddress?: true;
    category?: true;
    endpointType?: true;
    importance?: true;
    error?: true;
    organizationId?: true;
    userId?: true;
    endpointId?: true;
  };

  export type ApiActivityLogCountAggregateInputType = {
    id?: true;
    requestId?: true;
    timestamp?: true;
    method?: true;
    url?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    userAgent?: true;
    ipAddress?: true;
    category?: true;
    endpointType?: true;
    importance?: true;
    error?: true;
    metadata?: true;
    organizationId?: true;
    userId?: true;
    endpointId?: true;
    _all?: true;
  };

  export type ApiActivityLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiActivityLog to aggregate.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApiActivityLogs
     **/
    _count?: true | ApiActivityLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ApiActivityLogAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ApiActivityLogSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApiActivityLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApiActivityLogMaxAggregateInputType;
  };

  export type GetApiActivityLogAggregateType<T extends ApiActivityLogAggregateArgs> = {
    [P in keyof T & keyof AggregateApiActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiActivityLog[P]>
      : GetScalarType<T[P], AggregateApiActivityLog[P]>;
  };

  export type ApiActivityLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
    orderBy?:
      | ApiActivityLogOrderByWithAggregationInput
      | ApiActivityLogOrderByWithAggregationInput[];
    by: ApiActivityLogScalarFieldEnum[] | ApiActivityLogScalarFieldEnum;
    having?: ApiActivityLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApiActivityLogCountAggregateInputType | true;
    _avg?: ApiActivityLogAvgAggregateInputType;
    _sum?: ApiActivityLogSumAggregateInputType;
    _min?: ApiActivityLogMinAggregateInputType;
    _max?: ApiActivityLogMaxAggregateInputType;
  };

  export type ApiActivityLogGroupByOutputType = {
    id: string;
    requestId: string;
    timestamp: Date;
    method: $Enums.HttpMethod;
    url: string;
    endpoint: string | null;
    statusCode: number;
    responseTime: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    category: string | null;
    endpointType: string | null;
    importance: string | null;
    error: string | null;
    metadata: JsonValue | null;
    organizationId: string;
    userId: string | null;
    endpointId: string | null;
    _count: ApiActivityLogCountAggregateOutputType | null;
    _avg: ApiActivityLogAvgAggregateOutputType | null;
    _sum: ApiActivityLogSumAggregateOutputType | null;
    _min: ApiActivityLogMinAggregateOutputType | null;
    _max: ApiActivityLogMaxAggregateOutputType | null;
  };

  type GetApiActivityLogGroupByPayload<T extends ApiActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiActivityLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApiActivityLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApiActivityLogGroupByOutputType[P]>
          : GetScalarType<T[P], ApiActivityLogGroupByOutputType[P]>;
      }
    >
  >;

  export type ApiActivityLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requestId?: boolean;
      timestamp?: boolean;
      method?: boolean;
      url?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      category?: boolean;
      endpointType?: boolean;
      importance?: boolean;
      error?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      endpointId?: boolean;
      endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requestId?: boolean;
      timestamp?: boolean;
      method?: boolean;
      url?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      category?: boolean;
      endpointType?: boolean;
      importance?: boolean;
      error?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      endpointId?: boolean;
      endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      requestId?: boolean;
      timestamp?: boolean;
      method?: boolean;
      url?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      category?: boolean;
      endpointType?: boolean;
      importance?: boolean;
      error?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      endpointId?: boolean;
      endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectScalar = {
    id?: boolean;
    requestId?: boolean;
    timestamp?: boolean;
    method?: boolean;
    url?: boolean;
    endpoint?: boolean;
    statusCode?: boolean;
    responseTime?: boolean;
    userAgent?: boolean;
    ipAddress?: boolean;
    category?: boolean;
    endpointType?: boolean;
    importance?: boolean;
    error?: boolean;
    metadata?: boolean;
    organizationId?: boolean;
    userId?: boolean;
    endpointId?: boolean;
  };

  export type ApiActivityLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'requestId'
    | 'timestamp'
    | 'method'
    | 'url'
    | 'endpoint'
    | 'statusCode'
    | 'responseTime'
    | 'userAgent'
    | 'ipAddress'
    | 'category'
    | 'endpointType'
    | 'importance'
    | 'error'
    | 'metadata'
    | 'organizationId'
    | 'userId'
    | 'endpointId',
    ExtArgs['result']['apiActivityLog']
  >;
  export type ApiActivityLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
  };
  export type ApiActivityLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
  };
  export type ApiActivityLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    endpointUsage?: boolean | ApiActivityLog$endpointUsageArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | ApiActivityLog$userArgs<ExtArgs>;
  };

  export type $ApiActivityLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ApiActivityLog';
    objects: {
      endpointUsage: Prisma.$EndpointPayload<ExtArgs> | null;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        requestId: string;
        timestamp: Date;
        method: $Enums.HttpMethod;
        url: string;
        endpoint: string | null;
        statusCode: number;
        responseTime: number | null;
        userAgent: string | null;
        ipAddress: string | null;
        category: string | null;
        endpointType: string | null;
        importance: string | null;
        error: string | null;
        metadata: Prisma.JsonValue | null;
        organizationId: string;
        userId: string | null;
        endpointId: string | null;
      },
      ExtArgs['result']['apiActivityLog']
    >;
    composites: {};
  };

  type ApiActivityLogGetPayload<S extends boolean | null | undefined | ApiActivityLogDefaultArgs> =
    $Result.GetResult<Prisma.$ApiActivityLogPayload, S>;

  type ApiActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiActivityLogCountAggregateInputType | true;
    };

  export interface ApiActivityLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ApiActivityLog'];
      meta: { name: 'ApiActivityLog' };
    };
    /**
     * Find zero or one ApiActivityLog that matches the filter.
     * @param {ApiActivityLogFindUniqueArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiActivityLogFindUniqueArgs>(
      args: SelectSubset<T, ApiActivityLogFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ApiActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiActivityLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApiActivityLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindFirstArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiActivityLogFindFirstArgs>(
      args?: SelectSubset<T, ApiActivityLogFindFirstArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindFirstOrThrowArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiActivityLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApiActivityLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApiActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiActivityLogs
     * const apiActivityLogs = await prisma.apiActivityLog.findMany()
     *
     * // Get first 10 ApiActivityLogs
     * const apiActivityLogs = await prisma.apiActivityLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApiActivityLogFindManyArgs>(
      args?: SelectSubset<T, ApiActivityLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ApiActivityLog.
     * @param {ApiActivityLogCreateArgs} args - Arguments to create a ApiActivityLog.
     * @example
     * // Create one ApiActivityLog
     * const ApiActivityLog = await prisma.apiActivityLog.create({
     *   data: {
     *     // ... data to create a ApiActivityLog
     *   }
     * })
     *
     */
    create<T extends ApiActivityLogCreateArgs>(
      args: SelectSubset<T, ApiActivityLogCreateArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ApiActivityLogs.
     * @param {ApiActivityLogCreateManyArgs} args - Arguments to create many ApiActivityLogs.
     * @example
     * // Create many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApiActivityLogCreateManyArgs>(
      args?: SelectSubset<T, ApiActivityLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ApiActivityLogs and returns the data saved in the database.
     * @param {ApiActivityLogCreateManyAndReturnArgs} args - Arguments to create many ApiActivityLogs.
     * @example
     * // Create many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ApiActivityLogs and only return the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApiActivityLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApiActivityLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ApiActivityLog.
     * @param {ApiActivityLogDeleteArgs} args - Arguments to delete one ApiActivityLog.
     * @example
     * // Delete one ApiActivityLog
     * const ApiActivityLog = await prisma.apiActivityLog.delete({
     *   where: {
     *     // ... filter to delete one ApiActivityLog
     *   }
     * })
     *
     */
    delete<T extends ApiActivityLogDeleteArgs>(
      args: SelectSubset<T, ApiActivityLogDeleteArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ApiActivityLog.
     * @param {ApiActivityLogUpdateArgs} args - Arguments to update one ApiActivityLog.
     * @example
     * // Update one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApiActivityLogUpdateArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ApiActivityLogs.
     * @param {ApiActivityLogDeleteManyArgs} args - Arguments to filter ApiActivityLogs to delete.
     * @example
     * // Delete a few ApiActivityLogs
     * const { count } = await prisma.apiActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApiActivityLogDeleteManyArgs>(
      args?: SelectSubset<T, ApiActivityLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApiActivityLogUpdateManyArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiActivityLogs and returns the data updated in the database.
     * @param {ApiActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ApiActivityLogs.
     * @example
     * // Update many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ApiActivityLogs and only return the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApiActivityLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ApiActivityLog.
     * @param {ApiActivityLogUpsertArgs} args - Arguments to update or create a ApiActivityLog.
     * @example
     * // Update or create a ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.upsert({
     *   create: {
     *     // ... data to create a ApiActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiActivityLogUpsertArgs>(
      args: SelectSubset<T, ApiActivityLogUpsertArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ApiActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogCountArgs} args - Arguments to filter ApiActivityLogs to count.
     * @example
     * // Count the number of ApiActivityLogs
     * const count = await prisma.apiActivityLog.count({
     *   where: {
     *     // ... the filter for the ApiActivityLogs we want to count
     *   }
     * })
     **/
    count<T extends ApiActivityLogCountArgs>(
      args?: Subset<T, ApiActivityLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiActivityLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApiActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApiActivityLogAggregateArgs>(
      args: Subset<T, ApiActivityLogAggregateArgs>
    ): Prisma.PrismaPromise<GetApiActivityLogAggregateType<T>>;

    /**
     * Group by ApiActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApiActivityLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApiActivityLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetApiActivityLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApiActivityLog model
     */
    readonly fields: ApiActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiActivityLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    endpointUsage<T extends ApiActivityLog$endpointUsageArgs<ExtArgs> = {}>(
      args?: Subset<T, ApiActivityLog$endpointUsageArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends ApiActivityLog$userArgs<ExtArgs> = {}>(
      args?: Subset<T, ApiActivityLog$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApiActivityLog model
   */
  interface ApiActivityLogFieldRefs {
    readonly id: FieldRef<'ApiActivityLog', 'String'>;
    readonly requestId: FieldRef<'ApiActivityLog', 'String'>;
    readonly timestamp: FieldRef<'ApiActivityLog', 'DateTime'>;
    readonly method: FieldRef<'ApiActivityLog', 'HttpMethod'>;
    readonly url: FieldRef<'ApiActivityLog', 'String'>;
    readonly endpoint: FieldRef<'ApiActivityLog', 'String'>;
    readonly statusCode: FieldRef<'ApiActivityLog', 'Int'>;
    readonly responseTime: FieldRef<'ApiActivityLog', 'Int'>;
    readonly userAgent: FieldRef<'ApiActivityLog', 'String'>;
    readonly ipAddress: FieldRef<'ApiActivityLog', 'String'>;
    readonly category: FieldRef<'ApiActivityLog', 'String'>;
    readonly endpointType: FieldRef<'ApiActivityLog', 'String'>;
    readonly importance: FieldRef<'ApiActivityLog', 'String'>;
    readonly error: FieldRef<'ApiActivityLog', 'String'>;
    readonly metadata: FieldRef<'ApiActivityLog', 'Json'>;
    readonly organizationId: FieldRef<'ApiActivityLog', 'String'>;
    readonly userId: FieldRef<'ApiActivityLog', 'String'>;
    readonly endpointId: FieldRef<'ApiActivityLog', 'String'>;
  }

  // Custom InputTypes
  /**
   * ApiActivityLog findUnique
   */
  export type ApiActivityLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog findUniqueOrThrow
   */
  export type ApiActivityLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog findFirst
   */
  export type ApiActivityLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiActivityLogs.
     */
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog findFirstOrThrow
   */
  export type ApiActivityLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiActivityLogs.
     */
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog findMany
   */
  export type ApiActivityLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLogs to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog create
   */
  export type ApiActivityLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a ApiActivityLog.
     */
    data: XOR<ApiActivityLogCreateInput, ApiActivityLogUncheckedCreateInput>;
  };

  /**
   * ApiActivityLog createMany
   */
  export type ApiActivityLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApiActivityLogs.
     */
    data: ApiActivityLogCreateManyInput | ApiActivityLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ApiActivityLog createManyAndReturn
   */
  export type ApiActivityLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * The data used to create many ApiActivityLogs.
     */
    data: ApiActivityLogCreateManyInput | ApiActivityLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiActivityLog update
   */
  export type ApiActivityLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a ApiActivityLog.
     */
    data: XOR<ApiActivityLogUpdateInput, ApiActivityLogUncheckedUpdateInput>;
    /**
     * Choose, which ApiActivityLog to update.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog updateMany
   */
  export type ApiActivityLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApiActivityLogs.
     */
    data: XOR<ApiActivityLogUpdateManyMutationInput, ApiActivityLogUncheckedUpdateManyInput>;
    /**
     * Filter which ApiActivityLogs to update
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to update.
     */
    limit?: number;
  };

  /**
   * ApiActivityLog updateManyAndReturn
   */
  export type ApiActivityLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * The data used to update ApiActivityLogs.
     */
    data: XOR<ApiActivityLogUpdateManyMutationInput, ApiActivityLogUncheckedUpdateManyInput>;
    /**
     * Filter which ApiActivityLogs to update
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiActivityLog upsert
   */
  export type ApiActivityLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the ApiActivityLog to update in case it exists.
     */
    where: ApiActivityLogWhereUniqueInput;
    /**
     * In case the ApiActivityLog found by the `where` argument doesn't exist, create a new ApiActivityLog with this data.
     */
    create: XOR<ApiActivityLogCreateInput, ApiActivityLogUncheckedCreateInput>;
    /**
     * In case the ApiActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiActivityLogUpdateInput, ApiActivityLogUncheckedUpdateInput>;
  };

  /**
   * ApiActivityLog delete
   */
  export type ApiActivityLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter which ApiActivityLog to delete.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog deleteMany
   */
  export type ApiActivityLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiActivityLogs to delete
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to delete.
     */
    limit?: number;
  };

  /**
   * ApiActivityLog.endpointUsage
   */
  export type ApiActivityLog$endpointUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
  };

  /**
   * ApiActivityLog.user
   */
  export type ApiActivityLog$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * ApiActivityLog without action
   */
  export type ApiActivityLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
  };

  /**
   * Model DatabaseObject
   */

  export type AggregateDatabaseObject = {
    _count: DatabaseObjectCountAggregateOutputType | null;
    _min: DatabaseObjectMinAggregateOutputType | null;
    _max: DatabaseObjectMaxAggregateOutputType | null;
  };

  export type DatabaseObjectMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    schema: string | null;
    type: string | null;
    path: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    serviceId: string | null;
  };

  export type DatabaseObjectMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    schema: string | null;
    type: string | null;
    path: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
    serviceId: string | null;
  };

  export type DatabaseObjectCountAggregateOutputType = {
    id: number;
    name: number;
    schema: number;
    type: number;
    path: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    serviceId: number;
    _all: number;
  };

  export type DatabaseObjectMinAggregateInputType = {
    id?: true;
    name?: true;
    schema?: true;
    type?: true;
    path?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
  };

  export type DatabaseObjectMaxAggregateInputType = {
    id?: true;
    name?: true;
    schema?: true;
    type?: true;
    path?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
  };

  export type DatabaseObjectCountAggregateInputType = {
    id?: true;
    name?: true;
    schema?: true;
    type?: true;
    path?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    serviceId?: true;
    _all?: true;
  };

  export type DatabaseObjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseObject to aggregate.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DatabaseObjects
     **/
    _count?: true | DatabaseObjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DatabaseObjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DatabaseObjectMaxAggregateInputType;
  };

  export type GetDatabaseObjectAggregateType<T extends DatabaseObjectAggregateArgs> = {
    [P in keyof T & keyof AggregateDatabaseObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseObject[P]>
      : GetScalarType<T[P], AggregateDatabaseObject[P]>;
  };

  export type DatabaseObjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseObjectWhereInput;
    orderBy?:
      | DatabaseObjectOrderByWithAggregationInput
      | DatabaseObjectOrderByWithAggregationInput[];
    by: DatabaseObjectScalarFieldEnum[] | DatabaseObjectScalarFieldEnum;
    having?: DatabaseObjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DatabaseObjectCountAggregateInputType | true;
    _min?: DatabaseObjectMinAggregateInputType;
    _max?: DatabaseObjectMaxAggregateInputType;
  };

  export type DatabaseObjectGroupByOutputType = {
    id: string;
    name: string;
    schema: string | null;
    type: string;
    path: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    serviceId: string | null;
    _count: DatabaseObjectCountAggregateOutputType | null;
    _min: DatabaseObjectMinAggregateOutputType | null;
    _max: DatabaseObjectMaxAggregateOutputType | null;
  };

  type GetDatabaseObjectGroupByPayload<T extends DatabaseObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseObjectGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DatabaseObjectGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DatabaseObjectGroupByOutputType[P]>
          : GetScalarType<T[P], DatabaseObjectGroupByOutputType[P]>;
      }
    >
  >;

  export type DatabaseObjectSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      schema?: boolean;
      type?: boolean;
      path?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      schema?: boolean;
      type?: boolean;
      path?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      schema?: boolean;
      type?: boolean;
      path?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectScalar = {
    id?: boolean;
    name?: boolean;
    schema?: boolean;
    type?: boolean;
    path?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
    serviceId?: boolean;
  };

  export type DatabaseObjectOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'schema'
    | 'type'
    | 'path'
    | 'metadata'
    | 'createdAt'
    | 'updatedAt'
    | 'organizationId'
    | 'serviceId',
    ExtArgs['result']['databaseObject']
  >;
  export type DatabaseObjectInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
  };
  export type DatabaseObjectIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
  };
  export type DatabaseObjectIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | DatabaseObject$serviceArgs<ExtArgs>;
  };

  export type $DatabaseObjectPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DatabaseObject';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        schema: string | null;
        type: string;
        path: string | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
        organizationId: string;
        serviceId: string | null;
      },
      ExtArgs['result']['databaseObject']
    >;
    composites: {};
  };

  type DatabaseObjectGetPayload<S extends boolean | null | undefined | DatabaseObjectDefaultArgs> =
    $Result.GetResult<Prisma.$DatabaseObjectPayload, S>;

  type DatabaseObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseObjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseObjectCountAggregateInputType | true;
    };

  export interface DatabaseObjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DatabaseObject'];
      meta: { name: 'DatabaseObject' };
    };
    /**
     * Find zero or one DatabaseObject that matches the filter.
     * @param {DatabaseObjectFindUniqueArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseObjectFindUniqueArgs>(
      args: SelectSubset<T, DatabaseObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DatabaseObject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseObjectFindUniqueOrThrowArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseObjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DatabaseObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindFirstArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseObjectFindFirstArgs>(
      args?: SelectSubset<T, DatabaseObjectFindFirstArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseObject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindFirstOrThrowArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseObjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DatabaseObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DatabaseObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseObjects
     * const databaseObjects = await prisma.databaseObject.findMany()
     *
     * // Get first 10 DatabaseObjects
     * const databaseObjects = await prisma.databaseObject.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DatabaseObjectFindManyArgs>(
      args?: SelectSubset<T, DatabaseObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a DatabaseObject.
     * @param {DatabaseObjectCreateArgs} args - Arguments to create a DatabaseObject.
     * @example
     * // Create one DatabaseObject
     * const DatabaseObject = await prisma.databaseObject.create({
     *   data: {
     *     // ... data to create a DatabaseObject
     *   }
     * })
     *
     */
    create<T extends DatabaseObjectCreateArgs>(
      args: SelectSubset<T, DatabaseObjectCreateArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DatabaseObjects.
     * @param {DatabaseObjectCreateManyArgs} args - Arguments to create many DatabaseObjects.
     * @example
     * // Create many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DatabaseObjectCreateManyArgs>(
      args?: SelectSubset<T, DatabaseObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DatabaseObjects and returns the data saved in the database.
     * @param {DatabaseObjectCreateManyAndReturnArgs} args - Arguments to create many DatabaseObjects.
     * @example
     * // Create many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DatabaseObjects and only return the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DatabaseObjectCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DatabaseObjectCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DatabaseObject.
     * @param {DatabaseObjectDeleteArgs} args - Arguments to delete one DatabaseObject.
     * @example
     * // Delete one DatabaseObject
     * const DatabaseObject = await prisma.databaseObject.delete({
     *   where: {
     *     // ... filter to delete one DatabaseObject
     *   }
     * })
     *
     */
    delete<T extends DatabaseObjectDeleteArgs>(
      args: SelectSubset<T, DatabaseObjectDeleteArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DatabaseObject.
     * @param {DatabaseObjectUpdateArgs} args - Arguments to update one DatabaseObject.
     * @example
     * // Update one DatabaseObject
     * const databaseObject = await prisma.databaseObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DatabaseObjectUpdateArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DatabaseObjects.
     * @param {DatabaseObjectDeleteManyArgs} args - Arguments to filter DatabaseObjects to delete.
     * @example
     * // Delete a few DatabaseObjects
     * const { count } = await prisma.databaseObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DatabaseObjectDeleteManyArgs>(
      args?: SelectSubset<T, DatabaseObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DatabaseObjectUpdateManyArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseObjects and returns the data updated in the database.
     * @param {DatabaseObjectUpdateManyAndReturnArgs} args - Arguments to update many DatabaseObjects.
     * @example
     * // Update many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DatabaseObjects and only return the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DatabaseObjectUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DatabaseObject.
     * @param {DatabaseObjectUpsertArgs} args - Arguments to update or create a DatabaseObject.
     * @example
     * // Update or create a DatabaseObject
     * const databaseObject = await prisma.databaseObject.upsert({
     *   create: {
     *     // ... data to create a DatabaseObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseObject we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseObjectUpsertArgs>(
      args: SelectSubset<T, DatabaseObjectUpsertArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DatabaseObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectCountArgs} args - Arguments to filter DatabaseObjects to count.
     * @example
     * // Count the number of DatabaseObjects
     * const count = await prisma.databaseObject.count({
     *   where: {
     *     // ... the filter for the DatabaseObjects we want to count
     *   }
     * })
     **/
    count<T extends DatabaseObjectCountArgs>(
      args?: Subset<T, DatabaseObjectCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseObjectCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DatabaseObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DatabaseObjectAggregateArgs>(
      args: Subset<T, DatabaseObjectAggregateArgs>
    ): Prisma.PrismaPromise<GetDatabaseObjectAggregateType<T>>;

    /**
     * Group by DatabaseObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DatabaseObjectGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseObjectGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DatabaseObjectGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDatabaseObjectGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DatabaseObject model
     */
    readonly fields: DatabaseObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseObjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends DatabaseObject$serviceArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseObject$serviceArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DatabaseObject model
   */
  interface DatabaseObjectFieldRefs {
    readonly id: FieldRef<'DatabaseObject', 'String'>;
    readonly name: FieldRef<'DatabaseObject', 'String'>;
    readonly schema: FieldRef<'DatabaseObject', 'String'>;
    readonly type: FieldRef<'DatabaseObject', 'String'>;
    readonly path: FieldRef<'DatabaseObject', 'String'>;
    readonly metadata: FieldRef<'DatabaseObject', 'Json'>;
    readonly createdAt: FieldRef<'DatabaseObject', 'DateTime'>;
    readonly updatedAt: FieldRef<'DatabaseObject', 'DateTime'>;
    readonly organizationId: FieldRef<'DatabaseObject', 'String'>;
    readonly serviceId: FieldRef<'DatabaseObject', 'String'>;
  }

  // Custom InputTypes
  /**
   * DatabaseObject findUnique
   */
  export type DatabaseObjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject findUniqueOrThrow
   */
  export type DatabaseObjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject findFirst
   */
  export type DatabaseObjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseObjects.
     */
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject findFirstOrThrow
   */
  export type DatabaseObjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseObjects.
     */
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject findMany
   */
  export type DatabaseObjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter, which DatabaseObjects to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject create
   */
  export type DatabaseObjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * The data needed to create a DatabaseObject.
     */
    data: XOR<DatabaseObjectCreateInput, DatabaseObjectUncheckedCreateInput>;
  };

  /**
   * DatabaseObject createMany
   */
  export type DatabaseObjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DatabaseObjects.
     */
    data: DatabaseObjectCreateManyInput | DatabaseObjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DatabaseObject createManyAndReturn
   */
  export type DatabaseObjectCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data used to create many DatabaseObjects.
     */
    data: DatabaseObjectCreateManyInput | DatabaseObjectCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DatabaseObject update
   */
  export type DatabaseObjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * The data needed to update a DatabaseObject.
     */
    data: XOR<DatabaseObjectUpdateInput, DatabaseObjectUncheckedUpdateInput>;
    /**
     * Choose, which DatabaseObject to update.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject updateMany
   */
  export type DatabaseObjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DatabaseObjects.
     */
    data: XOR<DatabaseObjectUpdateManyMutationInput, DatabaseObjectUncheckedUpdateManyInput>;
    /**
     * Filter which DatabaseObjects to update
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to update.
     */
    limit?: number;
  };

  /**
   * DatabaseObject updateManyAndReturn
   */
  export type DatabaseObjectUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data used to update DatabaseObjects.
     */
    data: XOR<DatabaseObjectUpdateManyMutationInput, DatabaseObjectUncheckedUpdateManyInput>;
    /**
     * Filter which DatabaseObjects to update
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DatabaseObject upsert
   */
  export type DatabaseObjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * The filter to search for the DatabaseObject to update in case it exists.
     */
    where: DatabaseObjectWhereUniqueInput;
    /**
     * In case the DatabaseObject found by the `where` argument doesn't exist, create a new DatabaseObject with this data.
     */
    create: XOR<DatabaseObjectCreateInput, DatabaseObjectUncheckedCreateInput>;
    /**
     * In case the DatabaseObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseObjectUpdateInput, DatabaseObjectUncheckedUpdateInput>;
  };

  /**
   * DatabaseObject delete
   */
  export type DatabaseObjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
    /**
     * Filter which DatabaseObject to delete.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject deleteMany
   */
  export type DatabaseObjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseObjects to delete
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to delete.
     */
    limit?: number;
  };

  /**
   * DatabaseObject.service
   */
  export type DatabaseObject$serviceArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
  };

  /**
   * DatabaseObject without action
   */
  export type DatabaseObjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseObjectInclude<ExtArgs> | null;
  };

  /**
   * Model ExposedEntity
   */

  export type AggregateExposedEntity = {
    _count: ExposedEntityCountAggregateOutputType | null;
    _min: ExposedEntityMinAggregateOutputType | null;
    _max: ExposedEntityMaxAggregateOutputType | null;
  };

  export type ExposedEntityMinAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    connectionId: string | null;
    organizationId: string | null;
    database: string | null;
    schema: string | null;
    name: string | null;
    type: $Enums.ExposedEntityType | null;
    primaryKey: string | null;
    allowRead: boolean | null;
    allowCreate: boolean | null;
    allowUpdate: boolean | null;
    allowDelete: boolean | null;
    defaultSort: string | null;
    softDeleteEnabled: boolean | null;
    softDeleteColumn: string | null;
    softDeleteValue: string | null;
    pathSlug: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type ExposedEntityMaxAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    connectionId: string | null;
    organizationId: string | null;
    database: string | null;
    schema: string | null;
    name: string | null;
    type: $Enums.ExposedEntityType | null;
    primaryKey: string | null;
    allowRead: boolean | null;
    allowCreate: boolean | null;
    allowUpdate: boolean | null;
    allowDelete: boolean | null;
    defaultSort: string | null;
    softDeleteEnabled: boolean | null;
    softDeleteColumn: string | null;
    softDeleteValue: string | null;
    pathSlug: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type ExposedEntityCountAggregateOutputType = {
    id: number;
    serviceId: number;
    connectionId: number;
    organizationId: number;
    database: number;
    schema: number;
    name: number;
    type: number;
    primaryKey: number;
    allowRead: number;
    allowCreate: number;
    allowUpdate: number;
    allowDelete: number;
    defaultSort: number;
    softDeleteEnabled: number;
    softDeleteColumn: number;
    softDeleteValue: number;
    pathSlug: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type ExposedEntityMinAggregateInputType = {
    id?: true;
    serviceId?: true;
    connectionId?: true;
    organizationId?: true;
    database?: true;
    schema?: true;
    name?: true;
    type?: true;
    primaryKey?: true;
    allowRead?: true;
    allowCreate?: true;
    allowUpdate?: true;
    allowDelete?: true;
    defaultSort?: true;
    softDeleteEnabled?: true;
    softDeleteColumn?: true;
    softDeleteValue?: true;
    pathSlug?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type ExposedEntityMaxAggregateInputType = {
    id?: true;
    serviceId?: true;
    connectionId?: true;
    organizationId?: true;
    database?: true;
    schema?: true;
    name?: true;
    type?: true;
    primaryKey?: true;
    allowRead?: true;
    allowCreate?: true;
    allowUpdate?: true;
    allowDelete?: true;
    defaultSort?: true;
    softDeleteEnabled?: true;
    softDeleteColumn?: true;
    softDeleteValue?: true;
    pathSlug?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type ExposedEntityCountAggregateInputType = {
    id?: true;
    serviceId?: true;
    connectionId?: true;
    organizationId?: true;
    database?: true;
    schema?: true;
    name?: true;
    type?: true;
    primaryKey?: true;
    allowRead?: true;
    allowCreate?: true;
    allowUpdate?: true;
    allowDelete?: true;
    defaultSort?: true;
    softDeleteEnabled?: true;
    softDeleteColumn?: true;
    softDeleteValue?: true;
    pathSlug?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type ExposedEntityAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedEntity to aggregate.
     */
    where?: ExposedEntityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedEntities to fetch.
     */
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExposedEntityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedEntities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedEntities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExposedEntities
     **/
    _count?: true | ExposedEntityCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExposedEntityMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExposedEntityMaxAggregateInputType;
  };

  export type GetExposedEntityAggregateType<T extends ExposedEntityAggregateArgs> = {
    [P in keyof T & keyof AggregateExposedEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExposedEntity[P]>
      : GetScalarType<T[P], AggregateExposedEntity[P]>;
  };

  export type ExposedEntityGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedEntityWhereInput;
    orderBy?: ExposedEntityOrderByWithAggregationInput | ExposedEntityOrderByWithAggregationInput[];
    by: ExposedEntityScalarFieldEnum[] | ExposedEntityScalarFieldEnum;
    having?: ExposedEntityScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExposedEntityCountAggregateInputType | true;
    _min?: ExposedEntityMinAggregateInputType;
    _max?: ExposedEntityMaxAggregateInputType;
  };

  export type ExposedEntityGroupByOutputType = {
    id: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey: string | null;
    allowRead: boolean;
    allowCreate: boolean;
    allowUpdate: boolean;
    allowDelete: boolean;
    defaultSort: string | null;
    softDeleteEnabled: boolean;
    softDeleteColumn: string | null;
    softDeleteValue: string | null;
    pathSlug: string | null;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: ExposedEntityCountAggregateOutputType | null;
    _min: ExposedEntityMinAggregateOutputType | null;
    _max: ExposedEntityMaxAggregateOutputType | null;
  };

  type GetExposedEntityGroupByPayload<T extends ExposedEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExposedEntityGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ExposedEntityGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ExposedEntityGroupByOutputType[P]>
          : GetScalarType<T[P], ExposedEntityGroupByOutputType[P]>;
      }
    >
  >;

  export type ExposedEntitySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      connectionId?: boolean;
      organizationId?: boolean;
      database?: boolean;
      schema?: boolean;
      name?: boolean;
      type?: boolean;
      primaryKey?: boolean;
      allowRead?: boolean;
      allowCreate?: boolean;
      allowUpdate?: boolean;
      allowDelete?: boolean;
      defaultSort?: boolean;
      softDeleteEnabled?: boolean;
      softDeleteColumn?: boolean;
      softDeleteValue?: boolean;
      pathSlug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
      connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
      creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      fieldPolicies?: boolean | ExposedEntity$fieldPoliciesArgs<ExtArgs>;
      rowPolicies?: boolean | ExposedEntity$rowPoliciesArgs<ExtArgs>;
      _count?: boolean | ExposedEntityCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedEntity']
  >;

  export type ExposedEntitySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      connectionId?: boolean;
      organizationId?: boolean;
      database?: boolean;
      schema?: boolean;
      name?: boolean;
      type?: boolean;
      primaryKey?: boolean;
      allowRead?: boolean;
      allowCreate?: boolean;
      allowUpdate?: boolean;
      allowDelete?: boolean;
      defaultSort?: boolean;
      softDeleteEnabled?: boolean;
      softDeleteColumn?: boolean;
      softDeleteValue?: boolean;
      pathSlug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
      connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
      creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedEntity']
  >;

  export type ExposedEntitySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      connectionId?: boolean;
      organizationId?: boolean;
      database?: boolean;
      schema?: boolean;
      name?: boolean;
      type?: boolean;
      primaryKey?: boolean;
      allowRead?: boolean;
      allowCreate?: boolean;
      allowUpdate?: boolean;
      allowDelete?: boolean;
      defaultSort?: boolean;
      softDeleteEnabled?: boolean;
      softDeleteColumn?: boolean;
      softDeleteValue?: boolean;
      pathSlug?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
      connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
      creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedEntity']
  >;

  export type ExposedEntitySelectScalar = {
    id?: boolean;
    serviceId?: boolean;
    connectionId?: boolean;
    organizationId?: boolean;
    database?: boolean;
    schema?: boolean;
    name?: boolean;
    type?: boolean;
    primaryKey?: boolean;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: boolean;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: boolean;
    softDeleteValue?: boolean;
    pathSlug?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type ExposedEntityOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'serviceId'
    | 'connectionId'
    | 'organizationId'
    | 'database'
    | 'schema'
    | 'name'
    | 'type'
    | 'primaryKey'
    | 'allowRead'
    | 'allowCreate'
    | 'allowUpdate'
    | 'allowDelete'
    | 'defaultSort'
    | 'softDeleteEnabled'
    | 'softDeleteColumn'
    | 'softDeleteValue'
    | 'pathSlug'
    | 'createdAt'
    | 'updatedAt'
    | 'createdBy',
    ExtArgs['result']['exposedEntity']
  >;
  export type ExposedEntityInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
    creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    fieldPolicies?: boolean | ExposedEntity$fieldPoliciesArgs<ExtArgs>;
    rowPolicies?: boolean | ExposedEntity$rowPoliciesArgs<ExtArgs>;
    _count?: boolean | ExposedEntityCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ExposedEntityIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
    creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type ExposedEntityIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | DatabaseConnectionDefaultArgs<ExtArgs>;
    creator?: boolean | ExposedEntity$creatorArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ExposedEntityPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ExposedEntity';
    objects: {
      connection: Prisma.$DatabaseConnectionPayload<ExtArgs>;
      creator: Prisma.$UserPayload<ExtArgs> | null;
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs>;
      fieldPolicies: Prisma.$ExposedFieldPolicyPayload<ExtArgs>[];
      rowPolicies: Prisma.$ExposedRowPolicyPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        serviceId: string;
        connectionId: string;
        organizationId: string;
        database: string;
        schema: string | null;
        name: string;
        type: $Enums.ExposedEntityType;
        primaryKey: string | null;
        allowRead: boolean;
        allowCreate: boolean;
        allowUpdate: boolean;
        allowDelete: boolean;
        defaultSort: string | null;
        softDeleteEnabled: boolean;
        softDeleteColumn: string | null;
        softDeleteValue: string | null;
        pathSlug: string | null;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs['result']['exposedEntity']
    >;
    composites: {};
  };

  type ExposedEntityGetPayload<S extends boolean | null | undefined | ExposedEntityDefaultArgs> =
    $Result.GetResult<Prisma.$ExposedEntityPayload, S>;

  type ExposedEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExposedEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExposedEntityCountAggregateInputType | true;
    };

  export interface ExposedEntityDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ExposedEntity'];
      meta: { name: 'ExposedEntity' };
    };
    /**
     * Find zero or one ExposedEntity that matches the filter.
     * @param {ExposedEntityFindUniqueArgs} args - Arguments to find a ExposedEntity
     * @example
     * // Get one ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExposedEntityFindUniqueArgs>(
      args: SelectSubset<T, ExposedEntityFindUniqueArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExposedEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExposedEntityFindUniqueOrThrowArgs} args - Arguments to find a ExposedEntity
     * @example
     * // Get one ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExposedEntityFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExposedEntityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityFindFirstArgs} args - Arguments to find a ExposedEntity
     * @example
     * // Get one ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExposedEntityFindFirstArgs>(
      args?: SelectSubset<T, ExposedEntityFindFirstArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityFindFirstOrThrowArgs} args - Arguments to find a ExposedEntity
     * @example
     * // Get one ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExposedEntityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExposedEntityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExposedEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExposedEntities
     * const exposedEntities = await prisma.exposedEntity.findMany()
     *
     * // Get first 10 ExposedEntities
     * const exposedEntities = await prisma.exposedEntity.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const exposedEntityWithIdOnly = await prisma.exposedEntity.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExposedEntityFindManyArgs>(
      args?: SelectSubset<T, ExposedEntityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ExposedEntity.
     * @param {ExposedEntityCreateArgs} args - Arguments to create a ExposedEntity.
     * @example
     * // Create one ExposedEntity
     * const ExposedEntity = await prisma.exposedEntity.create({
     *   data: {
     *     // ... data to create a ExposedEntity
     *   }
     * })
     *
     */
    create<T extends ExposedEntityCreateArgs>(
      args: SelectSubset<T, ExposedEntityCreateArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExposedEntities.
     * @param {ExposedEntityCreateManyArgs} args - Arguments to create many ExposedEntities.
     * @example
     * // Create many ExposedEntities
     * const exposedEntity = await prisma.exposedEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExposedEntityCreateManyArgs>(
      args?: SelectSubset<T, ExposedEntityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExposedEntities and returns the data saved in the database.
     * @param {ExposedEntityCreateManyAndReturnArgs} args - Arguments to create many ExposedEntities.
     * @example
     * // Create many ExposedEntities
     * const exposedEntity = await prisma.exposedEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExposedEntities and only return the `id`
     * const exposedEntityWithIdOnly = await prisma.exposedEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExposedEntityCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExposedEntityCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExposedEntity.
     * @param {ExposedEntityDeleteArgs} args - Arguments to delete one ExposedEntity.
     * @example
     * // Delete one ExposedEntity
     * const ExposedEntity = await prisma.exposedEntity.delete({
     *   where: {
     *     // ... filter to delete one ExposedEntity
     *   }
     * })
     *
     */
    delete<T extends ExposedEntityDeleteArgs>(
      args: SelectSubset<T, ExposedEntityDeleteArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExposedEntity.
     * @param {ExposedEntityUpdateArgs} args - Arguments to update one ExposedEntity.
     * @example
     * // Update one ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExposedEntityUpdateArgs>(
      args: SelectSubset<T, ExposedEntityUpdateArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExposedEntities.
     * @param {ExposedEntityDeleteManyArgs} args - Arguments to filter ExposedEntities to delete.
     * @example
     * // Delete a few ExposedEntities
     * const { count } = await prisma.exposedEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExposedEntityDeleteManyArgs>(
      args?: SelectSubset<T, ExposedEntityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExposedEntities
     * const exposedEntity = await prisma.exposedEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExposedEntityUpdateManyArgs>(
      args: SelectSubset<T, ExposedEntityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedEntities and returns the data updated in the database.
     * @param {ExposedEntityUpdateManyAndReturnArgs} args - Arguments to update many ExposedEntities.
     * @example
     * // Update many ExposedEntities
     * const exposedEntity = await prisma.exposedEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExposedEntities and only return the `id`
     * const exposedEntityWithIdOnly = await prisma.exposedEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExposedEntityUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExposedEntityUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedEntityPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExposedEntity.
     * @param {ExposedEntityUpsertArgs} args - Arguments to update or create a ExposedEntity.
     * @example
     * // Update or create a ExposedEntity
     * const exposedEntity = await prisma.exposedEntity.upsert({
     *   create: {
     *     // ... data to create a ExposedEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExposedEntity we want to update
     *   }
     * })
     */
    upsert<T extends ExposedEntityUpsertArgs>(
      args: SelectSubset<T, ExposedEntityUpsertArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      $Result.GetResult<Prisma.$ExposedEntityPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExposedEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityCountArgs} args - Arguments to filter ExposedEntities to count.
     * @example
     * // Count the number of ExposedEntities
     * const count = await prisma.exposedEntity.count({
     *   where: {
     *     // ... the filter for the ExposedEntities we want to count
     *   }
     * })
     **/
    count<T extends ExposedEntityCountArgs>(
      args?: Subset<T, ExposedEntityCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExposedEntityCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExposedEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExposedEntityAggregateArgs>(
      args: Subset<T, ExposedEntityAggregateArgs>
    ): Prisma.PrismaPromise<GetExposedEntityAggregateType<T>>;

    /**
     * Group by ExposedEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExposedEntityGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExposedEntityGroupByArgs['orderBy'] }
        : { orderBy?: ExposedEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExposedEntityGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetExposedEntityGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExposedEntity model
     */
    readonly fields: ExposedEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExposedEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExposedEntityClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    connection<T extends DatabaseConnectionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, DatabaseConnectionDefaultArgs<ExtArgs>>
    ): Prisma__DatabaseConnectionClient<
      | $Result.GetResult<
          Prisma.$DatabaseConnectionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends ExposedEntity$creatorArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedEntity$creatorArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    fieldPolicies<T extends ExposedEntity$fieldPoliciesArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedEntity$fieldPoliciesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    rowPolicies<T extends ExposedEntity$rowPoliciesArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedEntity$rowPoliciesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExposedRowPolicyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExposedEntity model
   */
  interface ExposedEntityFieldRefs {
    readonly id: FieldRef<'ExposedEntity', 'String'>;
    readonly serviceId: FieldRef<'ExposedEntity', 'String'>;
    readonly connectionId: FieldRef<'ExposedEntity', 'String'>;
    readonly organizationId: FieldRef<'ExposedEntity', 'String'>;
    readonly database: FieldRef<'ExposedEntity', 'String'>;
    readonly schema: FieldRef<'ExposedEntity', 'String'>;
    readonly name: FieldRef<'ExposedEntity', 'String'>;
    readonly type: FieldRef<'ExposedEntity', 'ExposedEntityType'>;
    readonly primaryKey: FieldRef<'ExposedEntity', 'String'>;
    readonly allowRead: FieldRef<'ExposedEntity', 'Boolean'>;
    readonly allowCreate: FieldRef<'ExposedEntity', 'Boolean'>;
    readonly allowUpdate: FieldRef<'ExposedEntity', 'Boolean'>;
    readonly allowDelete: FieldRef<'ExposedEntity', 'Boolean'>;
    readonly defaultSort: FieldRef<'ExposedEntity', 'String'>;
    readonly softDeleteEnabled: FieldRef<'ExposedEntity', 'Boolean'>;
    readonly softDeleteColumn: FieldRef<'ExposedEntity', 'String'>;
    readonly softDeleteValue: FieldRef<'ExposedEntity', 'String'>;
    readonly pathSlug: FieldRef<'ExposedEntity', 'String'>;
    readonly createdAt: FieldRef<'ExposedEntity', 'DateTime'>;
    readonly updatedAt: FieldRef<'ExposedEntity', 'DateTime'>;
    readonly createdBy: FieldRef<'ExposedEntity', 'String'>;
  }

  // Custom InputTypes
  /**
   * ExposedEntity findUnique
   */
  export type ExposedEntityFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedEntity to fetch.
     */
    where: ExposedEntityWhereUniqueInput;
  };

  /**
   * ExposedEntity findUniqueOrThrow
   */
  export type ExposedEntityFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedEntity to fetch.
     */
    where: ExposedEntityWhereUniqueInput;
  };

  /**
   * ExposedEntity findFirst
   */
  export type ExposedEntityFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedEntity to fetch.
     */
    where?: ExposedEntityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedEntities to fetch.
     */
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedEntities.
     */
    cursor?: ExposedEntityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedEntities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedEntities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedEntities.
     */
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * ExposedEntity findFirstOrThrow
   */
  export type ExposedEntityFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedEntity to fetch.
     */
    where?: ExposedEntityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedEntities to fetch.
     */
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedEntities.
     */
    cursor?: ExposedEntityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedEntities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedEntities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedEntities.
     */
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * ExposedEntity findMany
   */
  export type ExposedEntityFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedEntities to fetch.
     */
    where?: ExposedEntityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedEntities to fetch.
     */
    orderBy?: ExposedEntityOrderByWithRelationInput | ExposedEntityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExposedEntities.
     */
    cursor?: ExposedEntityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedEntities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedEntities.
     */
    skip?: number;
    distinct?: ExposedEntityScalarFieldEnum | ExposedEntityScalarFieldEnum[];
  };

  /**
   * ExposedEntity create
   */
  export type ExposedEntityCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExposedEntity.
     */
    data: XOR<ExposedEntityCreateInput, ExposedEntityUncheckedCreateInput>;
  };

  /**
   * ExposedEntity createMany
   */
  export type ExposedEntityCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExposedEntities.
     */
    data: ExposedEntityCreateManyInput | ExposedEntityCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ExposedEntity createManyAndReturn
   */
  export type ExposedEntityCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * The data used to create many ExposedEntities.
     */
    data: ExposedEntityCreateManyInput | ExposedEntityCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedEntity update
   */
  export type ExposedEntityUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExposedEntity.
     */
    data: XOR<ExposedEntityUpdateInput, ExposedEntityUncheckedUpdateInput>;
    /**
     * Choose, which ExposedEntity to update.
     */
    where: ExposedEntityWhereUniqueInput;
  };

  /**
   * ExposedEntity updateMany
   */
  export type ExposedEntityUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExposedEntities.
     */
    data: XOR<ExposedEntityUpdateManyMutationInput, ExposedEntityUncheckedUpdateManyInput>;
    /**
     * Filter which ExposedEntities to update
     */
    where?: ExposedEntityWhereInput;
    /**
     * Limit how many ExposedEntities to update.
     */
    limit?: number;
  };

  /**
   * ExposedEntity updateManyAndReturn
   */
  export type ExposedEntityUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * The data used to update ExposedEntities.
     */
    data: XOR<ExposedEntityUpdateManyMutationInput, ExposedEntityUncheckedUpdateManyInput>;
    /**
     * Filter which ExposedEntities to update
     */
    where?: ExposedEntityWhereInput;
    /**
     * Limit how many ExposedEntities to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedEntity upsert
   */
  export type ExposedEntityUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExposedEntity to update in case it exists.
     */
    where: ExposedEntityWhereUniqueInput;
    /**
     * In case the ExposedEntity found by the `where` argument doesn't exist, create a new ExposedEntity with this data.
     */
    create: XOR<ExposedEntityCreateInput, ExposedEntityUncheckedCreateInput>;
    /**
     * In case the ExposedEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExposedEntityUpdateInput, ExposedEntityUncheckedUpdateInput>;
  };

  /**
   * ExposedEntity delete
   */
  export type ExposedEntityDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
    /**
     * Filter which ExposedEntity to delete.
     */
    where: ExposedEntityWhereUniqueInput;
  };

  /**
   * ExposedEntity deleteMany
   */
  export type ExposedEntityDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedEntities to delete
     */
    where?: ExposedEntityWhereInput;
    /**
     * Limit how many ExposedEntities to delete.
     */
    limit?: number;
  };

  /**
   * ExposedEntity.creator
   */
  export type ExposedEntity$creatorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * ExposedEntity.fieldPolicies
   */
  export type ExposedEntity$fieldPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    where?: ExposedFieldPolicyWhereInput;
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedFieldPolicyScalarFieldEnum | ExposedFieldPolicyScalarFieldEnum[];
  };

  /**
   * ExposedEntity.rowPolicies
   */
  export type ExposedEntity$rowPoliciesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    where?: ExposedRowPolicyWhereInput;
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    cursor?: ExposedRowPolicyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExposedRowPolicyScalarFieldEnum | ExposedRowPolicyScalarFieldEnum[];
  };

  /**
   * ExposedEntity without action
   */
  export type ExposedEntityDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedEntity
     */
    select?: ExposedEntitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedEntity
     */
    omit?: ExposedEntityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedEntityInclude<ExtArgs> | null;
  };

  /**
   * Model ExposedFieldPolicy
   */

  export type AggregateExposedFieldPolicy = {
    _count: ExposedFieldPolicyCountAggregateOutputType | null;
    _min: ExposedFieldPolicyMinAggregateOutputType | null;
    _max: ExposedFieldPolicyMaxAggregateOutputType | null;
  };

  export type ExposedFieldPolicyMinAggregateOutputType = {
    id: string | null;
    exposedEntityId: string | null;
    roleId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExposedFieldPolicyMaxAggregateOutputType = {
    id: string | null;
    exposedEntityId: string | null;
    roleId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExposedFieldPolicyCountAggregateOutputType = {
    id: number;
    exposedEntityId: number;
    roleId: number;
    includeFields: number;
    excludeFields: number;
    writeProtected: number;
    maskedFields: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ExposedFieldPolicyMinAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExposedFieldPolicyMaxAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExposedFieldPolicyCountAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    includeFields?: true;
    excludeFields?: true;
    writeProtected?: true;
    maskedFields?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ExposedFieldPolicyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedFieldPolicy to aggregate.
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedFieldPolicies to fetch.
     */
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedFieldPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedFieldPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExposedFieldPolicies
     **/
    _count?: true | ExposedFieldPolicyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExposedFieldPolicyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExposedFieldPolicyMaxAggregateInputType;
  };

  export type GetExposedFieldPolicyAggregateType<T extends ExposedFieldPolicyAggregateArgs> = {
    [P in keyof T & keyof AggregateExposedFieldPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExposedFieldPolicy[P]>
      : GetScalarType<T[P], AggregateExposedFieldPolicy[P]>;
  };

  export type ExposedFieldPolicyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedFieldPolicyWhereInput;
    orderBy?:
      | ExposedFieldPolicyOrderByWithAggregationInput
      | ExposedFieldPolicyOrderByWithAggregationInput[];
    by: ExposedFieldPolicyScalarFieldEnum[] | ExposedFieldPolicyScalarFieldEnum;
    having?: ExposedFieldPolicyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExposedFieldPolicyCountAggregateInputType | true;
    _min?: ExposedFieldPolicyMinAggregateInputType;
    _max?: ExposedFieldPolicyMaxAggregateInputType;
  };

  export type ExposedFieldPolicyGroupByOutputType = {
    id: string;
    exposedEntityId: string;
    roleId: string | null;
    includeFields: string[];
    excludeFields: string[];
    writeProtected: string[];
    maskedFields: string[];
    createdAt: Date;
    updatedAt: Date;
    _count: ExposedFieldPolicyCountAggregateOutputType | null;
    _min: ExposedFieldPolicyMinAggregateOutputType | null;
    _max: ExposedFieldPolicyMaxAggregateOutputType | null;
  };

  type GetExposedFieldPolicyGroupByPayload<T extends ExposedFieldPolicyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExposedFieldPolicyGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ExposedFieldPolicyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExposedFieldPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ExposedFieldPolicyGroupByOutputType[P]>;
        }
      >
    >;

  export type ExposedFieldPolicySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      includeFields?: boolean;
      excludeFields?: boolean;
      writeProtected?: boolean;
      maskedFields?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedFieldPolicy']
  >;

  export type ExposedFieldPolicySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      includeFields?: boolean;
      excludeFields?: boolean;
      writeProtected?: boolean;
      maskedFields?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedFieldPolicy']
  >;

  export type ExposedFieldPolicySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      includeFields?: boolean;
      excludeFields?: boolean;
      writeProtected?: boolean;
      maskedFields?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedFieldPolicy']
  >;

  export type ExposedFieldPolicySelectScalar = {
    id?: boolean;
    exposedEntityId?: boolean;
    roleId?: boolean;
    includeFields?: boolean;
    excludeFields?: boolean;
    writeProtected?: boolean;
    maskedFields?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ExposedFieldPolicyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'exposedEntityId'
    | 'roleId'
    | 'includeFields'
    | 'excludeFields'
    | 'writeProtected'
    | 'maskedFields'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['exposedFieldPolicy']
  >;
  export type ExposedFieldPolicyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
  };
  export type ExposedFieldPolicyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
  };
  export type ExposedFieldPolicyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedFieldPolicy$roleArgs<ExtArgs>;
  };

  export type $ExposedFieldPolicyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ExposedFieldPolicy';
    objects: {
      exposedEntity: Prisma.$ExposedEntityPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        exposedEntityId: string;
        roleId: string | null;
        includeFields: string[];
        excludeFields: string[];
        writeProtected: string[];
        maskedFields: string[];
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['exposedFieldPolicy']
    >;
    composites: {};
  };

  type ExposedFieldPolicyGetPayload<
    S extends boolean | null | undefined | ExposedFieldPolicyDefaultArgs,
  > = $Result.GetResult<Prisma.$ExposedFieldPolicyPayload, S>;

  type ExposedFieldPolicyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ExposedFieldPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ExposedFieldPolicyCountAggregateInputType | true;
  };

  export interface ExposedFieldPolicyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ExposedFieldPolicy'];
      meta: { name: 'ExposedFieldPolicy' };
    };
    /**
     * Find zero or one ExposedFieldPolicy that matches the filter.
     * @param {ExposedFieldPolicyFindUniqueArgs} args - Arguments to find a ExposedFieldPolicy
     * @example
     * // Get one ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExposedFieldPolicyFindUniqueArgs>(
      args: SelectSubset<T, ExposedFieldPolicyFindUniqueArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExposedFieldPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExposedFieldPolicyFindUniqueOrThrowArgs} args - Arguments to find a ExposedFieldPolicy
     * @example
     * // Get one ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExposedFieldPolicyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExposedFieldPolicyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedFieldPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyFindFirstArgs} args - Arguments to find a ExposedFieldPolicy
     * @example
     * // Get one ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExposedFieldPolicyFindFirstArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyFindFirstArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedFieldPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyFindFirstOrThrowArgs} args - Arguments to find a ExposedFieldPolicy
     * @example
     * // Get one ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExposedFieldPolicyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExposedFieldPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExposedFieldPolicies
     * const exposedFieldPolicies = await prisma.exposedFieldPolicy.findMany()
     *
     * // Get first 10 ExposedFieldPolicies
     * const exposedFieldPolicies = await prisma.exposedFieldPolicy.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const exposedFieldPolicyWithIdOnly = await prisma.exposedFieldPolicy.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExposedFieldPolicyFindManyArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExposedFieldPolicy.
     * @param {ExposedFieldPolicyCreateArgs} args - Arguments to create a ExposedFieldPolicy.
     * @example
     * // Create one ExposedFieldPolicy
     * const ExposedFieldPolicy = await prisma.exposedFieldPolicy.create({
     *   data: {
     *     // ... data to create a ExposedFieldPolicy
     *   }
     * })
     *
     */
    create<T extends ExposedFieldPolicyCreateArgs>(
      args: SelectSubset<T, ExposedFieldPolicyCreateArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<Prisma.$ExposedFieldPolicyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExposedFieldPolicies.
     * @param {ExposedFieldPolicyCreateManyArgs} args - Arguments to create many ExposedFieldPolicies.
     * @example
     * // Create many ExposedFieldPolicies
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExposedFieldPolicyCreateManyArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExposedFieldPolicies and returns the data saved in the database.
     * @param {ExposedFieldPolicyCreateManyAndReturnArgs} args - Arguments to create many ExposedFieldPolicies.
     * @example
     * // Create many ExposedFieldPolicies
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExposedFieldPolicies and only return the `id`
     * const exposedFieldPolicyWithIdOnly = await prisma.exposedFieldPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExposedFieldPolicyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExposedFieldPolicy.
     * @param {ExposedFieldPolicyDeleteArgs} args - Arguments to delete one ExposedFieldPolicy.
     * @example
     * // Delete one ExposedFieldPolicy
     * const ExposedFieldPolicy = await prisma.exposedFieldPolicy.delete({
     *   where: {
     *     // ... filter to delete one ExposedFieldPolicy
     *   }
     * })
     *
     */
    delete<T extends ExposedFieldPolicyDeleteArgs>(
      args: SelectSubset<T, ExposedFieldPolicyDeleteArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<Prisma.$ExposedFieldPolicyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExposedFieldPolicy.
     * @param {ExposedFieldPolicyUpdateArgs} args - Arguments to update one ExposedFieldPolicy.
     * @example
     * // Update one ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExposedFieldPolicyUpdateArgs>(
      args: SelectSubset<T, ExposedFieldPolicyUpdateArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<Prisma.$ExposedFieldPolicyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExposedFieldPolicies.
     * @param {ExposedFieldPolicyDeleteManyArgs} args - Arguments to filter ExposedFieldPolicies to delete.
     * @example
     * // Delete a few ExposedFieldPolicies
     * const { count } = await prisma.exposedFieldPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExposedFieldPolicyDeleteManyArgs>(
      args?: SelectSubset<T, ExposedFieldPolicyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedFieldPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExposedFieldPolicies
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExposedFieldPolicyUpdateManyArgs>(
      args: SelectSubset<T, ExposedFieldPolicyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedFieldPolicies and returns the data updated in the database.
     * @param {ExposedFieldPolicyUpdateManyAndReturnArgs} args - Arguments to update many ExposedFieldPolicies.
     * @example
     * // Update many ExposedFieldPolicies
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExposedFieldPolicies and only return the `id`
     * const exposedFieldPolicyWithIdOnly = await prisma.exposedFieldPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExposedFieldPolicyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExposedFieldPolicyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedFieldPolicyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExposedFieldPolicy.
     * @param {ExposedFieldPolicyUpsertArgs} args - Arguments to update or create a ExposedFieldPolicy.
     * @example
     * // Update or create a ExposedFieldPolicy
     * const exposedFieldPolicy = await prisma.exposedFieldPolicy.upsert({
     *   create: {
     *     // ... data to create a ExposedFieldPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExposedFieldPolicy we want to update
     *   }
     * })
     */
    upsert<T extends ExposedFieldPolicyUpsertArgs>(
      args: SelectSubset<T, ExposedFieldPolicyUpsertArgs<ExtArgs>>
    ): Prisma__ExposedFieldPolicyClient<
      $Result.GetResult<Prisma.$ExposedFieldPolicyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExposedFieldPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyCountArgs} args - Arguments to filter ExposedFieldPolicies to count.
     * @example
     * // Count the number of ExposedFieldPolicies
     * const count = await prisma.exposedFieldPolicy.count({
     *   where: {
     *     // ... the filter for the ExposedFieldPolicies we want to count
     *   }
     * })
     **/
    count<T extends ExposedFieldPolicyCountArgs>(
      args?: Subset<T, ExposedFieldPolicyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExposedFieldPolicyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExposedFieldPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExposedFieldPolicyAggregateArgs>(
      args: Subset<T, ExposedFieldPolicyAggregateArgs>
    ): Prisma.PrismaPromise<GetExposedFieldPolicyAggregateType<T>>;

    /**
     * Group by ExposedFieldPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedFieldPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExposedFieldPolicyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExposedFieldPolicyGroupByArgs['orderBy'] }
        : { orderBy?: ExposedFieldPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExposedFieldPolicyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetExposedFieldPolicyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExposedFieldPolicy model
     */
    readonly fields: ExposedFieldPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExposedFieldPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExposedFieldPolicyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    exposedEntity<T extends ExposedEntityDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedEntityDefaultArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      | $Result.GetResult<
          Prisma.$ExposedEntityPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends ExposedFieldPolicy$roleArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedFieldPolicy$roleArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExposedFieldPolicy model
   */
  interface ExposedFieldPolicyFieldRefs {
    readonly id: FieldRef<'ExposedFieldPolicy', 'String'>;
    readonly exposedEntityId: FieldRef<'ExposedFieldPolicy', 'String'>;
    readonly roleId: FieldRef<'ExposedFieldPolicy', 'String'>;
    readonly includeFields: FieldRef<'ExposedFieldPolicy', 'String[]'>;
    readonly excludeFields: FieldRef<'ExposedFieldPolicy', 'String[]'>;
    readonly writeProtected: FieldRef<'ExposedFieldPolicy', 'String[]'>;
    readonly maskedFields: FieldRef<'ExposedFieldPolicy', 'String[]'>;
    readonly createdAt: FieldRef<'ExposedFieldPolicy', 'DateTime'>;
    readonly updatedAt: FieldRef<'ExposedFieldPolicy', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ExposedFieldPolicy findUnique
   */
  export type ExposedFieldPolicyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedFieldPolicy to fetch.
     */
    where: ExposedFieldPolicyWhereUniqueInput;
  };

  /**
   * ExposedFieldPolicy findUniqueOrThrow
   */
  export type ExposedFieldPolicyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedFieldPolicy to fetch.
     */
    where: ExposedFieldPolicyWhereUniqueInput;
  };

  /**
   * ExposedFieldPolicy findFirst
   */
  export type ExposedFieldPolicyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedFieldPolicy to fetch.
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedFieldPolicies to fetch.
     */
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedFieldPolicies.
     */
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedFieldPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedFieldPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedFieldPolicies.
     */
    distinct?: ExposedFieldPolicyScalarFieldEnum | ExposedFieldPolicyScalarFieldEnum[];
  };

  /**
   * ExposedFieldPolicy findFirstOrThrow
   */
  export type ExposedFieldPolicyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedFieldPolicy to fetch.
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedFieldPolicies to fetch.
     */
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedFieldPolicies.
     */
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedFieldPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedFieldPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedFieldPolicies.
     */
    distinct?: ExposedFieldPolicyScalarFieldEnum | ExposedFieldPolicyScalarFieldEnum[];
  };

  /**
   * ExposedFieldPolicy findMany
   */
  export type ExposedFieldPolicyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedFieldPolicies to fetch.
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedFieldPolicies to fetch.
     */
    orderBy?:
      | ExposedFieldPolicyOrderByWithRelationInput
      | ExposedFieldPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExposedFieldPolicies.
     */
    cursor?: ExposedFieldPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedFieldPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedFieldPolicies.
     */
    skip?: number;
    distinct?: ExposedFieldPolicyScalarFieldEnum | ExposedFieldPolicyScalarFieldEnum[];
  };

  /**
   * ExposedFieldPolicy create
   */
  export type ExposedFieldPolicyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExposedFieldPolicy.
     */
    data: XOR<ExposedFieldPolicyCreateInput, ExposedFieldPolicyUncheckedCreateInput>;
  };

  /**
   * ExposedFieldPolicy createMany
   */
  export type ExposedFieldPolicyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExposedFieldPolicies.
     */
    data: ExposedFieldPolicyCreateManyInput | ExposedFieldPolicyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ExposedFieldPolicy createManyAndReturn
   */
  export type ExposedFieldPolicyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * The data used to create many ExposedFieldPolicies.
     */
    data: ExposedFieldPolicyCreateManyInput | ExposedFieldPolicyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedFieldPolicy update
   */
  export type ExposedFieldPolicyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExposedFieldPolicy.
     */
    data: XOR<ExposedFieldPolicyUpdateInput, ExposedFieldPolicyUncheckedUpdateInput>;
    /**
     * Choose, which ExposedFieldPolicy to update.
     */
    where: ExposedFieldPolicyWhereUniqueInput;
  };

  /**
   * ExposedFieldPolicy updateMany
   */
  export type ExposedFieldPolicyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExposedFieldPolicies.
     */
    data: XOR<
      ExposedFieldPolicyUpdateManyMutationInput,
      ExposedFieldPolicyUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExposedFieldPolicies to update
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * Limit how many ExposedFieldPolicies to update.
     */
    limit?: number;
  };

  /**
   * ExposedFieldPolicy updateManyAndReturn
   */
  export type ExposedFieldPolicyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * The data used to update ExposedFieldPolicies.
     */
    data: XOR<
      ExposedFieldPolicyUpdateManyMutationInput,
      ExposedFieldPolicyUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExposedFieldPolicies to update
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * Limit how many ExposedFieldPolicies to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedFieldPolicy upsert
   */
  export type ExposedFieldPolicyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExposedFieldPolicy to update in case it exists.
     */
    where: ExposedFieldPolicyWhereUniqueInput;
    /**
     * In case the ExposedFieldPolicy found by the `where` argument doesn't exist, create a new ExposedFieldPolicy with this data.
     */
    create: XOR<ExposedFieldPolicyCreateInput, ExposedFieldPolicyUncheckedCreateInput>;
    /**
     * In case the ExposedFieldPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExposedFieldPolicyUpdateInput, ExposedFieldPolicyUncheckedUpdateInput>;
  };

  /**
   * ExposedFieldPolicy delete
   */
  export type ExposedFieldPolicyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
    /**
     * Filter which ExposedFieldPolicy to delete.
     */
    where: ExposedFieldPolicyWhereUniqueInput;
  };

  /**
   * ExposedFieldPolicy deleteMany
   */
  export type ExposedFieldPolicyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedFieldPolicies to delete
     */
    where?: ExposedFieldPolicyWhereInput;
    /**
     * Limit how many ExposedFieldPolicies to delete.
     */
    limit?: number;
  };

  /**
   * ExposedFieldPolicy.role
   */
  export type ExposedFieldPolicy$roleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
  };

  /**
   * ExposedFieldPolicy without action
   */
  export type ExposedFieldPolicyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedFieldPolicy
     */
    select?: ExposedFieldPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedFieldPolicy
     */
    omit?: ExposedFieldPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedFieldPolicyInclude<ExtArgs> | null;
  };

  /**
   * Model ExposedRowPolicy
   */

  export type AggregateExposedRowPolicy = {
    _count: ExposedRowPolicyCountAggregateOutputType | null;
    _min: ExposedRowPolicyMinAggregateOutputType | null;
    _max: ExposedRowPolicyMaxAggregateOutputType | null;
  };

  export type ExposedRowPolicyMinAggregateOutputType = {
    id: string | null;
    exposedEntityId: string | null;
    roleId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExposedRowPolicyMaxAggregateOutputType = {
    id: string | null;
    exposedEntityId: string | null;
    roleId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExposedRowPolicyCountAggregateOutputType = {
    id: number;
    exposedEntityId: number;
    roleId: number;
    filterTemplate: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ExposedRowPolicyMinAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExposedRowPolicyMaxAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExposedRowPolicyCountAggregateInputType = {
    id?: true;
    exposedEntityId?: true;
    roleId?: true;
    filterTemplate?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ExposedRowPolicyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedRowPolicy to aggregate.
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedRowPolicies to fetch.
     */
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExposedRowPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedRowPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedRowPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExposedRowPolicies
     **/
    _count?: true | ExposedRowPolicyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExposedRowPolicyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExposedRowPolicyMaxAggregateInputType;
  };

  export type GetExposedRowPolicyAggregateType<T extends ExposedRowPolicyAggregateArgs> = {
    [P in keyof T & keyof AggregateExposedRowPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExposedRowPolicy[P]>
      : GetScalarType<T[P], AggregateExposedRowPolicy[P]>;
  };

  export type ExposedRowPolicyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExposedRowPolicyWhereInput;
    orderBy?:
      | ExposedRowPolicyOrderByWithAggregationInput
      | ExposedRowPolicyOrderByWithAggregationInput[];
    by: ExposedRowPolicyScalarFieldEnum[] | ExposedRowPolicyScalarFieldEnum;
    having?: ExposedRowPolicyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExposedRowPolicyCountAggregateInputType | true;
    _min?: ExposedRowPolicyMinAggregateInputType;
    _max?: ExposedRowPolicyMaxAggregateInputType;
  };

  export type ExposedRowPolicyGroupByOutputType = {
    id: string;
    exposedEntityId: string;
    roleId: string | null;
    filterTemplate: JsonValue;
    createdAt: Date;
    updatedAt: Date;
    _count: ExposedRowPolicyCountAggregateOutputType | null;
    _min: ExposedRowPolicyMinAggregateOutputType | null;
    _max: ExposedRowPolicyMaxAggregateOutputType | null;
  };

  type GetExposedRowPolicyGroupByPayload<T extends ExposedRowPolicyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExposedRowPolicyGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ExposedRowPolicyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExposedRowPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ExposedRowPolicyGroupByOutputType[P]>;
        }
      >
    >;

  export type ExposedRowPolicySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      filterTemplate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedRowPolicy']
  >;

  export type ExposedRowPolicySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      filterTemplate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedRowPolicy']
  >;

  export type ExposedRowPolicySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      exposedEntityId?: boolean;
      roleId?: boolean;
      filterTemplate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
      role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
    },
    ExtArgs['result']['exposedRowPolicy']
  >;

  export type ExposedRowPolicySelectScalar = {
    id?: boolean;
    exposedEntityId?: boolean;
    roleId?: boolean;
    filterTemplate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ExposedRowPolicyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'exposedEntityId' | 'roleId' | 'filterTemplate' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['exposedRowPolicy']
  >;
  export type ExposedRowPolicyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
  };
  export type ExposedRowPolicyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
  };
  export type ExposedRowPolicyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exposedEntity?: boolean | ExposedEntityDefaultArgs<ExtArgs>;
    role?: boolean | ExposedRowPolicy$roleArgs<ExtArgs>;
  };

  export type $ExposedRowPolicyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ExposedRowPolicy';
    objects: {
      exposedEntity: Prisma.$ExposedEntityPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        exposedEntityId: string;
        roleId: string | null;
        filterTemplate: Prisma.JsonValue;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['exposedRowPolicy']
    >;
    composites: {};
  };

  type ExposedRowPolicyGetPayload<
    S extends boolean | null | undefined | ExposedRowPolicyDefaultArgs,
  > = $Result.GetResult<Prisma.$ExposedRowPolicyPayload, S>;

  type ExposedRowPolicyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ExposedRowPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ExposedRowPolicyCountAggregateInputType | true;
  };

  export interface ExposedRowPolicyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ExposedRowPolicy'];
      meta: { name: 'ExposedRowPolicy' };
    };
    /**
     * Find zero or one ExposedRowPolicy that matches the filter.
     * @param {ExposedRowPolicyFindUniqueArgs} args - Arguments to find a ExposedRowPolicy
     * @example
     * // Get one ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExposedRowPolicyFindUniqueArgs>(
      args: SelectSubset<T, ExposedRowPolicyFindUniqueArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExposedRowPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExposedRowPolicyFindUniqueOrThrowArgs} args - Arguments to find a ExposedRowPolicy
     * @example
     * // Get one ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExposedRowPolicyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExposedRowPolicyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedRowPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyFindFirstArgs} args - Arguments to find a ExposedRowPolicy
     * @example
     * // Get one ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExposedRowPolicyFindFirstArgs>(
      args?: SelectSubset<T, ExposedRowPolicyFindFirstArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExposedRowPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyFindFirstOrThrowArgs} args - Arguments to find a ExposedRowPolicy
     * @example
     * // Get one ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExposedRowPolicyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExposedRowPolicyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExposedRowPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExposedRowPolicies
     * const exposedRowPolicies = await prisma.exposedRowPolicy.findMany()
     *
     * // Get first 10 ExposedRowPolicies
     * const exposedRowPolicies = await prisma.exposedRowPolicy.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const exposedRowPolicyWithIdOnly = await prisma.exposedRowPolicy.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExposedRowPolicyFindManyArgs>(
      args?: SelectSubset<T, ExposedRowPolicyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ExposedRowPolicyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ExposedRowPolicy.
     * @param {ExposedRowPolicyCreateArgs} args - Arguments to create a ExposedRowPolicy.
     * @example
     * // Create one ExposedRowPolicy
     * const ExposedRowPolicy = await prisma.exposedRowPolicy.create({
     *   data: {
     *     // ... data to create a ExposedRowPolicy
     *   }
     * })
     *
     */
    create<T extends ExposedRowPolicyCreateArgs>(
      args: SelectSubset<T, ExposedRowPolicyCreateArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<Prisma.$ExposedRowPolicyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExposedRowPolicies.
     * @param {ExposedRowPolicyCreateManyArgs} args - Arguments to create many ExposedRowPolicies.
     * @example
     * // Create many ExposedRowPolicies
     * const exposedRowPolicy = await prisma.exposedRowPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExposedRowPolicyCreateManyArgs>(
      args?: SelectSubset<T, ExposedRowPolicyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExposedRowPolicies and returns the data saved in the database.
     * @param {ExposedRowPolicyCreateManyAndReturnArgs} args - Arguments to create many ExposedRowPolicies.
     * @example
     * // Create many ExposedRowPolicies
     * const exposedRowPolicy = await prisma.exposedRowPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExposedRowPolicies and only return the `id`
     * const exposedRowPolicyWithIdOnly = await prisma.exposedRowPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExposedRowPolicyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExposedRowPolicyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExposedRowPolicy.
     * @param {ExposedRowPolicyDeleteArgs} args - Arguments to delete one ExposedRowPolicy.
     * @example
     * // Delete one ExposedRowPolicy
     * const ExposedRowPolicy = await prisma.exposedRowPolicy.delete({
     *   where: {
     *     // ... filter to delete one ExposedRowPolicy
     *   }
     * })
     *
     */
    delete<T extends ExposedRowPolicyDeleteArgs>(
      args: SelectSubset<T, ExposedRowPolicyDeleteArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<Prisma.$ExposedRowPolicyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExposedRowPolicy.
     * @param {ExposedRowPolicyUpdateArgs} args - Arguments to update one ExposedRowPolicy.
     * @example
     * // Update one ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExposedRowPolicyUpdateArgs>(
      args: SelectSubset<T, ExposedRowPolicyUpdateArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<Prisma.$ExposedRowPolicyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExposedRowPolicies.
     * @param {ExposedRowPolicyDeleteManyArgs} args - Arguments to filter ExposedRowPolicies to delete.
     * @example
     * // Delete a few ExposedRowPolicies
     * const { count } = await prisma.exposedRowPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExposedRowPolicyDeleteManyArgs>(
      args?: SelectSubset<T, ExposedRowPolicyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedRowPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExposedRowPolicies
     * const exposedRowPolicy = await prisma.exposedRowPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExposedRowPolicyUpdateManyArgs>(
      args: SelectSubset<T, ExposedRowPolicyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExposedRowPolicies and returns the data updated in the database.
     * @param {ExposedRowPolicyUpdateManyAndReturnArgs} args - Arguments to update many ExposedRowPolicies.
     * @example
     * // Update many ExposedRowPolicies
     * const exposedRowPolicy = await prisma.exposedRowPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExposedRowPolicies and only return the `id`
     * const exposedRowPolicyWithIdOnly = await prisma.exposedRowPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExposedRowPolicyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExposedRowPolicyUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExposedRowPolicyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExposedRowPolicy.
     * @param {ExposedRowPolicyUpsertArgs} args - Arguments to update or create a ExposedRowPolicy.
     * @example
     * // Update or create a ExposedRowPolicy
     * const exposedRowPolicy = await prisma.exposedRowPolicy.upsert({
     *   create: {
     *     // ... data to create a ExposedRowPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExposedRowPolicy we want to update
     *   }
     * })
     */
    upsert<T extends ExposedRowPolicyUpsertArgs>(
      args: SelectSubset<T, ExposedRowPolicyUpsertArgs<ExtArgs>>
    ): Prisma__ExposedRowPolicyClient<
      $Result.GetResult<Prisma.$ExposedRowPolicyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExposedRowPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyCountArgs} args - Arguments to filter ExposedRowPolicies to count.
     * @example
     * // Count the number of ExposedRowPolicies
     * const count = await prisma.exposedRowPolicy.count({
     *   where: {
     *     // ... the filter for the ExposedRowPolicies we want to count
     *   }
     * })
     **/
    count<T extends ExposedRowPolicyCountArgs>(
      args?: Subset<T, ExposedRowPolicyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExposedRowPolicyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExposedRowPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExposedRowPolicyAggregateArgs>(
      args: Subset<T, ExposedRowPolicyAggregateArgs>
    ): Prisma.PrismaPromise<GetExposedRowPolicyAggregateType<T>>;

    /**
     * Group by ExposedRowPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExposedRowPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExposedRowPolicyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExposedRowPolicyGroupByArgs['orderBy'] }
        : { orderBy?: ExposedRowPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExposedRowPolicyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetExposedRowPolicyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExposedRowPolicy model
     */
    readonly fields: ExposedRowPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExposedRowPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExposedRowPolicyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    exposedEntity<T extends ExposedEntityDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedEntityDefaultArgs<ExtArgs>>
    ): Prisma__ExposedEntityClient<
      | $Result.GetResult<
          Prisma.$ExposedEntityPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends ExposedRowPolicy$roleArgs<ExtArgs> = {}>(
      args?: Subset<T, ExposedRowPolicy$roleArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<
        Prisma.$RolePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExposedRowPolicy model
   */
  interface ExposedRowPolicyFieldRefs {
    readonly id: FieldRef<'ExposedRowPolicy', 'String'>;
    readonly exposedEntityId: FieldRef<'ExposedRowPolicy', 'String'>;
    readonly roleId: FieldRef<'ExposedRowPolicy', 'String'>;
    readonly filterTemplate: FieldRef<'ExposedRowPolicy', 'Json'>;
    readonly createdAt: FieldRef<'ExposedRowPolicy', 'DateTime'>;
    readonly updatedAt: FieldRef<'ExposedRowPolicy', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ExposedRowPolicy findUnique
   */
  export type ExposedRowPolicyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedRowPolicy to fetch.
     */
    where: ExposedRowPolicyWhereUniqueInput;
  };

  /**
   * ExposedRowPolicy findUniqueOrThrow
   */
  export type ExposedRowPolicyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedRowPolicy to fetch.
     */
    where: ExposedRowPolicyWhereUniqueInput;
  };

  /**
   * ExposedRowPolicy findFirst
   */
  export type ExposedRowPolicyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedRowPolicy to fetch.
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedRowPolicies to fetch.
     */
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedRowPolicies.
     */
    cursor?: ExposedRowPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedRowPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedRowPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedRowPolicies.
     */
    distinct?: ExposedRowPolicyScalarFieldEnum | ExposedRowPolicyScalarFieldEnum[];
  };

  /**
   * ExposedRowPolicy findFirstOrThrow
   */
  export type ExposedRowPolicyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedRowPolicy to fetch.
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedRowPolicies to fetch.
     */
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExposedRowPolicies.
     */
    cursor?: ExposedRowPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedRowPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedRowPolicies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExposedRowPolicies.
     */
    distinct?: ExposedRowPolicyScalarFieldEnum | ExposedRowPolicyScalarFieldEnum[];
  };

  /**
   * ExposedRowPolicy findMany
   */
  export type ExposedRowPolicyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter, which ExposedRowPolicies to fetch.
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExposedRowPolicies to fetch.
     */
    orderBy?: ExposedRowPolicyOrderByWithRelationInput | ExposedRowPolicyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExposedRowPolicies.
     */
    cursor?: ExposedRowPolicyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExposedRowPolicies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExposedRowPolicies.
     */
    skip?: number;
    distinct?: ExposedRowPolicyScalarFieldEnum | ExposedRowPolicyScalarFieldEnum[];
  };

  /**
   * ExposedRowPolicy create
   */
  export type ExposedRowPolicyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExposedRowPolicy.
     */
    data: XOR<ExposedRowPolicyCreateInput, ExposedRowPolicyUncheckedCreateInput>;
  };

  /**
   * ExposedRowPolicy createMany
   */
  export type ExposedRowPolicyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExposedRowPolicies.
     */
    data: ExposedRowPolicyCreateManyInput | ExposedRowPolicyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ExposedRowPolicy createManyAndReturn
   */
  export type ExposedRowPolicyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * The data used to create many ExposedRowPolicies.
     */
    data: ExposedRowPolicyCreateManyInput | ExposedRowPolicyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedRowPolicy update
   */
  export type ExposedRowPolicyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExposedRowPolicy.
     */
    data: XOR<ExposedRowPolicyUpdateInput, ExposedRowPolicyUncheckedUpdateInput>;
    /**
     * Choose, which ExposedRowPolicy to update.
     */
    where: ExposedRowPolicyWhereUniqueInput;
  };

  /**
   * ExposedRowPolicy updateMany
   */
  export type ExposedRowPolicyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExposedRowPolicies.
     */
    data: XOR<ExposedRowPolicyUpdateManyMutationInput, ExposedRowPolicyUncheckedUpdateManyInput>;
    /**
     * Filter which ExposedRowPolicies to update
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * Limit how many ExposedRowPolicies to update.
     */
    limit?: number;
  };

  /**
   * ExposedRowPolicy updateManyAndReturn
   */
  export type ExposedRowPolicyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * The data used to update ExposedRowPolicies.
     */
    data: XOR<ExposedRowPolicyUpdateManyMutationInput, ExposedRowPolicyUncheckedUpdateManyInput>;
    /**
     * Filter which ExposedRowPolicies to update
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * Limit how many ExposedRowPolicies to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExposedRowPolicy upsert
   */
  export type ExposedRowPolicyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExposedRowPolicy to update in case it exists.
     */
    where: ExposedRowPolicyWhereUniqueInput;
    /**
     * In case the ExposedRowPolicy found by the `where` argument doesn't exist, create a new ExposedRowPolicy with this data.
     */
    create: XOR<ExposedRowPolicyCreateInput, ExposedRowPolicyUncheckedCreateInput>;
    /**
     * In case the ExposedRowPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExposedRowPolicyUpdateInput, ExposedRowPolicyUncheckedUpdateInput>;
  };

  /**
   * ExposedRowPolicy delete
   */
  export type ExposedRowPolicyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
    /**
     * Filter which ExposedRowPolicy to delete.
     */
    where: ExposedRowPolicyWhereUniqueInput;
  };

  /**
   * ExposedRowPolicy deleteMany
   */
  export type ExposedRowPolicyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExposedRowPolicies to delete
     */
    where?: ExposedRowPolicyWhereInput;
    /**
     * Limit how many ExposedRowPolicies to delete.
     */
    limit?: number;
  };

  /**
   * ExposedRowPolicy.role
   */
  export type ExposedRowPolicy$roleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
  };

  /**
   * ExposedRowPolicy without action
   */
  export type ExposedRowPolicyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExposedRowPolicy
     */
    select?: ExposedRowPolicySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExposedRowPolicy
     */
    omit?: ExposedRowPolicyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExposedRowPolicyInclude<ExtArgs> | null;
  };

  /**
   * Model TermsAndConditions
   */

  export type AggregateTermsAndConditions = {
    _count: TermsAndConditionsCountAggregateOutputType | null;
    _min: TermsAndConditionsMinAggregateOutputType | null;
    _max: TermsAndConditionsMaxAggregateOutputType | null;
  };

  export type TermsAndConditionsMinAggregateOutputType = {
    id: string | null;
    version: string | null;
    content: string | null;
    summary: string | null;
    effectiveDate: Date | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TermsAndConditionsMaxAggregateOutputType = {
    id: string | null;
    version: string | null;
    content: string | null;
    summary: string | null;
    effectiveDate: Date | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TermsAndConditionsCountAggregateOutputType = {
    id: number;
    version: number;
    content: number;
    summary: number;
    effectiveDate: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TermsAndConditionsMinAggregateInputType = {
    id?: true;
    version?: true;
    content?: true;
    summary?: true;
    effectiveDate?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TermsAndConditionsMaxAggregateInputType = {
    id?: true;
    version?: true;
    content?: true;
    summary?: true;
    effectiveDate?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TermsAndConditionsCountAggregateInputType = {
    id?: true;
    version?: true;
    content?: true;
    summary?: true;
    effectiveDate?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TermsAndConditionsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TermsAndConditions to aggregate.
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAndConditions to fetch.
     */
    orderBy?:
      | TermsAndConditionsOrderByWithRelationInput
      | TermsAndConditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermsAndConditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAndConditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAndConditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TermsAndConditions
     **/
    _count?: true | TermsAndConditionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TermsAndConditionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TermsAndConditionsMaxAggregateInputType;
  };

  export type GetTermsAndConditionsAggregateType<T extends TermsAndConditionsAggregateArgs> = {
    [P in keyof T & keyof AggregateTermsAndConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsAndConditions[P]>
      : GetScalarType<T[P], AggregateTermsAndConditions[P]>;
  };

  export type TermsAndConditionsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermsAndConditionsWhereInput;
    orderBy?:
      | TermsAndConditionsOrderByWithAggregationInput
      | TermsAndConditionsOrderByWithAggregationInput[];
    by: TermsAndConditionsScalarFieldEnum[] | TermsAndConditionsScalarFieldEnum;
    having?: TermsAndConditionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TermsAndConditionsCountAggregateInputType | true;
    _min?: TermsAndConditionsMinAggregateInputType;
    _max?: TermsAndConditionsMaxAggregateInputType;
  };

  export type TermsAndConditionsGroupByOutputType = {
    id: string;
    version: string;
    content: string;
    summary: string | null;
    effectiveDate: Date;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: TermsAndConditionsCountAggregateOutputType | null;
    _min: TermsAndConditionsMinAggregateOutputType | null;
    _max: TermsAndConditionsMaxAggregateOutputType | null;
  };

  type GetTermsAndConditionsGroupByPayload<T extends TermsAndConditionsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TermsAndConditionsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TermsAndConditionsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsAndConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], TermsAndConditionsGroupByOutputType[P]>;
        }
      >
    >;

  export type TermsAndConditionsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      content?: boolean;
      summary?: boolean;
      effectiveDate?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      acceptances?: boolean | TermsAndConditions$acceptancesArgs<ExtArgs>;
      _count?: boolean | TermsAndConditionsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['termsAndConditions']
  >;

  export type TermsAndConditionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      content?: boolean;
      summary?: boolean;
      effectiveDate?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['termsAndConditions']
  >;

  export type TermsAndConditionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      version?: boolean;
      content?: boolean;
      summary?: boolean;
      effectiveDate?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['termsAndConditions']
  >;

  export type TermsAndConditionsSelectScalar = {
    id?: boolean;
    version?: boolean;
    content?: boolean;
    summary?: boolean;
    effectiveDate?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TermsAndConditionsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'version'
    | 'content'
    | 'summary'
    | 'effectiveDate'
    | 'isActive'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['termsAndConditions']
  >;
  export type TermsAndConditionsInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acceptances?: boolean | TermsAndConditions$acceptancesArgs<ExtArgs>;
    _count?: boolean | TermsAndConditionsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TermsAndConditionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type TermsAndConditionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $TermsAndConditionsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TermsAndConditions';
    objects: {
      acceptances: Prisma.$TermsAcceptancePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        version: string;
        content: string;
        summary: string | null;
        effectiveDate: Date;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['termsAndConditions']
    >;
    composites: {};
  };

  type TermsAndConditionsGetPayload<
    S extends boolean | null | undefined | TermsAndConditionsDefaultArgs,
  > = $Result.GetResult<Prisma.$TermsAndConditionsPayload, S>;

  type TermsAndConditionsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TermsAndConditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TermsAndConditionsCountAggregateInputType | true;
  };

  export interface TermsAndConditionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TermsAndConditions'];
      meta: { name: 'TermsAndConditions' };
    };
    /**
     * Find zero or one TermsAndConditions that matches the filter.
     * @param {TermsAndConditionsFindUniqueArgs} args - Arguments to find a TermsAndConditions
     * @example
     * // Get one TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsAndConditionsFindUniqueArgs>(
      args: SelectSubset<T, TermsAndConditionsFindUniqueArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TermsAndConditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsAndConditionsFindUniqueOrThrowArgs} args - Arguments to find a TermsAndConditions
     * @example
     * // Get one TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsAndConditionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermsAndConditionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TermsAndConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsFindFirstArgs} args - Arguments to find a TermsAndConditions
     * @example
     * // Get one TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsAndConditionsFindFirstArgs>(
      args?: SelectSubset<T, TermsAndConditionsFindFirstArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TermsAndConditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsFindFirstOrThrowArgs} args - Arguments to find a TermsAndConditions
     * @example
     * // Get one TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsAndConditionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermsAndConditionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TermsAndConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findMany()
     *
     * // Get first 10 TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termsAndConditionsWithIdOnly = await prisma.termsAndConditions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermsAndConditionsFindManyArgs>(
      args?: SelectSubset<T, TermsAndConditionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TermsAndConditions.
     * @param {TermsAndConditionsCreateArgs} args - Arguments to create a TermsAndConditions.
     * @example
     * // Create one TermsAndConditions
     * const TermsAndConditions = await prisma.termsAndConditions.create({
     *   data: {
     *     // ... data to create a TermsAndConditions
     *   }
     * })
     *
     */
    create<T extends TermsAndConditionsCreateArgs>(
      args: SelectSubset<T, TermsAndConditionsCreateArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<Prisma.$TermsAndConditionsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TermsAndConditions.
     * @param {TermsAndConditionsCreateManyArgs} args - Arguments to create many TermsAndConditions.
     * @example
     * // Create many TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermsAndConditionsCreateManyArgs>(
      args?: SelectSubset<T, TermsAndConditionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TermsAndConditions and returns the data saved in the database.
     * @param {TermsAndConditionsCreateManyAndReturnArgs} args - Arguments to create many TermsAndConditions.
     * @example
     * // Create many TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TermsAndConditions and only return the `id`
     * const termsAndConditionsWithIdOnly = await prisma.termsAndConditions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermsAndConditionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermsAndConditionsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TermsAndConditions.
     * @param {TermsAndConditionsDeleteArgs} args - Arguments to delete one TermsAndConditions.
     * @example
     * // Delete one TermsAndConditions
     * const TermsAndConditions = await prisma.termsAndConditions.delete({
     *   where: {
     *     // ... filter to delete one TermsAndConditions
     *   }
     * })
     *
     */
    delete<T extends TermsAndConditionsDeleteArgs>(
      args: SelectSubset<T, TermsAndConditionsDeleteArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<Prisma.$TermsAndConditionsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TermsAndConditions.
     * @param {TermsAndConditionsUpdateArgs} args - Arguments to update one TermsAndConditions.
     * @example
     * // Update one TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermsAndConditionsUpdateArgs>(
      args: SelectSubset<T, TermsAndConditionsUpdateArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<Prisma.$TermsAndConditionsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TermsAndConditions.
     * @param {TermsAndConditionsDeleteManyArgs} args - Arguments to filter TermsAndConditions to delete.
     * @example
     * // Delete a few TermsAndConditions
     * const { count } = await prisma.termsAndConditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermsAndConditionsDeleteManyArgs>(
      args?: SelectSubset<T, TermsAndConditionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TermsAndConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermsAndConditionsUpdateManyArgs>(
      args: SelectSubset<T, TermsAndConditionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TermsAndConditions and returns the data updated in the database.
     * @param {TermsAndConditionsUpdateManyAndReturnArgs} args - Arguments to update many TermsAndConditions.
     * @example
     * // Update many TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TermsAndConditions and only return the `id`
     * const termsAndConditionsWithIdOnly = await prisma.termsAndConditions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermsAndConditionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermsAndConditionsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermsAndConditionsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TermsAndConditions.
     * @param {TermsAndConditionsUpsertArgs} args - Arguments to update or create a TermsAndConditions.
     * @example
     * // Update or create a TermsAndConditions
     * const termsAndConditions = await prisma.termsAndConditions.upsert({
     *   create: {
     *     // ... data to create a TermsAndConditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsAndConditions we want to update
     *   }
     * })
     */
    upsert<T extends TermsAndConditionsUpsertArgs>(
      args: SelectSubset<T, TermsAndConditionsUpsertArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      $Result.GetResult<Prisma.$TermsAndConditionsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TermsAndConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsCountArgs} args - Arguments to filter TermsAndConditions to count.
     * @example
     * // Count the number of TermsAndConditions
     * const count = await prisma.termsAndConditions.count({
     *   where: {
     *     // ... the filter for the TermsAndConditions we want to count
     *   }
     * })
     **/
    count<T extends TermsAndConditionsCountArgs>(
      args?: Subset<T, TermsAndConditionsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsAndConditionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TermsAndConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TermsAndConditionsAggregateArgs>(
      args: Subset<T, TermsAndConditionsAggregateArgs>
    ): Prisma.PrismaPromise<GetTermsAndConditionsAggregateType<T>>;

    /**
     * Group by TermsAndConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAndConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TermsAndConditionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsAndConditionsGroupByArgs['orderBy'] }
        : { orderBy?: TermsAndConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TermsAndConditionsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTermsAndConditionsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TermsAndConditions model
     */
    readonly fields: TermsAndConditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsAndConditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsAndConditionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    acceptances<T extends TermsAndConditions$acceptancesArgs<ExtArgs> = {}>(
      args?: Subset<T, TermsAndConditions$acceptancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TermsAndConditions model
   */
  interface TermsAndConditionsFieldRefs {
    readonly id: FieldRef<'TermsAndConditions', 'String'>;
    readonly version: FieldRef<'TermsAndConditions', 'String'>;
    readonly content: FieldRef<'TermsAndConditions', 'String'>;
    readonly summary: FieldRef<'TermsAndConditions', 'String'>;
    readonly effectiveDate: FieldRef<'TermsAndConditions', 'DateTime'>;
    readonly isActive: FieldRef<'TermsAndConditions', 'Boolean'>;
    readonly createdAt: FieldRef<'TermsAndConditions', 'DateTime'>;
    readonly updatedAt: FieldRef<'TermsAndConditions', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TermsAndConditions findUnique
   */
  export type TermsAndConditionsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAndConditions to fetch.
     */
    where: TermsAndConditionsWhereUniqueInput;
  };

  /**
   * TermsAndConditions findUniqueOrThrow
   */
  export type TermsAndConditionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAndConditions to fetch.
     */
    where: TermsAndConditionsWhereUniqueInput;
  };

  /**
   * TermsAndConditions findFirst
   */
  export type TermsAndConditionsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAndConditions to fetch.
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAndConditions to fetch.
     */
    orderBy?:
      | TermsAndConditionsOrderByWithRelationInput
      | TermsAndConditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermsAndConditions.
     */
    cursor?: TermsAndConditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAndConditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAndConditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermsAndConditions.
     */
    distinct?: TermsAndConditionsScalarFieldEnum | TermsAndConditionsScalarFieldEnum[];
  };

  /**
   * TermsAndConditions findFirstOrThrow
   */
  export type TermsAndConditionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAndConditions to fetch.
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAndConditions to fetch.
     */
    orderBy?:
      | TermsAndConditionsOrderByWithRelationInput
      | TermsAndConditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermsAndConditions.
     */
    cursor?: TermsAndConditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAndConditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAndConditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermsAndConditions.
     */
    distinct?: TermsAndConditionsScalarFieldEnum | TermsAndConditionsScalarFieldEnum[];
  };

  /**
   * TermsAndConditions findMany
   */
  export type TermsAndConditionsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAndConditions to fetch.
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAndConditions to fetch.
     */
    orderBy?:
      | TermsAndConditionsOrderByWithRelationInput
      | TermsAndConditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TermsAndConditions.
     */
    cursor?: TermsAndConditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAndConditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAndConditions.
     */
    skip?: number;
    distinct?: TermsAndConditionsScalarFieldEnum | TermsAndConditionsScalarFieldEnum[];
  };

  /**
   * TermsAndConditions create
   */
  export type TermsAndConditionsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a TermsAndConditions.
     */
    data: XOR<TermsAndConditionsCreateInput, TermsAndConditionsUncheckedCreateInput>;
  };

  /**
   * TermsAndConditions createMany
   */
  export type TermsAndConditionsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TermsAndConditions.
     */
    data: TermsAndConditionsCreateManyInput | TermsAndConditionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TermsAndConditions createManyAndReturn
   */
  export type TermsAndConditionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * The data used to create many TermsAndConditions.
     */
    data: TermsAndConditionsCreateManyInput | TermsAndConditionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TermsAndConditions update
   */
  export type TermsAndConditionsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a TermsAndConditions.
     */
    data: XOR<TermsAndConditionsUpdateInput, TermsAndConditionsUncheckedUpdateInput>;
    /**
     * Choose, which TermsAndConditions to update.
     */
    where: TermsAndConditionsWhereUniqueInput;
  };

  /**
   * TermsAndConditions updateMany
   */
  export type TermsAndConditionsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TermsAndConditions.
     */
    data: XOR<
      TermsAndConditionsUpdateManyMutationInput,
      TermsAndConditionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which TermsAndConditions to update
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * Limit how many TermsAndConditions to update.
     */
    limit?: number;
  };

  /**
   * TermsAndConditions updateManyAndReturn
   */
  export type TermsAndConditionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * The data used to update TermsAndConditions.
     */
    data: XOR<
      TermsAndConditionsUpdateManyMutationInput,
      TermsAndConditionsUncheckedUpdateManyInput
    >;
    /**
     * Filter which TermsAndConditions to update
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * Limit how many TermsAndConditions to update.
     */
    limit?: number;
  };

  /**
   * TermsAndConditions upsert
   */
  export type TermsAndConditionsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the TermsAndConditions to update in case it exists.
     */
    where: TermsAndConditionsWhereUniqueInput;
    /**
     * In case the TermsAndConditions found by the `where` argument doesn't exist, create a new TermsAndConditions with this data.
     */
    create: XOR<TermsAndConditionsCreateInput, TermsAndConditionsUncheckedCreateInput>;
    /**
     * In case the TermsAndConditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsAndConditionsUpdateInput, TermsAndConditionsUncheckedUpdateInput>;
  };

  /**
   * TermsAndConditions delete
   */
  export type TermsAndConditionsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
    /**
     * Filter which TermsAndConditions to delete.
     */
    where: TermsAndConditionsWhereUniqueInput;
  };

  /**
   * TermsAndConditions deleteMany
   */
  export type TermsAndConditionsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TermsAndConditions to delete
     */
    where?: TermsAndConditionsWhereInput;
    /**
     * Limit how many TermsAndConditions to delete.
     */
    limit?: number;
  };

  /**
   * TermsAndConditions.acceptances
   */
  export type TermsAndConditions$acceptancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    where?: TermsAcceptanceWhereInput;
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    cursor?: TermsAcceptanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * TermsAndConditions without action
   */
  export type TermsAndConditionsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAndConditions
     */
    select?: TermsAndConditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAndConditions
     */
    omit?: TermsAndConditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAndConditionsInclude<ExtArgs> | null;
  };

  /**
   * Model TermsAcceptance
   */

  export type AggregateTermsAcceptance = {
    _count: TermsAcceptanceCountAggregateOutputType | null;
    _min: TermsAcceptanceMinAggregateOutputType | null;
    _max: TermsAcceptanceMaxAggregateOutputType | null;
  };

  export type TermsAcceptanceMinAggregateOutputType = {
    id: string | null;
    acceptedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    acceptanceMethod: $Enums.AcceptanceMethod | null;
    organizationId: string | null;
    userId: string | null;
    termsId: string | null;
  };

  export type TermsAcceptanceMaxAggregateOutputType = {
    id: string | null;
    acceptedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    acceptanceMethod: $Enums.AcceptanceMethod | null;
    organizationId: string | null;
    userId: string | null;
    termsId: string | null;
  };

  export type TermsAcceptanceCountAggregateOutputType = {
    id: number;
    acceptedAt: number;
    ipAddress: number;
    userAgent: number;
    geolocation: number;
    acceptanceMethod: number;
    organizationId: number;
    userId: number;
    termsId: number;
    _all: number;
  };

  export type TermsAcceptanceMinAggregateInputType = {
    id?: true;
    acceptedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    acceptanceMethod?: true;
    organizationId?: true;
    userId?: true;
    termsId?: true;
  };

  export type TermsAcceptanceMaxAggregateInputType = {
    id?: true;
    acceptedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    acceptanceMethod?: true;
    organizationId?: true;
    userId?: true;
    termsId?: true;
  };

  export type TermsAcceptanceCountAggregateInputType = {
    id?: true;
    acceptedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    geolocation?: true;
    acceptanceMethod?: true;
    organizationId?: true;
    userId?: true;
    termsId?: true;
    _all?: true;
  };

  export type TermsAcceptanceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TermsAcceptance to aggregate.
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAcceptances to fetch.
     */
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermsAcceptanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAcceptances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAcceptances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TermsAcceptances
     **/
    _count?: true | TermsAcceptanceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TermsAcceptanceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TermsAcceptanceMaxAggregateInputType;
  };

  export type GetTermsAcceptanceAggregateType<T extends TermsAcceptanceAggregateArgs> = {
    [P in keyof T & keyof AggregateTermsAcceptance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsAcceptance[P]>
      : GetScalarType<T[P], AggregateTermsAcceptance[P]>;
  };

  export type TermsAcceptanceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermsAcceptanceWhereInput;
    orderBy?:
      | TermsAcceptanceOrderByWithAggregationInput
      | TermsAcceptanceOrderByWithAggregationInput[];
    by: TermsAcceptanceScalarFieldEnum[] | TermsAcceptanceScalarFieldEnum;
    having?: TermsAcceptanceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TermsAcceptanceCountAggregateInputType | true;
    _min?: TermsAcceptanceMinAggregateInputType;
    _max?: TermsAcceptanceMaxAggregateInputType;
  };

  export type TermsAcceptanceGroupByOutputType = {
    id: string;
    acceptedAt: Date;
    ipAddress: string;
    userAgent: string | null;
    geolocation: JsonValue | null;
    acceptanceMethod: $Enums.AcceptanceMethod;
    organizationId: string;
    userId: string;
    termsId: string;
    _count: TermsAcceptanceCountAggregateOutputType | null;
    _min: TermsAcceptanceMinAggregateOutputType | null;
    _max: TermsAcceptanceMaxAggregateOutputType | null;
  };

  type GetTermsAcceptanceGroupByPayload<T extends TermsAcceptanceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TermsAcceptanceGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TermsAcceptanceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsAcceptanceGroupByOutputType[P]>
            : GetScalarType<T[P], TermsAcceptanceGroupByOutputType[P]>;
        }
      >
    >;

  export type TermsAcceptanceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      acceptedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      geolocation?: boolean;
      acceptanceMethod?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      termsId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['termsAcceptance']
  >;

  export type TermsAcceptanceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      acceptedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      geolocation?: boolean;
      acceptanceMethod?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      termsId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['termsAcceptance']
  >;

  export type TermsAcceptanceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      acceptedAt?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      geolocation?: boolean;
      acceptanceMethod?: boolean;
      organizationId?: boolean;
      userId?: boolean;
      termsId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['termsAcceptance']
  >;

  export type TermsAcceptanceSelectScalar = {
    id?: boolean;
    acceptedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    geolocation?: boolean;
    acceptanceMethod?: boolean;
    organizationId?: boolean;
    userId?: boolean;
    termsId?: boolean;
  };

  export type TermsAcceptanceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'acceptedAt'
    | 'ipAddress'
    | 'userAgent'
    | 'geolocation'
    | 'acceptanceMethod'
    | 'organizationId'
    | 'userId'
    | 'termsId',
    ExtArgs['result']['termsAcceptance']
  >;
  export type TermsAcceptanceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TermsAcceptanceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TermsAcceptanceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    terms?: boolean | TermsAndConditionsDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TermsAcceptancePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TermsAcceptance';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      terms: Prisma.$TermsAndConditionsPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        acceptedAt: Date;
        ipAddress: string;
        userAgent: string | null;
        geolocation: Prisma.JsonValue | null;
        acceptanceMethod: $Enums.AcceptanceMethod;
        organizationId: string;
        userId: string;
        termsId: string;
      },
      ExtArgs['result']['termsAcceptance']
    >;
    composites: {};
  };

  type TermsAcceptanceGetPayload<
    S extends boolean | null | undefined | TermsAcceptanceDefaultArgs,
  > = $Result.GetResult<Prisma.$TermsAcceptancePayload, S>;

  type TermsAcceptanceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TermsAcceptanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TermsAcceptanceCountAggregateInputType | true;
  };

  export interface TermsAcceptanceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TermsAcceptance'];
      meta: { name: 'TermsAcceptance' };
    };
    /**
     * Find zero or one TermsAcceptance that matches the filter.
     * @param {TermsAcceptanceFindUniqueArgs} args - Arguments to find a TermsAcceptance
     * @example
     * // Get one TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsAcceptanceFindUniqueArgs>(
      args: SelectSubset<T, TermsAcceptanceFindUniqueArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TermsAcceptance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsAcceptanceFindUniqueOrThrowArgs} args - Arguments to find a TermsAcceptance
     * @example
     * // Get one TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsAcceptanceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermsAcceptanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TermsAcceptance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceFindFirstArgs} args - Arguments to find a TermsAcceptance
     * @example
     * // Get one TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsAcceptanceFindFirstArgs>(
      args?: SelectSubset<T, TermsAcceptanceFindFirstArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TermsAcceptance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceFindFirstOrThrowArgs} args - Arguments to find a TermsAcceptance
     * @example
     * // Get one TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsAcceptanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermsAcceptanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TermsAcceptances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsAcceptances
     * const termsAcceptances = await prisma.termsAcceptance.findMany()
     *
     * // Get first 10 TermsAcceptances
     * const termsAcceptances = await prisma.termsAcceptance.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termsAcceptanceWithIdOnly = await prisma.termsAcceptance.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermsAcceptanceFindManyArgs>(
      args?: SelectSubset<T, TermsAcceptanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a TermsAcceptance.
     * @param {TermsAcceptanceCreateArgs} args - Arguments to create a TermsAcceptance.
     * @example
     * // Create one TermsAcceptance
     * const TermsAcceptance = await prisma.termsAcceptance.create({
     *   data: {
     *     // ... data to create a TermsAcceptance
     *   }
     * })
     *
     */
    create<T extends TermsAcceptanceCreateArgs>(
      args: SelectSubset<T, TermsAcceptanceCreateArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TermsAcceptances.
     * @param {TermsAcceptanceCreateManyArgs} args - Arguments to create many TermsAcceptances.
     * @example
     * // Create many TermsAcceptances
     * const termsAcceptance = await prisma.termsAcceptance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermsAcceptanceCreateManyArgs>(
      args?: SelectSubset<T, TermsAcceptanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TermsAcceptances and returns the data saved in the database.
     * @param {TermsAcceptanceCreateManyAndReturnArgs} args - Arguments to create many TermsAcceptances.
     * @example
     * // Create many TermsAcceptances
     * const termsAcceptance = await prisma.termsAcceptance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TermsAcceptances and only return the `id`
     * const termsAcceptanceWithIdOnly = await prisma.termsAcceptance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermsAcceptanceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermsAcceptanceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a TermsAcceptance.
     * @param {TermsAcceptanceDeleteArgs} args - Arguments to delete one TermsAcceptance.
     * @example
     * // Delete one TermsAcceptance
     * const TermsAcceptance = await prisma.termsAcceptance.delete({
     *   where: {
     *     // ... filter to delete one TermsAcceptance
     *   }
     * })
     *
     */
    delete<T extends TermsAcceptanceDeleteArgs>(
      args: SelectSubset<T, TermsAcceptanceDeleteArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TermsAcceptance.
     * @param {TermsAcceptanceUpdateArgs} args - Arguments to update one TermsAcceptance.
     * @example
     * // Update one TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermsAcceptanceUpdateArgs>(
      args: SelectSubset<T, TermsAcceptanceUpdateArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TermsAcceptances.
     * @param {TermsAcceptanceDeleteManyArgs} args - Arguments to filter TermsAcceptances to delete.
     * @example
     * // Delete a few TermsAcceptances
     * const { count } = await prisma.termsAcceptance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermsAcceptanceDeleteManyArgs>(
      args?: SelectSubset<T, TermsAcceptanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TermsAcceptances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsAcceptances
     * const termsAcceptance = await prisma.termsAcceptance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermsAcceptanceUpdateManyArgs>(
      args: SelectSubset<T, TermsAcceptanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TermsAcceptances and returns the data updated in the database.
     * @param {TermsAcceptanceUpdateManyAndReturnArgs} args - Arguments to update many TermsAcceptances.
     * @example
     * // Update many TermsAcceptances
     * const termsAcceptance = await prisma.termsAcceptance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TermsAcceptances and only return the `id`
     * const termsAcceptanceWithIdOnly = await prisma.termsAcceptance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermsAcceptanceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermsAcceptanceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermsAcceptancePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one TermsAcceptance.
     * @param {TermsAcceptanceUpsertArgs} args - Arguments to update or create a TermsAcceptance.
     * @example
     * // Update or create a TermsAcceptance
     * const termsAcceptance = await prisma.termsAcceptance.upsert({
     *   create: {
     *     // ... data to create a TermsAcceptance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsAcceptance we want to update
     *   }
     * })
     */
    upsert<T extends TermsAcceptanceUpsertArgs>(
      args: SelectSubset<T, TermsAcceptanceUpsertArgs<ExtArgs>>
    ): Prisma__TermsAcceptanceClient<
      $Result.GetResult<Prisma.$TermsAcceptancePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TermsAcceptances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceCountArgs} args - Arguments to filter TermsAcceptances to count.
     * @example
     * // Count the number of TermsAcceptances
     * const count = await prisma.termsAcceptance.count({
     *   where: {
     *     // ... the filter for the TermsAcceptances we want to count
     *   }
     * })
     **/
    count<T extends TermsAcceptanceCountArgs>(
      args?: Subset<T, TermsAcceptanceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsAcceptanceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TermsAcceptance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TermsAcceptanceAggregateArgs>(
      args: Subset<T, TermsAcceptanceAggregateArgs>
    ): Prisma.PrismaPromise<GetTermsAcceptanceAggregateType<T>>;

    /**
     * Group by TermsAcceptance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAcceptanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TermsAcceptanceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsAcceptanceGroupByArgs['orderBy'] }
        : { orderBy?: TermsAcceptanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TermsAcceptanceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTermsAcceptanceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TermsAcceptance model
     */
    readonly fields: TermsAcceptanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsAcceptance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsAcceptanceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    terms<T extends TermsAndConditionsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TermsAndConditionsDefaultArgs<ExtArgs>>
    ): Prisma__TermsAndConditionsClient<
      | $Result.GetResult<
          Prisma.$TermsAndConditionsPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TermsAcceptance model
   */
  interface TermsAcceptanceFieldRefs {
    readonly id: FieldRef<'TermsAcceptance', 'String'>;
    readonly acceptedAt: FieldRef<'TermsAcceptance', 'DateTime'>;
    readonly ipAddress: FieldRef<'TermsAcceptance', 'String'>;
    readonly userAgent: FieldRef<'TermsAcceptance', 'String'>;
    readonly geolocation: FieldRef<'TermsAcceptance', 'Json'>;
    readonly acceptanceMethod: FieldRef<'TermsAcceptance', 'AcceptanceMethod'>;
    readonly organizationId: FieldRef<'TermsAcceptance', 'String'>;
    readonly userId: FieldRef<'TermsAcceptance', 'String'>;
    readonly termsId: FieldRef<'TermsAcceptance', 'String'>;
  }

  // Custom InputTypes
  /**
   * TermsAcceptance findUnique
   */
  export type TermsAcceptanceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAcceptance to fetch.
     */
    where: TermsAcceptanceWhereUniqueInput;
  };

  /**
   * TermsAcceptance findUniqueOrThrow
   */
  export type TermsAcceptanceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAcceptance to fetch.
     */
    where: TermsAcceptanceWhereUniqueInput;
  };

  /**
   * TermsAcceptance findFirst
   */
  export type TermsAcceptanceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAcceptance to fetch.
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAcceptances to fetch.
     */
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermsAcceptances.
     */
    cursor?: TermsAcceptanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAcceptances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAcceptances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermsAcceptances.
     */
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * TermsAcceptance findFirstOrThrow
   */
  export type TermsAcceptanceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAcceptance to fetch.
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAcceptances to fetch.
     */
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TermsAcceptances.
     */
    cursor?: TermsAcceptanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAcceptances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAcceptances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TermsAcceptances.
     */
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * TermsAcceptance findMany
   */
  export type TermsAcceptanceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter, which TermsAcceptances to fetch.
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TermsAcceptances to fetch.
     */
    orderBy?: TermsAcceptanceOrderByWithRelationInput | TermsAcceptanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TermsAcceptances.
     */
    cursor?: TermsAcceptanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TermsAcceptances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TermsAcceptances.
     */
    skip?: number;
    distinct?: TermsAcceptanceScalarFieldEnum | TermsAcceptanceScalarFieldEnum[];
  };

  /**
   * TermsAcceptance create
   */
  export type TermsAcceptanceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * The data needed to create a TermsAcceptance.
     */
    data: XOR<TermsAcceptanceCreateInput, TermsAcceptanceUncheckedCreateInput>;
  };

  /**
   * TermsAcceptance createMany
   */
  export type TermsAcceptanceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TermsAcceptances.
     */
    data: TermsAcceptanceCreateManyInput | TermsAcceptanceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TermsAcceptance createManyAndReturn
   */
  export type TermsAcceptanceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * The data used to create many TermsAcceptances.
     */
    data: TermsAcceptanceCreateManyInput | TermsAcceptanceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TermsAcceptance update
   */
  export type TermsAcceptanceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * The data needed to update a TermsAcceptance.
     */
    data: XOR<TermsAcceptanceUpdateInput, TermsAcceptanceUncheckedUpdateInput>;
    /**
     * Choose, which TermsAcceptance to update.
     */
    where: TermsAcceptanceWhereUniqueInput;
  };

  /**
   * TermsAcceptance updateMany
   */
  export type TermsAcceptanceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TermsAcceptances.
     */
    data: XOR<TermsAcceptanceUpdateManyMutationInput, TermsAcceptanceUncheckedUpdateManyInput>;
    /**
     * Filter which TermsAcceptances to update
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * Limit how many TermsAcceptances to update.
     */
    limit?: number;
  };

  /**
   * TermsAcceptance updateManyAndReturn
   */
  export type TermsAcceptanceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * The data used to update TermsAcceptances.
     */
    data: XOR<TermsAcceptanceUpdateManyMutationInput, TermsAcceptanceUncheckedUpdateManyInput>;
    /**
     * Filter which TermsAcceptances to update
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * Limit how many TermsAcceptances to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TermsAcceptance upsert
   */
  export type TermsAcceptanceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * The filter to search for the TermsAcceptance to update in case it exists.
     */
    where: TermsAcceptanceWhereUniqueInput;
    /**
     * In case the TermsAcceptance found by the `where` argument doesn't exist, create a new TermsAcceptance with this data.
     */
    create: XOR<TermsAcceptanceCreateInput, TermsAcceptanceUncheckedCreateInput>;
    /**
     * In case the TermsAcceptance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsAcceptanceUpdateInput, TermsAcceptanceUncheckedUpdateInput>;
  };

  /**
   * TermsAcceptance delete
   */
  export type TermsAcceptanceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
    /**
     * Filter which TermsAcceptance to delete.
     */
    where: TermsAcceptanceWhereUniqueInput;
  };

  /**
   * TermsAcceptance deleteMany
   */
  export type TermsAcceptanceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TermsAcceptances to delete
     */
    where?: TermsAcceptanceWhereInput;
    /**
     * Limit how many TermsAcceptances to delete.
     */
    limit?: number;
  };

  /**
   * TermsAcceptance without action
   */
  export type TermsAcceptanceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermsAcceptance
     */
    select?: TermsAcceptanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TermsAcceptance
     */
    omit?: TermsAcceptanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermsAcceptanceInclude<ExtArgs> | null;
  };

  /**
   * Model RateLimitConfig
   */

  export type AggregateRateLimitConfig = {
    _count: RateLimitConfigCountAggregateOutputType | null;
    _avg: RateLimitConfigAvgAggregateOutputType | null;
    _sum: RateLimitConfigSumAggregateOutputType | null;
    _min: RateLimitConfigMinAggregateOutputType | null;
    _max: RateLimitConfigMaxAggregateOutputType | null;
  };

  export type RateLimitConfigAvgAggregateOutputType = {
    max: number | null;
    windowMs: number | null;
  };

  export type RateLimitConfigSumAggregateOutputType = {
    max: number | null;
    windowMs: number | null;
  };

  export type RateLimitConfigMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    displayName: string | null;
    type: $Enums.RateLimitType | null;
    max: number | null;
    windowMs: number | null;
    keyStrategy: $Enums.RateLimitKeyStrategy | null;
    enabled: boolean | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    changeReason: string | null;
    organizationId: string | null;
    createdBy: string | null;
    updatedBy: string | null;
  };

  export type RateLimitConfigMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    displayName: string | null;
    type: $Enums.RateLimitType | null;
    max: number | null;
    windowMs: number | null;
    keyStrategy: $Enums.RateLimitKeyStrategy | null;
    enabled: boolean | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    changeReason: string | null;
    organizationId: string | null;
    createdBy: string | null;
    updatedBy: string | null;
  };

  export type RateLimitConfigCountAggregateOutputType = {
    id: number;
    name: number;
    displayName: number;
    type: number;
    max: number;
    windowMs: number;
    keyStrategy: number;
    enabled: number;
    description: number;
    createdAt: number;
    updatedAt: number;
    applicationLimits: number;
    roleLimits: number;
    componentLimits: number;
    changeHistory: number;
    changeReason: number;
    organizationId: number;
    createdBy: number;
    updatedBy: number;
    _all: number;
  };

  export type RateLimitConfigAvgAggregateInputType = {
    max?: true;
    windowMs?: true;
  };

  export type RateLimitConfigSumAggregateInputType = {
    max?: true;
    windowMs?: true;
  };

  export type RateLimitConfigMinAggregateInputType = {
    id?: true;
    name?: true;
    displayName?: true;
    type?: true;
    max?: true;
    windowMs?: true;
    keyStrategy?: true;
    enabled?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    changeReason?: true;
    organizationId?: true;
    createdBy?: true;
    updatedBy?: true;
  };

  export type RateLimitConfigMaxAggregateInputType = {
    id?: true;
    name?: true;
    displayName?: true;
    type?: true;
    max?: true;
    windowMs?: true;
    keyStrategy?: true;
    enabled?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    changeReason?: true;
    organizationId?: true;
    createdBy?: true;
    updatedBy?: true;
  };

  export type RateLimitConfigCountAggregateInputType = {
    id?: true;
    name?: true;
    displayName?: true;
    type?: true;
    max?: true;
    windowMs?: true;
    keyStrategy?: true;
    enabled?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    applicationLimits?: true;
    roleLimits?: true;
    componentLimits?: true;
    changeHistory?: true;
    changeReason?: true;
    organizationId?: true;
    createdBy?: true;
    updatedBy?: true;
    _all?: true;
  };

  export type RateLimitConfigAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitConfig to aggregate.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RateLimitConfigs
     **/
    _count?: true | RateLimitConfigCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RateLimitConfigAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RateLimitConfigSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RateLimitConfigMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RateLimitConfigMaxAggregateInputType;
  };

  export type GetRateLimitConfigAggregateType<T extends RateLimitConfigAggregateArgs> = {
    [P in keyof T & keyof AggregateRateLimitConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimitConfig[P]>
      : GetScalarType<T[P], AggregateRateLimitConfig[P]>;
  };

  export type RateLimitConfigGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitConfigWhereInput;
    orderBy?:
      | RateLimitConfigOrderByWithAggregationInput
      | RateLimitConfigOrderByWithAggregationInput[];
    by: RateLimitConfigScalarFieldEnum[] | RateLimitConfigScalarFieldEnum;
    having?: RateLimitConfigScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RateLimitConfigCountAggregateInputType | true;
    _avg?: RateLimitConfigAvgAggregateInputType;
    _sum?: RateLimitConfigSumAggregateInputType;
    _min?: RateLimitConfigMinAggregateInputType;
    _max?: RateLimitConfigMaxAggregateInputType;
  };

  export type RateLimitConfigGroupByOutputType = {
    id: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy: $Enums.RateLimitKeyStrategy;
    enabled: boolean;
    description: string | null;
    createdAt: Date;
    updatedAt: Date;
    applicationLimits: JsonValue | null;
    roleLimits: JsonValue | null;
    componentLimits: JsonValue | null;
    changeHistory: JsonValue | null;
    changeReason: string | null;
    organizationId: string;
    createdBy: string;
    updatedBy: string | null;
    _count: RateLimitConfigCountAggregateOutputType | null;
    _avg: RateLimitConfigAvgAggregateOutputType | null;
    _sum: RateLimitConfigSumAggregateOutputType | null;
    _min: RateLimitConfigMinAggregateOutputType | null;
    _max: RateLimitConfigMaxAggregateOutputType | null;
  };

  type GetRateLimitConfigGroupByPayload<T extends RateLimitConfigGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RateLimitConfigGroupByOutputType, T['by']> & {
          [P in keyof T & keyof RateLimitConfigGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitConfigGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitConfigGroupByOutputType[P]>;
        }
      >
    >;

  export type RateLimitConfigSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      displayName?: boolean;
      type?: boolean;
      max?: boolean;
      windowMs?: boolean;
      keyStrategy?: boolean;
      enabled?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      applicationLimits?: boolean;
      roleLimits?: boolean;
      componentLimits?: boolean;
      changeHistory?: boolean;
      changeReason?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      updatedBy?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      displayName?: boolean;
      type?: boolean;
      max?: boolean;
      windowMs?: boolean;
      keyStrategy?: boolean;
      enabled?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      applicationLimits?: boolean;
      roleLimits?: boolean;
      componentLimits?: boolean;
      changeHistory?: boolean;
      changeReason?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      updatedBy?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      displayName?: boolean;
      type?: boolean;
      max?: boolean;
      windowMs?: boolean;
      keyStrategy?: boolean;
      enabled?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      applicationLimits?: boolean;
      roleLimits?: boolean;
      componentLimits?: boolean;
      changeHistory?: boolean;
      changeReason?: boolean;
      organizationId?: boolean;
      createdBy?: boolean;
      updatedBy?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectScalar = {
    id?: boolean;
    name?: boolean;
    displayName?: boolean;
    type?: boolean;
    max?: boolean;
    windowMs?: boolean;
    keyStrategy?: boolean;
    enabled?: boolean;
    description?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    applicationLimits?: boolean;
    roleLimits?: boolean;
    componentLimits?: boolean;
    changeHistory?: boolean;
    changeReason?: boolean;
    organizationId?: boolean;
    createdBy?: boolean;
    updatedBy?: boolean;
  };

  export type RateLimitConfigOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'displayName'
    | 'type'
    | 'max'
    | 'windowMs'
    | 'keyStrategy'
    | 'enabled'
    | 'description'
    | 'createdAt'
    | 'updatedAt'
    | 'applicationLimits'
    | 'roleLimits'
    | 'componentLimits'
    | 'changeHistory'
    | 'changeReason'
    | 'organizationId'
    | 'createdBy'
    | 'updatedBy',
    ExtArgs['result']['rateLimitConfig']
  >;
  export type RateLimitConfigInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
  };
  export type RateLimitConfigIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
  };
  export type RateLimitConfigIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    updater?: boolean | RateLimitConfig$updaterArgs<ExtArgs>;
  };

  export type $RateLimitConfigPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RateLimitConfig';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      creator: Prisma.$UserPayload<ExtArgs>;
      updater: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        displayName: string;
        type: $Enums.RateLimitType;
        max: number;
        windowMs: number;
        keyStrategy: $Enums.RateLimitKeyStrategy;
        enabled: boolean;
        description: string | null;
        createdAt: Date;
        updatedAt: Date;
        applicationLimits: Prisma.JsonValue | null;
        roleLimits: Prisma.JsonValue | null;
        componentLimits: Prisma.JsonValue | null;
        changeHistory: Prisma.JsonValue | null;
        changeReason: string | null;
        organizationId: string;
        createdBy: string;
        updatedBy: string | null;
      },
      ExtArgs['result']['rateLimitConfig']
    >;
    composites: {};
  };

  type RateLimitConfigGetPayload<
    S extends boolean | null | undefined | RateLimitConfigDefaultArgs,
  > = $Result.GetResult<Prisma.$RateLimitConfigPayload, S>;

  type RateLimitConfigCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RateLimitConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RateLimitConfigCountAggregateInputType | true;
  };

  export interface RateLimitConfigDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RateLimitConfig'];
      meta: { name: 'RateLimitConfig' };
    };
    /**
     * Find zero or one RateLimitConfig that matches the filter.
     * @param {RateLimitConfigFindUniqueArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitConfigFindUniqueArgs>(
      args: SelectSubset<T, RateLimitConfigFindUniqueArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RateLimitConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RateLimitConfigFindUniqueOrThrowArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitConfigFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RateLimitConfigFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindFirstArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitConfigFindFirstArgs>(
      args?: SelectSubset<T, RateLimitConfigFindFirstArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindFirstOrThrowArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitConfigFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RateLimitConfigFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RateLimitConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitConfigs
     * const rateLimitConfigs = await prisma.rateLimitConfig.findMany()
     *
     * // Get first 10 RateLimitConfigs
     * const rateLimitConfigs = await prisma.rateLimitConfig.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RateLimitConfigFindManyArgs>(
      args?: SelectSubset<T, RateLimitConfigFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a RateLimitConfig.
     * @param {RateLimitConfigCreateArgs} args - Arguments to create a RateLimitConfig.
     * @example
     * // Create one RateLimitConfig
     * const RateLimitConfig = await prisma.rateLimitConfig.create({
     *   data: {
     *     // ... data to create a RateLimitConfig
     *   }
     * })
     *
     */
    create<T extends RateLimitConfigCreateArgs>(
      args: SelectSubset<T, RateLimitConfigCreateArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RateLimitConfigs.
     * @param {RateLimitConfigCreateManyArgs} args - Arguments to create many RateLimitConfigs.
     * @example
     * // Create many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RateLimitConfigCreateManyArgs>(
      args?: SelectSubset<T, RateLimitConfigCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RateLimitConfigs and returns the data saved in the database.
     * @param {RateLimitConfigCreateManyAndReturnArgs} args - Arguments to create many RateLimitConfigs.
     * @example
     * // Create many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RateLimitConfigs and only return the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RateLimitConfigCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RateLimitConfigCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a RateLimitConfig.
     * @param {RateLimitConfigDeleteArgs} args - Arguments to delete one RateLimitConfig.
     * @example
     * // Delete one RateLimitConfig
     * const RateLimitConfig = await prisma.rateLimitConfig.delete({
     *   where: {
     *     // ... filter to delete one RateLimitConfig
     *   }
     * })
     *
     */
    delete<T extends RateLimitConfigDeleteArgs>(
      args: SelectSubset<T, RateLimitConfigDeleteArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RateLimitConfig.
     * @param {RateLimitConfigUpdateArgs} args - Arguments to update one RateLimitConfig.
     * @example
     * // Update one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RateLimitConfigUpdateArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RateLimitConfigs.
     * @param {RateLimitConfigDeleteManyArgs} args - Arguments to filter RateLimitConfigs to delete.
     * @example
     * // Delete a few RateLimitConfigs
     * const { count } = await prisma.rateLimitConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RateLimitConfigDeleteManyArgs>(
      args?: SelectSubset<T, RateLimitConfigDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RateLimitConfigUpdateManyArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitConfigs and returns the data updated in the database.
     * @param {RateLimitConfigUpdateManyAndReturnArgs} args - Arguments to update many RateLimitConfigs.
     * @example
     * // Update many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RateLimitConfigs and only return the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RateLimitConfigUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one RateLimitConfig.
     * @param {RateLimitConfigUpsertArgs} args - Arguments to update or create a RateLimitConfig.
     * @example
     * // Update or create a RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.upsert({
     *   create: {
     *     // ... data to create a RateLimitConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimitConfig we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitConfigUpsertArgs>(
      args: SelectSubset<T, RateLimitConfigUpsertArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RateLimitConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigCountArgs} args - Arguments to filter RateLimitConfigs to count.
     * @example
     * // Count the number of RateLimitConfigs
     * const count = await prisma.rateLimitConfig.count({
     *   where: {
     *     // ... the filter for the RateLimitConfigs we want to count
     *   }
     * })
     **/
    count<T extends RateLimitConfigCountArgs>(
      args?: Subset<T, RateLimitConfigCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitConfigCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RateLimitConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RateLimitConfigAggregateArgs>(
      args: Subset<T, RateLimitConfigAggregateArgs>
    ): Prisma.PrismaPromise<GetRateLimitConfigAggregateType<T>>;

    /**
     * Group by RateLimitConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RateLimitConfigGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitConfigGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RateLimitConfigGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRateLimitConfigGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RateLimitConfig model
     */
    readonly fields: RateLimitConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimitConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitConfigClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    updater<T extends RateLimitConfig$updaterArgs<ExtArgs> = {}>(
      args?: Subset<T, RateLimitConfig$updaterArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RateLimitConfig model
   */
  interface RateLimitConfigFieldRefs {
    readonly id: FieldRef<'RateLimitConfig', 'String'>;
    readonly name: FieldRef<'RateLimitConfig', 'String'>;
    readonly displayName: FieldRef<'RateLimitConfig', 'String'>;
    readonly type: FieldRef<'RateLimitConfig', 'RateLimitType'>;
    readonly max: FieldRef<'RateLimitConfig', 'Int'>;
    readonly windowMs: FieldRef<'RateLimitConfig', 'Int'>;
    readonly keyStrategy: FieldRef<'RateLimitConfig', 'RateLimitKeyStrategy'>;
    readonly enabled: FieldRef<'RateLimitConfig', 'Boolean'>;
    readonly description: FieldRef<'RateLimitConfig', 'String'>;
    readonly createdAt: FieldRef<'RateLimitConfig', 'DateTime'>;
    readonly updatedAt: FieldRef<'RateLimitConfig', 'DateTime'>;
    readonly applicationLimits: FieldRef<'RateLimitConfig', 'Json'>;
    readonly roleLimits: FieldRef<'RateLimitConfig', 'Json'>;
    readonly componentLimits: FieldRef<'RateLimitConfig', 'Json'>;
    readonly changeHistory: FieldRef<'RateLimitConfig', 'Json'>;
    readonly changeReason: FieldRef<'RateLimitConfig', 'String'>;
    readonly organizationId: FieldRef<'RateLimitConfig', 'String'>;
    readonly createdBy: FieldRef<'RateLimitConfig', 'String'>;
    readonly updatedBy: FieldRef<'RateLimitConfig', 'String'>;
  }

  // Custom InputTypes
  /**
   * RateLimitConfig findUnique
   */
  export type RateLimitConfigFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig findUniqueOrThrow
   */
  export type RateLimitConfigFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig findFirst
   */
  export type RateLimitConfigFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitConfigs.
     */
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig findFirstOrThrow
   */
  export type RateLimitConfigFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitConfigs.
     */
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig findMany
   */
  export type RateLimitConfigFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfigs to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig create
   */
  export type RateLimitConfigCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * The data needed to create a RateLimitConfig.
     */
    data: XOR<RateLimitConfigCreateInput, RateLimitConfigUncheckedCreateInput>;
  };

  /**
   * RateLimitConfig createMany
   */
  export type RateLimitConfigCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RateLimitConfigs.
     */
    data: RateLimitConfigCreateManyInput | RateLimitConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RateLimitConfig createManyAndReturn
   */
  export type RateLimitConfigCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data used to create many RateLimitConfigs.
     */
    data: RateLimitConfigCreateManyInput | RateLimitConfigCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RateLimitConfig update
   */
  export type RateLimitConfigUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * The data needed to update a RateLimitConfig.
     */
    data: XOR<RateLimitConfigUpdateInput, RateLimitConfigUncheckedUpdateInput>;
    /**
     * Choose, which RateLimitConfig to update.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig updateMany
   */
  export type RateLimitConfigUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RateLimitConfigs.
     */
    data: XOR<RateLimitConfigUpdateManyMutationInput, RateLimitConfigUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitConfigs to update
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to update.
     */
    limit?: number;
  };

  /**
   * RateLimitConfig updateManyAndReturn
   */
  export type RateLimitConfigUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data used to update RateLimitConfigs.
     */
    data: XOR<RateLimitConfigUpdateManyMutationInput, RateLimitConfigUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitConfigs to update
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RateLimitConfig upsert
   */
  export type RateLimitConfigUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * The filter to search for the RateLimitConfig to update in case it exists.
     */
    where: RateLimitConfigWhereUniqueInput;
    /**
     * In case the RateLimitConfig found by the `where` argument doesn't exist, create a new RateLimitConfig with this data.
     */
    create: XOR<RateLimitConfigCreateInput, RateLimitConfigUncheckedCreateInput>;
    /**
     * In case the RateLimitConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitConfigUpdateInput, RateLimitConfigUncheckedUpdateInput>;
  };

  /**
   * RateLimitConfig delete
   */
  export type RateLimitConfigDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
    /**
     * Filter which RateLimitConfig to delete.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig deleteMany
   */
  export type RateLimitConfigDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitConfigs to delete
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to delete.
     */
    limit?: number;
  };

  /**
   * RateLimitConfig.updater
   */
  export type RateLimitConfig$updaterArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * RateLimitConfig without action
   */
  export type RateLimitConfigDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitConfigInclude<ExtArgs> | null;
  };

  /**
   * Model RateLimitUsage
   */

  export type AggregateRateLimitUsage = {
    _count: RateLimitUsageCountAggregateOutputType | null;
    _avg: RateLimitUsageAvgAggregateOutputType | null;
    _sum: RateLimitUsageSumAggregateOutputType | null;
    _min: RateLimitUsageMinAggregateOutputType | null;
    _max: RateLimitUsageMaxAggregateOutputType | null;
  };

  export type RateLimitUsageAvgAggregateOutputType = {
    currentCount: number | null;
  };

  export type RateLimitUsageSumAggregateOutputType = {
    currentCount: number | null;
  };

  export type RateLimitUsageMinAggregateOutputType = {
    id: string | null;
    configName: string | null;
    limitKey: string | null;
    currentCount: number | null;
    resetAt: Date | null;
    blocked: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
  };

  export type RateLimitUsageMaxAggregateOutputType = {
    id: string | null;
    configName: string | null;
    limitKey: string | null;
    currentCount: number | null;
    resetAt: Date | null;
    blocked: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    organizationId: string | null;
  };

  export type RateLimitUsageCountAggregateOutputType = {
    id: number;
    configName: number;
    limitKey: number;
    currentCount: number;
    resetAt: number;
    blocked: number;
    createdAt: number;
    updatedAt: number;
    organizationId: number;
    _all: number;
  };

  export type RateLimitUsageAvgAggregateInputType = {
    currentCount?: true;
  };

  export type RateLimitUsageSumAggregateInputType = {
    currentCount?: true;
  };

  export type RateLimitUsageMinAggregateInputType = {
    id?: true;
    configName?: true;
    limitKey?: true;
    currentCount?: true;
    resetAt?: true;
    blocked?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
  };

  export type RateLimitUsageMaxAggregateInputType = {
    id?: true;
    configName?: true;
    limitKey?: true;
    currentCount?: true;
    resetAt?: true;
    blocked?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
  };

  export type RateLimitUsageCountAggregateInputType = {
    id?: true;
    configName?: true;
    limitKey?: true;
    currentCount?: true;
    resetAt?: true;
    blocked?: true;
    createdAt?: true;
    updatedAt?: true;
    organizationId?: true;
    _all?: true;
  };

  export type RateLimitUsageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitUsage to aggregate.
     */
    where?: RateLimitUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitUsages to fetch.
     */
    orderBy?: RateLimitUsageOrderByWithRelationInput | RateLimitUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RateLimitUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RateLimitUsages
     **/
    _count?: true | RateLimitUsageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RateLimitUsageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RateLimitUsageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RateLimitUsageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RateLimitUsageMaxAggregateInputType;
  };

  export type GetRateLimitUsageAggregateType<T extends RateLimitUsageAggregateArgs> = {
    [P in keyof T & keyof AggregateRateLimitUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimitUsage[P]>
      : GetScalarType<T[P], AggregateRateLimitUsage[P]>;
  };

  export type RateLimitUsageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitUsageWhereInput;
    orderBy?:
      | RateLimitUsageOrderByWithAggregationInput
      | RateLimitUsageOrderByWithAggregationInput[];
    by: RateLimitUsageScalarFieldEnum[] | RateLimitUsageScalarFieldEnum;
    having?: RateLimitUsageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RateLimitUsageCountAggregateInputType | true;
    _avg?: RateLimitUsageAvgAggregateInputType;
    _sum?: RateLimitUsageSumAggregateInputType;
    _min?: RateLimitUsageMinAggregateInputType;
    _max?: RateLimitUsageMaxAggregateInputType;
  };

  export type RateLimitUsageGroupByOutputType = {
    id: string;
    configName: string;
    limitKey: string;
    currentCount: number;
    resetAt: Date;
    blocked: boolean;
    createdAt: Date;
    updatedAt: Date;
    organizationId: string;
    _count: RateLimitUsageCountAggregateOutputType | null;
    _avg: RateLimitUsageAvgAggregateOutputType | null;
    _sum: RateLimitUsageSumAggregateOutputType | null;
    _min: RateLimitUsageMinAggregateOutputType | null;
    _max: RateLimitUsageMaxAggregateOutputType | null;
  };

  type GetRateLimitUsageGroupByPayload<T extends RateLimitUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitUsageGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RateLimitUsageGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RateLimitUsageGroupByOutputType[P]>
          : GetScalarType<T[P], RateLimitUsageGroupByOutputType[P]>;
      }
    >
  >;

  export type RateLimitUsageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      configName?: boolean;
      limitKey?: boolean;
      currentCount?: boolean;
      resetAt?: boolean;
      blocked?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitUsage']
  >;

  export type RateLimitUsageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      configName?: boolean;
      limitKey?: boolean;
      currentCount?: boolean;
      resetAt?: boolean;
      blocked?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitUsage']
  >;

  export type RateLimitUsageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      configName?: boolean;
      limitKey?: boolean;
      currentCount?: boolean;
      resetAt?: boolean;
      blocked?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organizationId?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['rateLimitUsage']
  >;

  export type RateLimitUsageSelectScalar = {
    id?: boolean;
    configName?: boolean;
    limitKey?: boolean;
    currentCount?: boolean;
    resetAt?: boolean;
    blocked?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    organizationId?: boolean;
  };

  export type RateLimitUsageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'configName'
    | 'limitKey'
    | 'currentCount'
    | 'resetAt'
    | 'blocked'
    | 'createdAt'
    | 'updatedAt'
    | 'organizationId',
    ExtArgs['result']['rateLimitUsage']
  >;
  export type RateLimitUsageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type RateLimitUsageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type RateLimitUsageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $RateLimitUsagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RateLimitUsage';
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        configName: string;
        limitKey: string;
        currentCount: number;
        resetAt: Date;
        blocked: boolean;
        createdAt: Date;
        updatedAt: Date;
        organizationId: string;
      },
      ExtArgs['result']['rateLimitUsage']
    >;
    composites: {};
  };

  type RateLimitUsageGetPayload<S extends boolean | null | undefined | RateLimitUsageDefaultArgs> =
    $Result.GetResult<Prisma.$RateLimitUsagePayload, S>;

  type RateLimitUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RateLimitUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RateLimitUsageCountAggregateInputType | true;
    };

  export interface RateLimitUsageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RateLimitUsage'];
      meta: { name: 'RateLimitUsage' };
    };
    /**
     * Find zero or one RateLimitUsage that matches the filter.
     * @param {RateLimitUsageFindUniqueArgs} args - Arguments to find a RateLimitUsage
     * @example
     * // Get one RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitUsageFindUniqueArgs>(
      args: SelectSubset<T, RateLimitUsageFindUniqueArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RateLimitUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RateLimitUsageFindUniqueOrThrowArgs} args - Arguments to find a RateLimitUsage
     * @example
     * // Get one RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitUsageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RateLimitUsageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageFindFirstArgs} args - Arguments to find a RateLimitUsage
     * @example
     * // Get one RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitUsageFindFirstArgs>(
      args?: SelectSubset<T, RateLimitUsageFindFirstArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageFindFirstOrThrowArgs} args - Arguments to find a RateLimitUsage
     * @example
     * // Get one RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitUsageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RateLimitUsageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RateLimitUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitUsages
     * const rateLimitUsages = await prisma.rateLimitUsage.findMany()
     *
     * // Get first 10 RateLimitUsages
     * const rateLimitUsages = await prisma.rateLimitUsage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rateLimitUsageWithIdOnly = await prisma.rateLimitUsage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RateLimitUsageFindManyArgs>(
      args?: SelectSubset<T, RateLimitUsageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a RateLimitUsage.
     * @param {RateLimitUsageCreateArgs} args - Arguments to create a RateLimitUsage.
     * @example
     * // Create one RateLimitUsage
     * const RateLimitUsage = await prisma.rateLimitUsage.create({
     *   data: {
     *     // ... data to create a RateLimitUsage
     *   }
     * })
     *
     */
    create<T extends RateLimitUsageCreateArgs>(
      args: SelectSubset<T, RateLimitUsageCreateArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RateLimitUsages.
     * @param {RateLimitUsageCreateManyArgs} args - Arguments to create many RateLimitUsages.
     * @example
     * // Create many RateLimitUsages
     * const rateLimitUsage = await prisma.rateLimitUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RateLimitUsageCreateManyArgs>(
      args?: SelectSubset<T, RateLimitUsageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RateLimitUsages and returns the data saved in the database.
     * @param {RateLimitUsageCreateManyAndReturnArgs} args - Arguments to create many RateLimitUsages.
     * @example
     * // Create many RateLimitUsages
     * const rateLimitUsage = await prisma.rateLimitUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RateLimitUsages and only return the `id`
     * const rateLimitUsageWithIdOnly = await prisma.rateLimitUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RateLimitUsageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RateLimitUsageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a RateLimitUsage.
     * @param {RateLimitUsageDeleteArgs} args - Arguments to delete one RateLimitUsage.
     * @example
     * // Delete one RateLimitUsage
     * const RateLimitUsage = await prisma.rateLimitUsage.delete({
     *   where: {
     *     // ... filter to delete one RateLimitUsage
     *   }
     * })
     *
     */
    delete<T extends RateLimitUsageDeleteArgs>(
      args: SelectSubset<T, RateLimitUsageDeleteArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RateLimitUsage.
     * @param {RateLimitUsageUpdateArgs} args - Arguments to update one RateLimitUsage.
     * @example
     * // Update one RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RateLimitUsageUpdateArgs>(
      args: SelectSubset<T, RateLimitUsageUpdateArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RateLimitUsages.
     * @param {RateLimitUsageDeleteManyArgs} args - Arguments to filter RateLimitUsages to delete.
     * @example
     * // Delete a few RateLimitUsages
     * const { count } = await prisma.rateLimitUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RateLimitUsageDeleteManyArgs>(
      args?: SelectSubset<T, RateLimitUsageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitUsages
     * const rateLimitUsage = await prisma.rateLimitUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RateLimitUsageUpdateManyArgs>(
      args: SelectSubset<T, RateLimitUsageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitUsages and returns the data updated in the database.
     * @param {RateLimitUsageUpdateManyAndReturnArgs} args - Arguments to update many RateLimitUsages.
     * @example
     * // Update many RateLimitUsages
     * const rateLimitUsage = await prisma.rateLimitUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RateLimitUsages and only return the `id`
     * const rateLimitUsageWithIdOnly = await prisma.rateLimitUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RateLimitUsageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RateLimitUsageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitUsagePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one RateLimitUsage.
     * @param {RateLimitUsageUpsertArgs} args - Arguments to update or create a RateLimitUsage.
     * @example
     * // Update or create a RateLimitUsage
     * const rateLimitUsage = await prisma.rateLimitUsage.upsert({
     *   create: {
     *     // ... data to create a RateLimitUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimitUsage we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitUsageUpsertArgs>(
      args: SelectSubset<T, RateLimitUsageUpsertArgs<ExtArgs>>
    ): Prisma__RateLimitUsageClient<
      $Result.GetResult<Prisma.$RateLimitUsagePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RateLimitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageCountArgs} args - Arguments to filter RateLimitUsages to count.
     * @example
     * // Count the number of RateLimitUsages
     * const count = await prisma.rateLimitUsage.count({
     *   where: {
     *     // ... the filter for the RateLimitUsages we want to count
     *   }
     * })
     **/
    count<T extends RateLimitUsageCountArgs>(
      args?: Subset<T, RateLimitUsageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitUsageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RateLimitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RateLimitUsageAggregateArgs>(
      args: Subset<T, RateLimitUsageAggregateArgs>
    ): Prisma.PrismaPromise<GetRateLimitUsageAggregateType<T>>;

    /**
     * Group by RateLimitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RateLimitUsageGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitUsageGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RateLimitUsageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRateLimitUsageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RateLimitUsage model
     */
    readonly fields: RateLimitUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimitUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitUsageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RateLimitUsage model
   */
  interface RateLimitUsageFieldRefs {
    readonly id: FieldRef<'RateLimitUsage', 'String'>;
    readonly configName: FieldRef<'RateLimitUsage', 'String'>;
    readonly limitKey: FieldRef<'RateLimitUsage', 'String'>;
    readonly currentCount: FieldRef<'RateLimitUsage', 'Int'>;
    readonly resetAt: FieldRef<'RateLimitUsage', 'DateTime'>;
    readonly blocked: FieldRef<'RateLimitUsage', 'Boolean'>;
    readonly createdAt: FieldRef<'RateLimitUsage', 'DateTime'>;
    readonly updatedAt: FieldRef<'RateLimitUsage', 'DateTime'>;
    readonly organizationId: FieldRef<'RateLimitUsage', 'String'>;
  }

  // Custom InputTypes
  /**
   * RateLimitUsage findUnique
   */
  export type RateLimitUsageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitUsage to fetch.
     */
    where: RateLimitUsageWhereUniqueInput;
  };

  /**
   * RateLimitUsage findUniqueOrThrow
   */
  export type RateLimitUsageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitUsage to fetch.
     */
    where: RateLimitUsageWhereUniqueInput;
  };

  /**
   * RateLimitUsage findFirst
   */
  export type RateLimitUsageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitUsage to fetch.
     */
    where?: RateLimitUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitUsages to fetch.
     */
    orderBy?: RateLimitUsageOrderByWithRelationInput | RateLimitUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitUsages.
     */
    cursor?: RateLimitUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitUsages.
     */
    distinct?: RateLimitUsageScalarFieldEnum | RateLimitUsageScalarFieldEnum[];
  };

  /**
   * RateLimitUsage findFirstOrThrow
   */
  export type RateLimitUsageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitUsage to fetch.
     */
    where?: RateLimitUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitUsages to fetch.
     */
    orderBy?: RateLimitUsageOrderByWithRelationInput | RateLimitUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitUsages.
     */
    cursor?: RateLimitUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitUsages.
     */
    distinct?: RateLimitUsageScalarFieldEnum | RateLimitUsageScalarFieldEnum[];
  };

  /**
   * RateLimitUsage findMany
   */
  export type RateLimitUsageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter, which RateLimitUsages to fetch.
     */
    where?: RateLimitUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitUsages to fetch.
     */
    orderBy?: RateLimitUsageOrderByWithRelationInput | RateLimitUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RateLimitUsages.
     */
    cursor?: RateLimitUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitUsages.
     */
    skip?: number;
    distinct?: RateLimitUsageScalarFieldEnum | RateLimitUsageScalarFieldEnum[];
  };

  /**
   * RateLimitUsage create
   */
  export type RateLimitUsageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * The data needed to create a RateLimitUsage.
     */
    data: XOR<RateLimitUsageCreateInput, RateLimitUsageUncheckedCreateInput>;
  };

  /**
   * RateLimitUsage createMany
   */
  export type RateLimitUsageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RateLimitUsages.
     */
    data: RateLimitUsageCreateManyInput | RateLimitUsageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RateLimitUsage createManyAndReturn
   */
  export type RateLimitUsageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * The data used to create many RateLimitUsages.
     */
    data: RateLimitUsageCreateManyInput | RateLimitUsageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RateLimitUsage update
   */
  export type RateLimitUsageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * The data needed to update a RateLimitUsage.
     */
    data: XOR<RateLimitUsageUpdateInput, RateLimitUsageUncheckedUpdateInput>;
    /**
     * Choose, which RateLimitUsage to update.
     */
    where: RateLimitUsageWhereUniqueInput;
  };

  /**
   * RateLimitUsage updateMany
   */
  export type RateLimitUsageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RateLimitUsages.
     */
    data: XOR<RateLimitUsageUpdateManyMutationInput, RateLimitUsageUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitUsages to update
     */
    where?: RateLimitUsageWhereInput;
    /**
     * Limit how many RateLimitUsages to update.
     */
    limit?: number;
  };

  /**
   * RateLimitUsage updateManyAndReturn
   */
  export type RateLimitUsageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * The data used to update RateLimitUsages.
     */
    data: XOR<RateLimitUsageUpdateManyMutationInput, RateLimitUsageUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitUsages to update
     */
    where?: RateLimitUsageWhereInput;
    /**
     * Limit how many RateLimitUsages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RateLimitUsage upsert
   */
  export type RateLimitUsageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * The filter to search for the RateLimitUsage to update in case it exists.
     */
    where: RateLimitUsageWhereUniqueInput;
    /**
     * In case the RateLimitUsage found by the `where` argument doesn't exist, create a new RateLimitUsage with this data.
     */
    create: XOR<RateLimitUsageCreateInput, RateLimitUsageUncheckedCreateInput>;
    /**
     * In case the RateLimitUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitUsageUpdateInput, RateLimitUsageUncheckedUpdateInput>;
  };

  /**
   * RateLimitUsage delete
   */
  export type RateLimitUsageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
    /**
     * Filter which RateLimitUsage to delete.
     */
    where: RateLimitUsageWhereUniqueInput;
  };

  /**
   * RateLimitUsage deleteMany
   */
  export type RateLimitUsageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitUsages to delete
     */
    where?: RateLimitUsageWhereInput;
    /**
     * Limit how many RateLimitUsages to delete.
     */
    limit?: number;
  };

  /**
   * RateLimitUsage without action
   */
  export type RateLimitUsageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitUsage
     */
    select?: RateLimitUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitUsage
     */
    omit?: RateLimitUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateLimitUsageInclude<ExtArgs> | null;
  };

  /**
   * Model SocialAccount
   */

  export type AggregateSocialAccount = {
    _count: SocialAccountCountAggregateOutputType | null;
    _min: SocialAccountMinAggregateOutputType | null;
    _max: SocialAccountMaxAggregateOutputType | null;
  };

  export type SocialAccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    provider: string | null;
    providerId: string | null;
    email: string | null;
    name: string | null;
    profileUrl: string | null;
    avatarUrl: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    profileData: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SocialAccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    provider: string | null;
    providerId: string | null;
    email: string | null;
    name: string | null;
    profileUrl: string | null;
    avatarUrl: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    profileData: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SocialAccountCountAggregateOutputType = {
    id: number;
    userId: number;
    provider: number;
    providerId: number;
    email: number;
    name: number;
    profileUrl: number;
    avatarUrl: number;
    accessToken: number;
    refreshToken: number;
    profileData: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SocialAccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    providerId?: true;
    email?: true;
    name?: true;
    profileUrl?: true;
    avatarUrl?: true;
    accessToken?: true;
    refreshToken?: true;
    profileData?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SocialAccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    providerId?: true;
    email?: true;
    name?: true;
    profileUrl?: true;
    avatarUrl?: true;
    accessToken?: true;
    refreshToken?: true;
    profileData?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SocialAccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    provider?: true;
    providerId?: true;
    email?: true;
    name?: true;
    profileUrl?: true;
    avatarUrl?: true;
    accessToken?: true;
    refreshToken?: true;
    profileData?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SocialAccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SocialAccount to aggregate.
     */
    where?: SocialAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SocialAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SocialAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SocialAccounts
     **/
    _count?: true | SocialAccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SocialAccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SocialAccountMaxAggregateInputType;
  };

  export type GetSocialAccountAggregateType<T extends SocialAccountAggregateArgs> = {
    [P in keyof T & keyof AggregateSocialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialAccount[P]>
      : GetScalarType<T[P], AggregateSocialAccount[P]>;
  };

  export type SocialAccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SocialAccountWhereInput;
    orderBy?: SocialAccountOrderByWithAggregationInput | SocialAccountOrderByWithAggregationInput[];
    by: SocialAccountScalarFieldEnum[] | SocialAccountScalarFieldEnum;
    having?: SocialAccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SocialAccountCountAggregateInputType | true;
    _min?: SocialAccountMinAggregateInputType;
    _max?: SocialAccountMaxAggregateInputType;
  };

  export type SocialAccountGroupByOutputType = {
    id: string;
    userId: string;
    provider: string;
    providerId: string;
    email: string | null;
    name: string | null;
    profileUrl: string | null;
    avatarUrl: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    profileData: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: SocialAccountCountAggregateOutputType | null;
    _min: SocialAccountMinAggregateOutputType | null;
    _max: SocialAccountMaxAggregateOutputType | null;
  };

  type GetSocialAccountGroupByPayload<T extends SocialAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialAccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SocialAccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SocialAccountGroupByOutputType[P]>
          : GetScalarType<T[P], SocialAccountGroupByOutputType[P]>;
      }
    >
  >;

  export type SocialAccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      providerId?: boolean;
      email?: boolean;
      name?: boolean;
      profileUrl?: boolean;
      avatarUrl?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      profileData?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['socialAccount']
  >;

  export type SocialAccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      providerId?: boolean;
      email?: boolean;
      name?: boolean;
      profileUrl?: boolean;
      avatarUrl?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      profileData?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['socialAccount']
  >;

  export type SocialAccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      provider?: boolean;
      providerId?: boolean;
      email?: boolean;
      name?: boolean;
      profileUrl?: boolean;
      avatarUrl?: boolean;
      accessToken?: boolean;
      refreshToken?: boolean;
      profileData?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['socialAccount']
  >;

  export type SocialAccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    provider?: boolean;
    providerId?: boolean;
    email?: boolean;
    name?: boolean;
    profileUrl?: boolean;
    avatarUrl?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    profileData?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SocialAccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'provider'
    | 'providerId'
    | 'email'
    | 'name'
    | 'profileUrl'
    | 'avatarUrl'
    | 'accessToken'
    | 'refreshToken'
    | 'profileData'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['socialAccount']
  >;
  export type SocialAccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SocialAccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SocialAccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SocialAccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SocialAccount';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        provider: string;
        providerId: string;
        email: string | null;
        name: string | null;
        profileUrl: string | null;
        avatarUrl: string | null;
        accessToken: string | null;
        refreshToken: string | null;
        profileData: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['socialAccount']
    >;
    composites: {};
  };

  type SocialAccountGetPayload<S extends boolean | null | undefined | SocialAccountDefaultArgs> =
    $Result.GetResult<Prisma.$SocialAccountPayload, S>;

  type SocialAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialAccountCountAggregateInputType | true;
    };

  export interface SocialAccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SocialAccount'];
      meta: { name: 'SocialAccount' };
    };
    /**
     * Find zero or one SocialAccount that matches the filter.
     * @param {SocialAccountFindUniqueArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialAccountFindUniqueArgs>(
      args: SelectSubset<T, SocialAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SocialAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialAccountFindUniqueOrThrowArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialAccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SocialAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SocialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindFirstArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialAccountFindFirstArgs>(
      args?: SelectSubset<T, SocialAccountFindFirstArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SocialAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindFirstOrThrowArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialAccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SocialAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SocialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialAccounts
     * const socialAccounts = await prisma.socialAccount.findMany()
     *
     * // Get first 10 SocialAccounts
     * const socialAccounts = await prisma.socialAccount.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SocialAccountFindManyArgs>(
      args?: SelectSubset<T, SocialAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a SocialAccount.
     * @param {SocialAccountCreateArgs} args - Arguments to create a SocialAccount.
     * @example
     * // Create one SocialAccount
     * const SocialAccount = await prisma.socialAccount.create({
     *   data: {
     *     // ... data to create a SocialAccount
     *   }
     * })
     *
     */
    create<T extends SocialAccountCreateArgs>(
      args: SelectSubset<T, SocialAccountCreateArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SocialAccounts.
     * @param {SocialAccountCreateManyArgs} args - Arguments to create many SocialAccounts.
     * @example
     * // Create many SocialAccounts
     * const socialAccount = await prisma.socialAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SocialAccountCreateManyArgs>(
      args?: SelectSubset<T, SocialAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SocialAccounts and returns the data saved in the database.
     * @param {SocialAccountCreateManyAndReturnArgs} args - Arguments to create many SocialAccounts.
     * @example
     * // Create many SocialAccounts
     * const socialAccount = await prisma.socialAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SocialAccounts and only return the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SocialAccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SocialAccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SocialAccount.
     * @param {SocialAccountDeleteArgs} args - Arguments to delete one SocialAccount.
     * @example
     * // Delete one SocialAccount
     * const SocialAccount = await prisma.socialAccount.delete({
     *   where: {
     *     // ... filter to delete one SocialAccount
     *   }
     * })
     *
     */
    delete<T extends SocialAccountDeleteArgs>(
      args: SelectSubset<T, SocialAccountDeleteArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SocialAccount.
     * @param {SocialAccountUpdateArgs} args - Arguments to update one SocialAccount.
     * @example
     * // Update one SocialAccount
     * const socialAccount = await prisma.socialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SocialAccountUpdateArgs>(
      args: SelectSubset<T, SocialAccountUpdateArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SocialAccounts.
     * @param {SocialAccountDeleteManyArgs} args - Arguments to filter SocialAccounts to delete.
     * @example
     * // Delete a few SocialAccounts
     * const { count } = await prisma.socialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SocialAccountDeleteManyArgs>(
      args?: SelectSubset<T, SocialAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialAccounts
     * const socialAccount = await prisma.socialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SocialAccountUpdateManyArgs>(
      args: SelectSubset<T, SocialAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SocialAccounts and returns the data updated in the database.
     * @param {SocialAccountUpdateManyAndReturnArgs} args - Arguments to update many SocialAccounts.
     * @example
     * // Update many SocialAccounts
     * const socialAccount = await prisma.socialAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SocialAccounts and only return the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SocialAccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SocialAccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SocialAccountPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SocialAccount.
     * @param {SocialAccountUpsertArgs} args - Arguments to update or create a SocialAccount.
     * @example
     * // Update or create a SocialAccount
     * const socialAccount = await prisma.socialAccount.upsert({
     *   create: {
     *     // ... data to create a SocialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialAccount we want to update
     *   }
     * })
     */
    upsert<T extends SocialAccountUpsertArgs>(
      args: SelectSubset<T, SocialAccountUpsertArgs<ExtArgs>>
    ): Prisma__SocialAccountClient<
      $Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountCountArgs} args - Arguments to filter SocialAccounts to count.
     * @example
     * // Count the number of SocialAccounts
     * const count = await prisma.socialAccount.count({
     *   where: {
     *     // ... the filter for the SocialAccounts we want to count
     *   }
     * })
     **/
    count<T extends SocialAccountCountArgs>(
      args?: Subset<T, SocialAccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialAccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SocialAccountAggregateArgs>(
      args: Subset<T, SocialAccountAggregateArgs>
    ): Prisma.PrismaPromise<GetSocialAccountAggregateType<T>>;

    /**
     * Group by SocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SocialAccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialAccountGroupByArgs['orderBy'] }
        : { orderBy?: SocialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SocialAccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSocialAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SocialAccount model
     */
    readonly fields: SocialAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialAccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SocialAccount model
   */
  interface SocialAccountFieldRefs {
    readonly id: FieldRef<'SocialAccount', 'String'>;
    readonly userId: FieldRef<'SocialAccount', 'String'>;
    readonly provider: FieldRef<'SocialAccount', 'String'>;
    readonly providerId: FieldRef<'SocialAccount', 'String'>;
    readonly email: FieldRef<'SocialAccount', 'String'>;
    readonly name: FieldRef<'SocialAccount', 'String'>;
    readonly profileUrl: FieldRef<'SocialAccount', 'String'>;
    readonly avatarUrl: FieldRef<'SocialAccount', 'String'>;
    readonly accessToken: FieldRef<'SocialAccount', 'String'>;
    readonly refreshToken: FieldRef<'SocialAccount', 'String'>;
    readonly profileData: FieldRef<'SocialAccount', 'String'>;
    readonly createdAt: FieldRef<'SocialAccount', 'DateTime'>;
    readonly updatedAt: FieldRef<'SocialAccount', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SocialAccount findUnique
   */
  export type SocialAccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter, which SocialAccount to fetch.
     */
    where: SocialAccountWhereUniqueInput;
  };

  /**
   * SocialAccount findUniqueOrThrow
   */
  export type SocialAccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter, which SocialAccount to fetch.
     */
    where: SocialAccountWhereUniqueInput;
  };

  /**
   * SocialAccount findFirst
   */
  export type SocialAccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter, which SocialAccount to fetch.
     */
    where?: SocialAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SocialAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SocialAccounts.
     */
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[];
  };

  /**
   * SocialAccount findFirstOrThrow
   */
  export type SocialAccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter, which SocialAccount to fetch.
     */
    where?: SocialAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SocialAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SocialAccounts.
     */
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[];
  };

  /**
   * SocialAccount findMany
   */
  export type SocialAccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter, which SocialAccounts to fetch.
     */
    where?: SocialAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SocialAccounts.
     */
    skip?: number;
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[];
  };

  /**
   * SocialAccount create
   */
  export type SocialAccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a SocialAccount.
     */
    data: XOR<SocialAccountCreateInput, SocialAccountUncheckedCreateInput>;
  };

  /**
   * SocialAccount createMany
   */
  export type SocialAccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SocialAccounts.
     */
    data: SocialAccountCreateManyInput | SocialAccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SocialAccount createManyAndReturn
   */
  export type SocialAccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * The data used to create many SocialAccounts.
     */
    data: SocialAccountCreateManyInput | SocialAccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SocialAccount update
   */
  export type SocialAccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a SocialAccount.
     */
    data: XOR<SocialAccountUpdateInput, SocialAccountUncheckedUpdateInput>;
    /**
     * Choose, which SocialAccount to update.
     */
    where: SocialAccountWhereUniqueInput;
  };

  /**
   * SocialAccount updateMany
   */
  export type SocialAccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SocialAccounts.
     */
    data: XOR<SocialAccountUpdateManyMutationInput, SocialAccountUncheckedUpdateManyInput>;
    /**
     * Filter which SocialAccounts to update
     */
    where?: SocialAccountWhereInput;
    /**
     * Limit how many SocialAccounts to update.
     */
    limit?: number;
  };

  /**
   * SocialAccount updateManyAndReturn
   */
  export type SocialAccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * The data used to update SocialAccounts.
     */
    data: XOR<SocialAccountUpdateManyMutationInput, SocialAccountUncheckedUpdateManyInput>;
    /**
     * Filter which SocialAccounts to update
     */
    where?: SocialAccountWhereInput;
    /**
     * Limit how many SocialAccounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * SocialAccount upsert
   */
  export type SocialAccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the SocialAccount to update in case it exists.
     */
    where: SocialAccountWhereUniqueInput;
    /**
     * In case the SocialAccount found by the `where` argument doesn't exist, create a new SocialAccount with this data.
     */
    create: XOR<SocialAccountCreateInput, SocialAccountUncheckedCreateInput>;
    /**
     * In case the SocialAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialAccountUpdateInput, SocialAccountUncheckedUpdateInput>;
  };

  /**
   * SocialAccount delete
   */
  export type SocialAccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
    /**
     * Filter which SocialAccount to delete.
     */
    where: SocialAccountWhereUniqueInput;
  };

  /**
   * SocialAccount deleteMany
   */
  export type SocialAccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SocialAccounts to delete
     */
    where?: SocialAccountWhereInput;
    /**
     * Limit how many SocialAccounts to delete.
     */
    limit?: number;
  };

  /**
   * SocialAccount without action
   */
  export type SocialAccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const OrganizationScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    domain: 'domain';
    logo: 'logo';
    website: 'website';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    lastTermsPromptedAt: 'lastTermsPromptedAt';
    requiresTermsAcceptance: 'requiresTermsAcceptance';
  };

  export type OrganizationScalarFieldEnum =
    (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    passwordHash: 'passwordHash';
    firstName: 'firstName';
    lastName: 'lastName';
    avatarUrl: 'avatarUrl';
    isActive: 'isActive';
    emailVerified: 'emailVerified';
    emailVerifiedAt: 'emailVerifiedAt';
    lastLoginAt: 'lastLoginAt';
    twoFactorEnabled: 'twoFactorEnabled';
    twoFactorSecret: 'twoFactorSecret';
    phoneNumber: 'phoneNumber';
    phoneCarrier: 'phoneCarrier';
    isSuperAdmin: 'isSuperAdmin';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const MembershipScalarFieldEnum: {
    id: 'id';
    role: 'role';
    joinedAt: 'joinedAt';
    userId: 'userId';
    organizationId: 'organizationId';
  };

  export type MembershipScalarFieldEnum =
    (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum];

  export const InvitationScalarFieldEnum: {
    id: 'id';
    email: 'email';
    role: 'role';
    token: 'token';
    expiresAt: 'expiresAt';
    acceptedAt: 'acceptedAt';
    createdAt: 'createdAt';
    organizationId: 'organizationId';
    invitedById: 'invitedById';
  };

  export type InvitationScalarFieldEnum =
    (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum];

  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id';
    token: 'token';
    email: 'email';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type EmailVerificationTokenScalarFieldEnum =
    (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum];

  export const BillingEventScalarFieldEnum: {
    id: 'id';
    eventType: 'eventType';
    stripeEventId: 'stripeEventId';
    metadata: 'metadata';
    createdAt: 'createdAt';
    organizationId: 'organizationId';
    subscriptionId: 'subscriptionId';
  };

  export type BillingEventScalarFieldEnum =
    (typeof BillingEventScalarFieldEnum)[keyof typeof BillingEventScalarFieldEnum];

  export const SubscriptionScalarFieldEnum: {
    id: 'id';
    plan: 'plan';
    status: 'status';
    trialEndsAt: 'trialEndsAt';
    currentPeriodStart: 'currentPeriodStart';
    currentPeriodEnd: 'currentPeriodEnd';
    canceledAt: 'canceledAt';
    stripeCustomerId: 'stripeCustomerId';
    stripeSubscriptionId: 'stripeSubscriptionId';
    stripePriceId: 'stripePriceId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    maxDatabaseConnections: 'maxDatabaseConnections';
    maxApiCallsPerMonth: 'maxApiCallsPerMonth';
    maxUsersPerOrg: 'maxUsersPerOrg';
    maxWorkflows: 'maxWorkflows';
    organizationId: 'organizationId';
  };

  export type SubscriptionScalarFieldEnum =
    (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum];

  export const InvoiceScalarFieldEnum: {
    id: 'id';
    invoiceNumber: 'invoiceNumber';
    amount: 'amount';
    currency: 'currency';
    status: 'status';
    dueDate: 'dueDate';
    paidAt: 'paidAt';
    stripeInvoiceId: 'stripeInvoiceId';
    stripePaymentIntentId: 'stripePaymentIntentId';
    hostedInvoiceUrl: 'hostedInvoiceUrl';
    createdAt: 'createdAt';
    subscriptionId: 'subscriptionId';
  };

  export type InvoiceScalarFieldEnum =
    (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum];

  export const DatabaseConnectionScalarFieldEnum: {
    id: 'id';
    name: 'name';
    type: 'type';
    host: 'host';
    port: 'port';
    database: 'database';
    username: 'username';
    passwordEncrypted: 'passwordEncrypted';
    sslEnabled: 'sslEnabled';
    isActive: 'isActive';
    lastTestedAt: 'lastTestedAt';
    lastTestResult: 'lastTestResult';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
    databases: 'databases';
  };

  export type DatabaseConnectionScalarFieldEnum =
    (typeof DatabaseConnectionScalarFieldEnum)[keyof typeof DatabaseConnectionScalarFieldEnum];

  export const EndpointScalarFieldEnum: {
    id: 'id';
    path: 'path';
    method: 'method';
    name: 'name';
    description: 'description';
    query: 'query';
    queryParams: 'queryParams';
    bodySchema: 'bodySchema';
    responseSchema: 'responseSchema';
    apiKey: 'apiKey';
    isActive: 'isActive';
    rateLimitPerMinute: 'rateLimitPerMinute';
    requiresAuth: 'requiresAuth';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
    connectionId: 'connectionId';
  };

  export type EndpointScalarFieldEnum =
    (typeof EndpointScalarFieldEnum)[keyof typeof EndpointScalarFieldEnum];

  export const ApiKeyScalarFieldEnum: {
    id: 'id';
    name: 'name';
    keyHash: 'keyHash';
    keyPrefix: 'keyPrefix';
    lastUsedAt: 'lastUsedAt';
    expiresAt: 'expiresAt';
    isActive: 'isActive';
    permissions: 'permissions';
    createdAt: 'createdAt';
    organizationId: 'organizationId';
    createdById: 'createdById';
  };

  export type ApiKeyScalarFieldEnum =
    (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum];

  export const UsageMetricScalarFieldEnum: {
    id: 'id';
    endpoint: 'endpoint';
    method: 'method';
    statusCode: 'statusCode';
    responseTimeMs: 'responseTimeMs';
    timestamp: 'timestamp';
    organizationId: 'organizationId';
    apiKeyId: 'apiKeyId';
  };

  export type UsageMetricScalarFieldEnum =
    (typeof UsageMetricScalarFieldEnum)[keyof typeof UsageMetricScalarFieldEnum];

  export const WorkflowScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    definition: 'definition';
    isActive: 'isActive';
    trigger: 'trigger';
    lastRunAt: 'lastRunAt';
    runCount: 'runCount';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
  };

  export type WorkflowScalarFieldEnum =
    (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum];

  export const WorkflowExecutionScalarFieldEnum: {
    id: 'id';
    status: 'status';
    startedAt: 'startedAt';
    completedAt: 'completedAt';
    error: 'error';
    logs: 'logs';
    workflowId: 'workflowId';
  };

  export type WorkflowExecutionScalarFieldEnum =
    (typeof WorkflowExecutionScalarFieldEnum)[keyof typeof WorkflowExecutionScalarFieldEnum];

  export const WebhookScalarFieldEnum: {
    id: 'id';
    url: 'url';
    events: 'events';
    secret: 'secret';
    isActive: 'isActive';
    lastTriggeredAt: 'lastTriggeredAt';
    failureCount: 'failureCount';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
  };

  export type WebhookScalarFieldEnum =
    (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    metadata: 'metadata';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    timestamp: 'timestamp';
    organizationId: 'organizationId';
    userId: 'userId';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const ServiceScalarFieldEnum: {
    id: 'id';
    name: 'name';
    label: 'label';
    description: 'description';
    host: 'host';
    port: 'port';
    database: 'database';
    username: 'username';
    passwordEncrypted: 'passwordEncrypted';
    isActive: 'isActive';
    failoverHost: 'failoverHost';
    objects: 'objects';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
    connectionId: 'connectionId';
  };

  export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

  export const ApplicationScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    apiKeyHash: 'apiKeyHash';
    apiKeyEncrypted: 'apiKeyEncrypted';
    apiKeyPrefix: 'apiKeyPrefix';
    apiKeyHint: 'apiKeyHint';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
    defaultRoleId: 'defaultRoleId';
  };

  export type ApplicationScalarFieldEnum =
    (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    isActive: 'isActive';
    permissions: 'permissions';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    serviceId: 'serviceId';
    createdBy: 'createdBy';
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    type: 'type';
    priority: 'priority';
    title: 'title';
    message: 'message';
    isRead: 'isRead';
    readAt: 'readAt';
    metadata: 'metadata';
    createdAt: 'createdAt';
    organizationId: 'organizationId';
    userId: 'userId';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const ApiActivityLogScalarFieldEnum: {
    id: 'id';
    requestId: 'requestId';
    timestamp: 'timestamp';
    method: 'method';
    url: 'url';
    endpoint: 'endpoint';
    statusCode: 'statusCode';
    responseTime: 'responseTime';
    userAgent: 'userAgent';
    ipAddress: 'ipAddress';
    category: 'category';
    endpointType: 'endpointType';
    importance: 'importance';
    error: 'error';
    metadata: 'metadata';
    organizationId: 'organizationId';
    userId: 'userId';
    endpointId: 'endpointId';
  };

  export type ApiActivityLogScalarFieldEnum =
    (typeof ApiActivityLogScalarFieldEnum)[keyof typeof ApiActivityLogScalarFieldEnum];

  export const DatabaseObjectScalarFieldEnum: {
    id: 'id';
    name: 'name';
    schema: 'schema';
    type: 'type';
    path: 'path';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
    serviceId: 'serviceId';
  };

  export type DatabaseObjectScalarFieldEnum =
    (typeof DatabaseObjectScalarFieldEnum)[keyof typeof DatabaseObjectScalarFieldEnum];

  export const ExposedEntityScalarFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    connectionId: 'connectionId';
    organizationId: 'organizationId';
    database: 'database';
    schema: 'schema';
    name: 'name';
    type: 'type';
    primaryKey: 'primaryKey';
    allowRead: 'allowRead';
    allowCreate: 'allowCreate';
    allowUpdate: 'allowUpdate';
    allowDelete: 'allowDelete';
    defaultSort: 'defaultSort';
    softDeleteEnabled: 'softDeleteEnabled';
    softDeleteColumn: 'softDeleteColumn';
    softDeleteValue: 'softDeleteValue';
    pathSlug: 'pathSlug';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdBy: 'createdBy';
  };

  export type ExposedEntityScalarFieldEnum =
    (typeof ExposedEntityScalarFieldEnum)[keyof typeof ExposedEntityScalarFieldEnum];

  export const ExposedFieldPolicyScalarFieldEnum: {
    id: 'id';
    exposedEntityId: 'exposedEntityId';
    roleId: 'roleId';
    includeFields: 'includeFields';
    excludeFields: 'excludeFields';
    writeProtected: 'writeProtected';
    maskedFields: 'maskedFields';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ExposedFieldPolicyScalarFieldEnum =
    (typeof ExposedFieldPolicyScalarFieldEnum)[keyof typeof ExposedFieldPolicyScalarFieldEnum];

  export const ExposedRowPolicyScalarFieldEnum: {
    id: 'id';
    exposedEntityId: 'exposedEntityId';
    roleId: 'roleId';
    filterTemplate: 'filterTemplate';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ExposedRowPolicyScalarFieldEnum =
    (typeof ExposedRowPolicyScalarFieldEnum)[keyof typeof ExposedRowPolicyScalarFieldEnum];

  export const TermsAndConditionsScalarFieldEnum: {
    id: 'id';
    version: 'version';
    content: 'content';
    summary: 'summary';
    effectiveDate: 'effectiveDate';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TermsAndConditionsScalarFieldEnum =
    (typeof TermsAndConditionsScalarFieldEnum)[keyof typeof TermsAndConditionsScalarFieldEnum];

  export const TermsAcceptanceScalarFieldEnum: {
    id: 'id';
    acceptedAt: 'acceptedAt';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    geolocation: 'geolocation';
    acceptanceMethod: 'acceptanceMethod';
    organizationId: 'organizationId';
    userId: 'userId';
    termsId: 'termsId';
  };

  export type TermsAcceptanceScalarFieldEnum =
    (typeof TermsAcceptanceScalarFieldEnum)[keyof typeof TermsAcceptanceScalarFieldEnum];

  export const RateLimitConfigScalarFieldEnum: {
    id: 'id';
    name: 'name';
    displayName: 'displayName';
    type: 'type';
    max: 'max';
    windowMs: 'windowMs';
    keyStrategy: 'keyStrategy';
    enabled: 'enabled';
    description: 'description';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    applicationLimits: 'applicationLimits';
    roleLimits: 'roleLimits';
    componentLimits: 'componentLimits';
    changeHistory: 'changeHistory';
    changeReason: 'changeReason';
    organizationId: 'organizationId';
    createdBy: 'createdBy';
    updatedBy: 'updatedBy';
  };

  export type RateLimitConfigScalarFieldEnum =
    (typeof RateLimitConfigScalarFieldEnum)[keyof typeof RateLimitConfigScalarFieldEnum];

  export const RateLimitUsageScalarFieldEnum: {
    id: 'id';
    configName: 'configName';
    limitKey: 'limitKey';
    currentCount: 'currentCount';
    resetAt: 'resetAt';
    blocked: 'blocked';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    organizationId: 'organizationId';
  };

  export type RateLimitUsageScalarFieldEnum =
    (typeof RateLimitUsageScalarFieldEnum)[keyof typeof RateLimitUsageScalarFieldEnum];

  export const SocialAccountScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    provider: 'provider';
    providerId: 'providerId';
    email: 'email';
    name: 'name';
    profileUrl: 'profileUrl';
    avatarUrl: 'avatarUrl';
    accessToken: 'accessToken';
    refreshToken: 'refreshToken';
    profileData: 'profileData';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SocialAccountScalarFieldEnum =
    (typeof SocialAccountScalarFieldEnum)[keyof typeof SocialAccountScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MemberRole'
  >;

  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'MemberRole[]'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubscriptionPlan'
  >;

  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubscriptionPlan[]'
  >;

  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubscriptionStatus'
  >;

  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubscriptionStatus[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InvoiceStatus'
  >;

  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InvoiceStatus[]'
  >;

  /**
   * Reference to a field of type 'DatabaseType'
   */
  export type EnumDatabaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DatabaseType'
  >;

  /**
   * Reference to a field of type 'DatabaseType[]'
   */
  export type ListEnumDatabaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DatabaseType[]'
  >;

  /**
   * Reference to a field of type 'HttpMethod'
   */
  export type EnumHttpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HttpMethod'
  >;

  /**
   * Reference to a field of type 'HttpMethod[]'
   */
  export type ListEnumHttpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HttpMethod[]'
  >;

  /**
   * Reference to a field of type 'ExecutionStatus'
   */
  export type EnumExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ExecutionStatus'
  >;

  /**
   * Reference to a field of type 'ExecutionStatus[]'
   */
  export type ListEnumExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ExecutionStatus[]'
  >;

  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationType'
  >;

  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationType[]'
  >;

  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationPriority'
  >;

  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationPriority[]'
  >;

  /**
   * Reference to a field of type 'ExposedEntityType'
   */
  export type EnumExposedEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ExposedEntityType'
  >;

  /**
   * Reference to a field of type 'ExposedEntityType[]'
   */
  export type ListEnumExposedEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ExposedEntityType[]'
  >;

  /**
   * Reference to a field of type 'AcceptanceMethod'
   */
  export type EnumAcceptanceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AcceptanceMethod'
  >;

  /**
   * Reference to a field of type 'AcceptanceMethod[]'
   */
  export type ListEnumAcceptanceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AcceptanceMethod[]'
  >;

  /**
   * Reference to a field of type 'RateLimitType'
   */
  export type EnumRateLimitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RateLimitType'
  >;

  /**
   * Reference to a field of type 'RateLimitType[]'
   */
  export type ListEnumRateLimitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RateLimitType[]'
  >;

  /**
   * Reference to a field of type 'RateLimitKeyStrategy'
   */
  export type EnumRateLimitKeyStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RateLimitKeyStrategy'
  >;

  /**
   * Reference to a field of type 'RateLimitKeyStrategy[]'
   */
  export type ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RateLimitKeyStrategy[]'
  >;

  /**
   * Deep Input Types
   */

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[];
    OR?: OrganizationWhereInput[];
    NOT?: OrganizationWhereInput | OrganizationWhereInput[];
    id?: StringFilter<'Organization'> | string;
    name?: StringFilter<'Organization'> | string;
    slug?: StringFilter<'Organization'> | string;
    domain?: StringNullableFilter<'Organization'> | string | null;
    logo?: StringNullableFilter<'Organization'> | string | null;
    website?: StringNullableFilter<'Organization'> | string | null;
    createdAt?: DateTimeFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeFilter<'Organization'> | Date | string;
    lastTermsPromptedAt?: DateTimeNullableFilter<'Organization'> | Date | string | null;
    requiresTermsAcceptance?: BoolFilter<'Organization'> | boolean;
    apiActivityLogs?: ApiActivityLogListRelationFilter;
    apiKeys?: ApiKeyListRelationFilter;
    applications?: ApplicationListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    databaseConnections?: DatabaseConnectionListRelationFilter;
    databaseObjects?: DatabaseObjectListRelationFilter;
    endpoints?: EndpointListRelationFilter;
    exposedEntities?: ExposedEntityListRelationFilter;
    invitations?: InvitationListRelationFilter;
    memberships?: MembershipListRelationFilter;
    notifications?: NotificationListRelationFilter;
    roles?: RoleListRelationFilter;
    services?: ServiceListRelationFilter;
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null;
    termsAcceptances?: TermsAcceptanceListRelationFilter;
    usageMetrics?: UsageMetricListRelationFilter;
    webhooks?: WebhookListRelationFilter;
    workflows?: WorkflowListRelationFilter;
    rateLimitConfigs?: RateLimitConfigListRelationFilter;
    rateLimitUsage?: RateLimitUsageListRelationFilter;
    billingEvents?: BillingEventListRelationFilter;
  };

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    domain?: SortOrderInput | SortOrder;
    logo?: SortOrderInput | SortOrder;
    website?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastTermsPromptedAt?: SortOrderInput | SortOrder;
    requiresTermsAcceptance?: SortOrder;
    apiActivityLogs?: ApiActivityLogOrderByRelationAggregateInput;
    apiKeys?: ApiKeyOrderByRelationAggregateInput;
    applications?: ApplicationOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    databaseConnections?: DatabaseConnectionOrderByRelationAggregateInput;
    databaseObjects?: DatabaseObjectOrderByRelationAggregateInput;
    endpoints?: EndpointOrderByRelationAggregateInput;
    exposedEntities?: ExposedEntityOrderByRelationAggregateInput;
    invitations?: InvitationOrderByRelationAggregateInput;
    memberships?: MembershipOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    roles?: RoleOrderByRelationAggregateInput;
    services?: ServiceOrderByRelationAggregateInput;
    subscription?: SubscriptionOrderByWithRelationInput;
    termsAcceptances?: TermsAcceptanceOrderByRelationAggregateInput;
    usageMetrics?: UsageMetricOrderByRelationAggregateInput;
    webhooks?: WebhookOrderByRelationAggregateInput;
    workflows?: WorkflowOrderByRelationAggregateInput;
    rateLimitConfigs?: RateLimitConfigOrderByRelationAggregateInput;
    rateLimitUsage?: RateLimitUsageOrderByRelationAggregateInput;
    billingEvents?: BillingEventOrderByRelationAggregateInput;
  };

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      domain?: string;
      AND?: OrganizationWhereInput | OrganizationWhereInput[];
      OR?: OrganizationWhereInput[];
      NOT?: OrganizationWhereInput | OrganizationWhereInput[];
      name?: StringFilter<'Organization'> | string;
      logo?: StringNullableFilter<'Organization'> | string | null;
      website?: StringNullableFilter<'Organization'> | string | null;
      createdAt?: DateTimeFilter<'Organization'> | Date | string;
      updatedAt?: DateTimeFilter<'Organization'> | Date | string;
      lastTermsPromptedAt?: DateTimeNullableFilter<'Organization'> | Date | string | null;
      requiresTermsAcceptance?: BoolFilter<'Organization'> | boolean;
      apiActivityLogs?: ApiActivityLogListRelationFilter;
      apiKeys?: ApiKeyListRelationFilter;
      applications?: ApplicationListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      databaseConnections?: DatabaseConnectionListRelationFilter;
      databaseObjects?: DatabaseObjectListRelationFilter;
      endpoints?: EndpointListRelationFilter;
      exposedEntities?: ExposedEntityListRelationFilter;
      invitations?: InvitationListRelationFilter;
      memberships?: MembershipListRelationFilter;
      notifications?: NotificationListRelationFilter;
      roles?: RoleListRelationFilter;
      services?: ServiceListRelationFilter;
      subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null;
      termsAcceptances?: TermsAcceptanceListRelationFilter;
      usageMetrics?: UsageMetricListRelationFilter;
      webhooks?: WebhookListRelationFilter;
      workflows?: WorkflowListRelationFilter;
      rateLimitConfigs?: RateLimitConfigListRelationFilter;
      rateLimitUsage?: RateLimitUsageListRelationFilter;
      billingEvents?: BillingEventListRelationFilter;
    },
    'id' | 'slug' | 'domain'
  >;

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    domain?: SortOrderInput | SortOrder;
    logo?: SortOrderInput | SortOrder;
    website?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastTermsPromptedAt?: SortOrderInput | SortOrder;
    requiresTermsAcceptance?: SortOrder;
    _count?: OrganizationCountOrderByAggregateInput;
    _max?: OrganizationMaxOrderByAggregateInput;
    _min?: OrganizationMinOrderByAggregateInput;
  };

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[];
    OR?: OrganizationScalarWhereWithAggregatesInput[];
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Organization'> | string;
    name?: StringWithAggregatesFilter<'Organization'> | string;
    slug?: StringWithAggregatesFilter<'Organization'> | string;
    domain?: StringNullableWithAggregatesFilter<'Organization'> | string | null;
    logo?: StringNullableWithAggregatesFilter<'Organization'> | string | null;
    website?: StringNullableWithAggregatesFilter<'Organization'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
    lastTermsPromptedAt?:
      | DateTimeNullableWithAggregatesFilter<'Organization'>
      | Date
      | string
      | null;
    requiresTermsAcceptance?: BoolWithAggregatesFilter<'Organization'> | boolean;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    passwordHash?: StringNullableFilter<'User'> | string | null;
    firstName?: StringFilter<'User'> | string;
    lastName?: StringFilter<'User'> | string;
    avatarUrl?: StringNullableFilter<'User'> | string | null;
    isActive?: BoolFilter<'User'> | boolean;
    emailVerified?: BoolFilter<'User'> | boolean;
    emailVerifiedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    twoFactorEnabled?: BoolFilter<'User'> | boolean;
    twoFactorSecret?: StringNullableFilter<'User'> | string | null;
    phoneNumber?: StringNullableFilter<'User'> | string | null;
    phoneCarrier?: StringNullableFilter<'User'> | string | null;
    isSuperAdmin?: BoolFilter<'User'> | boolean;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    apiActivityLogs?: ApiActivityLogListRelationFilter;
    apiKeysCreated?: ApiKeyListRelationFilter;
    applicationsCreated?: ApplicationListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    databaseConnectionsCreated?: DatabaseConnectionListRelationFilter;
    endpointsCreated?: EndpointListRelationFilter;
    exposedEntitiesCreated?: ExposedEntityListRelationFilter;
    invitationsSent?: InvitationListRelationFilter;
    memberships?: MembershipListRelationFilter;
    notifications?: NotificationListRelationFilter;
    rolesCreated?: RoleListRelationFilter;
    servicesCreated?: ServiceListRelationFilter;
    termsAcceptances?: TermsAcceptanceListRelationFilter;
    workflowsCreated?: WorkflowListRelationFilter;
    rateLimitCreated?: RateLimitConfigListRelationFilter;
    rateLimitUpdated?: RateLimitConfigListRelationFilter;
    socialAccounts?: SocialAccountListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    emailVerifiedAt?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    phoneCarrier?: SortOrderInput | SortOrder;
    isSuperAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    apiActivityLogs?: ApiActivityLogOrderByRelationAggregateInput;
    apiKeysCreated?: ApiKeyOrderByRelationAggregateInput;
    applicationsCreated?: ApplicationOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    databaseConnectionsCreated?: DatabaseConnectionOrderByRelationAggregateInput;
    endpointsCreated?: EndpointOrderByRelationAggregateInput;
    exposedEntitiesCreated?: ExposedEntityOrderByRelationAggregateInput;
    invitationsSent?: InvitationOrderByRelationAggregateInput;
    memberships?: MembershipOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    rolesCreated?: RoleOrderByRelationAggregateInput;
    servicesCreated?: ServiceOrderByRelationAggregateInput;
    termsAcceptances?: TermsAcceptanceOrderByRelationAggregateInput;
    workflowsCreated?: WorkflowOrderByRelationAggregateInput;
    rateLimitCreated?: RateLimitConfigOrderByRelationAggregateInput;
    rateLimitUpdated?: RateLimitConfigOrderByRelationAggregateInput;
    socialAccounts?: SocialAccountOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      passwordHash?: StringNullableFilter<'User'> | string | null;
      firstName?: StringFilter<'User'> | string;
      lastName?: StringFilter<'User'> | string;
      avatarUrl?: StringNullableFilter<'User'> | string | null;
      isActive?: BoolFilter<'User'> | boolean;
      emailVerified?: BoolFilter<'User'> | boolean;
      emailVerifiedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      twoFactorEnabled?: BoolFilter<'User'> | boolean;
      twoFactorSecret?: StringNullableFilter<'User'> | string | null;
      phoneNumber?: StringNullableFilter<'User'> | string | null;
      phoneCarrier?: StringNullableFilter<'User'> | string | null;
      isSuperAdmin?: BoolFilter<'User'> | boolean;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      apiActivityLogs?: ApiActivityLogListRelationFilter;
      apiKeysCreated?: ApiKeyListRelationFilter;
      applicationsCreated?: ApplicationListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      databaseConnectionsCreated?: DatabaseConnectionListRelationFilter;
      endpointsCreated?: EndpointListRelationFilter;
      exposedEntitiesCreated?: ExposedEntityListRelationFilter;
      invitationsSent?: InvitationListRelationFilter;
      memberships?: MembershipListRelationFilter;
      notifications?: NotificationListRelationFilter;
      rolesCreated?: RoleListRelationFilter;
      servicesCreated?: ServiceListRelationFilter;
      termsAcceptances?: TermsAcceptanceListRelationFilter;
      workflowsCreated?: WorkflowListRelationFilter;
      rateLimitCreated?: RateLimitConfigListRelationFilter;
      rateLimitUpdated?: RateLimitConfigListRelationFilter;
      socialAccounts?: SocialAccountListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    emailVerifiedAt?: SortOrderInput | SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    phoneCarrier?: SortOrderInput | SortOrder;
    isSuperAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    passwordHash?: StringNullableWithAggregatesFilter<'User'> | string | null;
    firstName?: StringWithAggregatesFilter<'User'> | string;
    lastName?: StringWithAggregatesFilter<'User'> | string;
    avatarUrl?: StringNullableWithAggregatesFilter<'User'> | string | null;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    emailVerified?: BoolWithAggregatesFilter<'User'> | boolean;
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    twoFactorEnabled?: BoolWithAggregatesFilter<'User'> | boolean;
    twoFactorSecret?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phoneNumber?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phoneCarrier?: StringNullableWithAggregatesFilter<'User'> | string | null;
    isSuperAdmin?: BoolWithAggregatesFilter<'User'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
  };

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[];
    OR?: MembershipWhereInput[];
    NOT?: MembershipWhereInput | MembershipWhereInput[];
    id?: StringFilter<'Membership'> | string;
    role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
    joinedAt?: DateTimeFilter<'Membership'> | Date | string;
    userId?: StringFilter<'Membership'> | string;
    organizationId?: StringFilter<'Membership'> | string;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type MembershipWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_organizationId?: MembershipUserIdOrganizationIdCompoundUniqueInput;
      AND?: MembershipWhereInput | MembershipWhereInput[];
      OR?: MembershipWhereInput[];
      NOT?: MembershipWhereInput | MembershipWhereInput[];
      role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
      joinedAt?: DateTimeFilter<'Membership'> | Date | string;
      userId?: StringFilter<'Membership'> | string;
      organizationId?: StringFilter<'Membership'> | string;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'userId_organizationId'
  >;

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    _count?: MembershipCountOrderByAggregateInput;
    _max?: MembershipMaxOrderByAggregateInput;
    _min?: MembershipMinOrderByAggregateInput;
  };

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[];
    OR?: MembershipScalarWhereWithAggregatesInput[];
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Membership'> | string;
    role?: EnumMemberRoleWithAggregatesFilter<'Membership'> | $Enums.MemberRole;
    joinedAt?: DateTimeWithAggregatesFilter<'Membership'> | Date | string;
    userId?: StringWithAggregatesFilter<'Membership'> | string;
    organizationId?: StringWithAggregatesFilter<'Membership'> | string;
  };

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[];
    OR?: InvitationWhereInput[];
    NOT?: InvitationWhereInput | InvitationWhereInput[];
    id?: StringFilter<'Invitation'> | string;
    email?: StringFilter<'Invitation'> | string;
    role?: EnumMemberRoleFilter<'Invitation'> | $Enums.MemberRole;
    token?: StringFilter<'Invitation'> | string;
    expiresAt?: DateTimeFilter<'Invitation'> | Date | string;
    acceptedAt?: DateTimeNullableFilter<'Invitation'> | Date | string | null;
    createdAt?: DateTimeFilter<'Invitation'> | Date | string;
    organizationId?: StringFilter<'Invitation'> | string;
    invitedById?: StringFilter<'Invitation'> | string;
    invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    role?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    acceptedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    invitedById?: SortOrder;
    invitedBy?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type InvitationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: InvitationWhereInput | InvitationWhereInput[];
      OR?: InvitationWhereInput[];
      NOT?: InvitationWhereInput | InvitationWhereInput[];
      email?: StringFilter<'Invitation'> | string;
      role?: EnumMemberRoleFilter<'Invitation'> | $Enums.MemberRole;
      expiresAt?: DateTimeFilter<'Invitation'> | Date | string;
      acceptedAt?: DateTimeNullableFilter<'Invitation'> | Date | string | null;
      createdAt?: DateTimeFilter<'Invitation'> | Date | string;
      organizationId?: StringFilter<'Invitation'> | string;
      invitedById?: StringFilter<'Invitation'> | string;
      invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'token'
  >;

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    role?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    acceptedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    invitedById?: SortOrder;
    _count?: InvitationCountOrderByAggregateInput;
    _max?: InvitationMaxOrderByAggregateInput;
    _min?: InvitationMinOrderByAggregateInput;
  };

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[];
    OR?: InvitationScalarWhereWithAggregatesInput[];
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Invitation'> | string;
    email?: StringWithAggregatesFilter<'Invitation'> | string;
    role?: EnumMemberRoleWithAggregatesFilter<'Invitation'> | $Enums.MemberRole;
    token?: StringWithAggregatesFilter<'Invitation'> | string;
    expiresAt?: DateTimeWithAggregatesFilter<'Invitation'> | Date | string;
    acceptedAt?: DateTimeNullableWithAggregatesFilter<'Invitation'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Invitation'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Invitation'> | string;
    invitedById?: StringWithAggregatesFilter<'Invitation'> | string;
  };

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    OR?: EmailVerificationTokenWhereInput[];
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    id?: StringFilter<'EmailVerificationToken'> | string;
    token?: StringFilter<'EmailVerificationToken'> | string;
    email?: StringFilter<'EmailVerificationToken'> | string;
    expiresAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
    createdAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
  };

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder;
    token?: SortOrder;
    email?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
      OR?: EmailVerificationTokenWhereInput[];
      NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
      email?: StringFilter<'EmailVerificationToken'> | string;
      expiresAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
      createdAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
    },
    'id' | 'token'
  >;

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    token?: SortOrder;
    email?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: EmailVerificationTokenCountOrderByAggregateInput;
    _max?: EmailVerificationTokenMaxOrderByAggregateInput;
    _min?: EmailVerificationTokenMinOrderByAggregateInput;
  };

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    token?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    email?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    expiresAt?: DateTimeWithAggregatesFilter<'EmailVerificationToken'> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<'EmailVerificationToken'> | Date | string;
  };

  export type BillingEventWhereInput = {
    AND?: BillingEventWhereInput | BillingEventWhereInput[];
    OR?: BillingEventWhereInput[];
    NOT?: BillingEventWhereInput | BillingEventWhereInput[];
    id?: StringFilter<'BillingEvent'> | string;
    eventType?: StringFilter<'BillingEvent'> | string;
    stripeEventId?: StringFilter<'BillingEvent'> | string;
    metadata?: JsonFilter<'BillingEvent'>;
    createdAt?: DateTimeFilter<'BillingEvent'> | Date | string;
    organizationId?: StringNullableFilter<'BillingEvent'> | string | null;
    subscriptionId?: StringNullableFilter<'BillingEvent'> | string | null;
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null;
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null;
  };

  export type BillingEventOrderByWithRelationInput = {
    id?: SortOrder;
    eventType?: SortOrder;
    stripeEventId?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    subscriptionId?: SortOrderInput | SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    subscription?: SubscriptionOrderByWithRelationInput;
  };

  export type BillingEventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      stripeEventId?: string;
      AND?: BillingEventWhereInput | BillingEventWhereInput[];
      OR?: BillingEventWhereInput[];
      NOT?: BillingEventWhereInput | BillingEventWhereInput[];
      eventType?: StringFilter<'BillingEvent'> | string;
      metadata?: JsonFilter<'BillingEvent'>;
      createdAt?: DateTimeFilter<'BillingEvent'> | Date | string;
      organizationId?: StringNullableFilter<'BillingEvent'> | string | null;
      subscriptionId?: StringNullableFilter<'BillingEvent'> | string | null;
      organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null;
      subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null;
    },
    'id' | 'stripeEventId'
  >;

  export type BillingEventOrderByWithAggregationInput = {
    id?: SortOrder;
    eventType?: SortOrder;
    stripeEventId?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    subscriptionId?: SortOrderInput | SortOrder;
    _count?: BillingEventCountOrderByAggregateInput;
    _max?: BillingEventMaxOrderByAggregateInput;
    _min?: BillingEventMinOrderByAggregateInput;
  };

  export type BillingEventScalarWhereWithAggregatesInput = {
    AND?: BillingEventScalarWhereWithAggregatesInput | BillingEventScalarWhereWithAggregatesInput[];
    OR?: BillingEventScalarWhereWithAggregatesInput[];
    NOT?: BillingEventScalarWhereWithAggregatesInput | BillingEventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'BillingEvent'> | string;
    eventType?: StringWithAggregatesFilter<'BillingEvent'> | string;
    stripeEventId?: StringWithAggregatesFilter<'BillingEvent'> | string;
    metadata?: JsonWithAggregatesFilter<'BillingEvent'>;
    createdAt?: DateTimeWithAggregatesFilter<'BillingEvent'> | Date | string;
    organizationId?: StringNullableWithAggregatesFilter<'BillingEvent'> | string | null;
    subscriptionId?: StringNullableWithAggregatesFilter<'BillingEvent'> | string | null;
  };

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[];
    OR?: SubscriptionWhereInput[];
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[];
    id?: StringFilter<'Subscription'> | string;
    plan?: EnumSubscriptionPlanFilter<'Subscription'> | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFilter<'Subscription'> | $Enums.SubscriptionStatus;
    trialEndsAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
    currentPeriodStart?: DateTimeFilter<'Subscription'> | Date | string;
    currentPeriodEnd?: DateTimeFilter<'Subscription'> | Date | string;
    canceledAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
    stripeCustomerId?: StringNullableFilter<'Subscription'> | string | null;
    stripeSubscriptionId?: StringNullableFilter<'Subscription'> | string | null;
    stripePriceId?: StringNullableFilter<'Subscription'> | string | null;
    createdAt?: DateTimeFilter<'Subscription'> | Date | string;
    updatedAt?: DateTimeFilter<'Subscription'> | Date | string;
    maxDatabaseConnections?: IntFilter<'Subscription'> | number;
    maxApiCallsPerMonth?: IntFilter<'Subscription'> | number;
    maxUsersPerOrg?: IntFilter<'Subscription'> | number;
    maxWorkflows?: IntFilter<'Subscription'> | number;
    organizationId?: StringFilter<'Subscription'> | string;
    invoices?: InvoiceListRelationFilter;
    billingEvents?: BillingEventListRelationFilter;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder;
    plan?: SortOrder;
    status?: SortOrder;
    trialEndsAt?: SortOrderInput | SortOrder;
    currentPeriodStart?: SortOrder;
    currentPeriodEnd?: SortOrder;
    canceledAt?: SortOrderInput | SortOrder;
    stripeCustomerId?: SortOrderInput | SortOrder;
    stripeSubscriptionId?: SortOrderInput | SortOrder;
    stripePriceId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
    organizationId?: SortOrder;
    invoices?: InvoiceOrderByRelationAggregateInput;
    billingEvents?: BillingEventOrderByRelationAggregateInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      stripeCustomerId?: string;
      stripeSubscriptionId?: string;
      organizationId?: string;
      AND?: SubscriptionWhereInput | SubscriptionWhereInput[];
      OR?: SubscriptionWhereInput[];
      NOT?: SubscriptionWhereInput | SubscriptionWhereInput[];
      plan?: EnumSubscriptionPlanFilter<'Subscription'> | $Enums.SubscriptionPlan;
      status?: EnumSubscriptionStatusFilter<'Subscription'> | $Enums.SubscriptionStatus;
      trialEndsAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
      currentPeriodStart?: DateTimeFilter<'Subscription'> | Date | string;
      currentPeriodEnd?: DateTimeFilter<'Subscription'> | Date | string;
      canceledAt?: DateTimeNullableFilter<'Subscription'> | Date | string | null;
      stripePriceId?: StringNullableFilter<'Subscription'> | string | null;
      createdAt?: DateTimeFilter<'Subscription'> | Date | string;
      updatedAt?: DateTimeFilter<'Subscription'> | Date | string;
      maxDatabaseConnections?: IntFilter<'Subscription'> | number;
      maxApiCallsPerMonth?: IntFilter<'Subscription'> | number;
      maxUsersPerOrg?: IntFilter<'Subscription'> | number;
      maxWorkflows?: IntFilter<'Subscription'> | number;
      invoices?: InvoiceListRelationFilter;
      billingEvents?: BillingEventListRelationFilter;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'stripeCustomerId' | 'stripeSubscriptionId' | 'organizationId'
  >;

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder;
    plan?: SortOrder;
    status?: SortOrder;
    trialEndsAt?: SortOrderInput | SortOrder;
    currentPeriodStart?: SortOrder;
    currentPeriodEnd?: SortOrder;
    canceledAt?: SortOrderInput | SortOrder;
    stripeCustomerId?: SortOrderInput | SortOrder;
    stripeSubscriptionId?: SortOrderInput | SortOrder;
    stripePriceId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
    organizationId?: SortOrder;
    _count?: SubscriptionCountOrderByAggregateInput;
    _avg?: SubscriptionAvgOrderByAggregateInput;
    _max?: SubscriptionMaxOrderByAggregateInput;
    _min?: SubscriptionMinOrderByAggregateInput;
    _sum?: SubscriptionSumOrderByAggregateInput;
  };

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[];
    OR?: SubscriptionScalarWhereWithAggregatesInput[];
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Subscription'> | string;
    plan?: EnumSubscriptionPlanWithAggregatesFilter<'Subscription'> | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusWithAggregatesFilter<'Subscription'> | $Enums.SubscriptionStatus;
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<'Subscription'> | Date | string | null;
    currentPeriodStart?: DateTimeWithAggregatesFilter<'Subscription'> | Date | string;
    currentPeriodEnd?: DateTimeWithAggregatesFilter<'Subscription'> | Date | string;
    canceledAt?: DateTimeNullableWithAggregatesFilter<'Subscription'> | Date | string | null;
    stripeCustomerId?: StringNullableWithAggregatesFilter<'Subscription'> | string | null;
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<'Subscription'> | string | null;
    stripePriceId?: StringNullableWithAggregatesFilter<'Subscription'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Subscription'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Subscription'> | Date | string;
    maxDatabaseConnections?: IntWithAggregatesFilter<'Subscription'> | number;
    maxApiCallsPerMonth?: IntWithAggregatesFilter<'Subscription'> | number;
    maxUsersPerOrg?: IntWithAggregatesFilter<'Subscription'> | number;
    maxWorkflows?: IntWithAggregatesFilter<'Subscription'> | number;
    organizationId?: StringWithAggregatesFilter<'Subscription'> | string;
  };

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[];
    OR?: InvoiceWhereInput[];
    NOT?: InvoiceWhereInput | InvoiceWhereInput[];
    id?: StringFilter<'Invoice'> | string;
    invoiceNumber?: StringFilter<'Invoice'> | string;
    amount?: FloatFilter<'Invoice'> | number;
    currency?: StringFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
    dueDate?: DateTimeFilter<'Invoice'> | Date | string;
    paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    stripeInvoiceId?: StringNullableFilter<'Invoice'> | string | null;
    stripePaymentIntentId?: StringNullableFilter<'Invoice'> | string | null;
    hostedInvoiceUrl?: StringNullableFilter<'Invoice'> | string | null;
    createdAt?: DateTimeFilter<'Invoice'> | Date | string;
    subscriptionId?: StringFilter<'Invoice'> | string;
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>;
  };

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidAt?: SortOrderInput | SortOrder;
    stripeInvoiceId?: SortOrderInput | SortOrder;
    stripePaymentIntentId?: SortOrderInput | SortOrder;
    hostedInvoiceUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    subscriptionId?: SortOrder;
    subscription?: SubscriptionOrderByWithRelationInput;
  };

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      invoiceNumber?: string;
      stripeInvoiceId?: string;
      AND?: InvoiceWhereInput | InvoiceWhereInput[];
      OR?: InvoiceWhereInput[];
      NOT?: InvoiceWhereInput | InvoiceWhereInput[];
      amount?: FloatFilter<'Invoice'> | number;
      currency?: StringFilter<'Invoice'> | string;
      status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
      dueDate?: DateTimeFilter<'Invoice'> | Date | string;
      paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
      stripePaymentIntentId?: StringNullableFilter<'Invoice'> | string | null;
      hostedInvoiceUrl?: StringNullableFilter<'Invoice'> | string | null;
      createdAt?: DateTimeFilter<'Invoice'> | Date | string;
      subscriptionId?: StringFilter<'Invoice'> | string;
      subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>;
    },
    'id' | 'invoiceNumber' | 'stripeInvoiceId'
  >;

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidAt?: SortOrderInput | SortOrder;
    stripeInvoiceId?: SortOrderInput | SortOrder;
    stripePaymentIntentId?: SortOrderInput | SortOrder;
    hostedInvoiceUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    subscriptionId?: SortOrder;
    _count?: InvoiceCountOrderByAggregateInput;
    _avg?: InvoiceAvgOrderByAggregateInput;
    _max?: InvoiceMaxOrderByAggregateInput;
    _min?: InvoiceMinOrderByAggregateInput;
    _sum?: InvoiceSumOrderByAggregateInput;
  };

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[];
    OR?: InvoiceScalarWhereWithAggregatesInput[];
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Invoice'> | string;
    invoiceNumber?: StringWithAggregatesFilter<'Invoice'> | string;
    amount?: FloatWithAggregatesFilter<'Invoice'> | number;
    currency?: StringWithAggregatesFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusWithAggregatesFilter<'Invoice'> | $Enums.InvoiceStatus;
    dueDate?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    paidAt?: DateTimeNullableWithAggregatesFilter<'Invoice'> | Date | string | null;
    stripeInvoiceId?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    hostedInvoiceUrl?: StringNullableWithAggregatesFilter<'Invoice'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Invoice'> | Date | string;
    subscriptionId?: StringWithAggregatesFilter<'Invoice'> | string;
  };

  export type DatabaseConnectionWhereInput = {
    AND?: DatabaseConnectionWhereInput | DatabaseConnectionWhereInput[];
    OR?: DatabaseConnectionWhereInput[];
    NOT?: DatabaseConnectionWhereInput | DatabaseConnectionWhereInput[];
    id?: StringFilter<'DatabaseConnection'> | string;
    name?: StringFilter<'DatabaseConnection'> | string;
    type?: EnumDatabaseTypeFilter<'DatabaseConnection'> | $Enums.DatabaseType;
    host?: StringFilter<'DatabaseConnection'> | string;
    port?: IntFilter<'DatabaseConnection'> | number;
    database?: StringFilter<'DatabaseConnection'> | string;
    username?: StringFilter<'DatabaseConnection'> | string;
    passwordEncrypted?: StringFilter<'DatabaseConnection'> | string;
    sslEnabled?: BoolFilter<'DatabaseConnection'> | boolean;
    isActive?: BoolFilter<'DatabaseConnection'> | boolean;
    lastTestedAt?: DateTimeNullableFilter<'DatabaseConnection'> | Date | string | null;
    lastTestResult?: BoolNullableFilter<'DatabaseConnection'> | boolean | null;
    createdAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
    updatedAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
    organizationId?: StringFilter<'DatabaseConnection'> | string;
    createdBy?: StringNullableFilter<'DatabaseConnection'> | string | null;
    databases?: JsonNullableFilter<'DatabaseConnection'>;
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    endpoints?: EndpointListRelationFilter;
    exposedEntities?: ExposedEntityListRelationFilter;
    services?: ServiceListRelationFilter;
  };

  export type DatabaseConnectionOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    sslEnabled?: SortOrder;
    isActive?: SortOrder;
    lastTestedAt?: SortOrderInput | SortOrder;
    lastTestResult?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    databases?: SortOrderInput | SortOrder;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    endpoints?: EndpointOrderByRelationAggregateInput;
    exposedEntities?: ExposedEntityOrderByRelationAggregateInput;
    services?: ServiceOrderByRelationAggregateInput;
  };

  export type DatabaseConnectionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_name?: DatabaseConnectionOrganizationIdNameCompoundUniqueInput;
      AND?: DatabaseConnectionWhereInput | DatabaseConnectionWhereInput[];
      OR?: DatabaseConnectionWhereInput[];
      NOT?: DatabaseConnectionWhereInput | DatabaseConnectionWhereInput[];
      name?: StringFilter<'DatabaseConnection'> | string;
      type?: EnumDatabaseTypeFilter<'DatabaseConnection'> | $Enums.DatabaseType;
      host?: StringFilter<'DatabaseConnection'> | string;
      port?: IntFilter<'DatabaseConnection'> | number;
      database?: StringFilter<'DatabaseConnection'> | string;
      username?: StringFilter<'DatabaseConnection'> | string;
      passwordEncrypted?: StringFilter<'DatabaseConnection'> | string;
      sslEnabled?: BoolFilter<'DatabaseConnection'> | boolean;
      isActive?: BoolFilter<'DatabaseConnection'> | boolean;
      lastTestedAt?: DateTimeNullableFilter<'DatabaseConnection'> | Date | string | null;
      lastTestResult?: BoolNullableFilter<'DatabaseConnection'> | boolean | null;
      createdAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
      updatedAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
      organizationId?: StringFilter<'DatabaseConnection'> | string;
      createdBy?: StringNullableFilter<'DatabaseConnection'> | string | null;
      databases?: JsonNullableFilter<'DatabaseConnection'>;
      creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      endpoints?: EndpointListRelationFilter;
      exposedEntities?: ExposedEntityListRelationFilter;
      services?: ServiceListRelationFilter;
    },
    'id' | 'organizationId_name'
  >;

  export type DatabaseConnectionOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    sslEnabled?: SortOrder;
    isActive?: SortOrder;
    lastTestedAt?: SortOrderInput | SortOrder;
    lastTestResult?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    databases?: SortOrderInput | SortOrder;
    _count?: DatabaseConnectionCountOrderByAggregateInput;
    _avg?: DatabaseConnectionAvgOrderByAggregateInput;
    _max?: DatabaseConnectionMaxOrderByAggregateInput;
    _min?: DatabaseConnectionMinOrderByAggregateInput;
    _sum?: DatabaseConnectionSumOrderByAggregateInput;
  };

  export type DatabaseConnectionScalarWhereWithAggregatesInput = {
    AND?:
      | DatabaseConnectionScalarWhereWithAggregatesInput
      | DatabaseConnectionScalarWhereWithAggregatesInput[];
    OR?: DatabaseConnectionScalarWhereWithAggregatesInput[];
    NOT?:
      | DatabaseConnectionScalarWhereWithAggregatesInput
      | DatabaseConnectionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    name?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    type?: EnumDatabaseTypeWithAggregatesFilter<'DatabaseConnection'> | $Enums.DatabaseType;
    host?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    port?: IntWithAggregatesFilter<'DatabaseConnection'> | number;
    database?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    username?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    passwordEncrypted?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    sslEnabled?: BoolWithAggregatesFilter<'DatabaseConnection'> | boolean;
    isActive?: BoolWithAggregatesFilter<'DatabaseConnection'> | boolean;
    lastTestedAt?:
      | DateTimeNullableWithAggregatesFilter<'DatabaseConnection'>
      | Date
      | string
      | null;
    lastTestResult?: BoolNullableWithAggregatesFilter<'DatabaseConnection'> | boolean | null;
    createdAt?: DateTimeWithAggregatesFilter<'DatabaseConnection'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'DatabaseConnection'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'DatabaseConnection'> | string;
    createdBy?: StringNullableWithAggregatesFilter<'DatabaseConnection'> | string | null;
    databases?: JsonNullableWithAggregatesFilter<'DatabaseConnection'>;
  };

  export type EndpointWhereInput = {
    AND?: EndpointWhereInput | EndpointWhereInput[];
    OR?: EndpointWhereInput[];
    NOT?: EndpointWhereInput | EndpointWhereInput[];
    id?: StringFilter<'Endpoint'> | string;
    path?: StringFilter<'Endpoint'> | string;
    method?: EnumHttpMethodFilter<'Endpoint'> | $Enums.HttpMethod;
    name?: StringFilter<'Endpoint'> | string;
    description?: StringNullableFilter<'Endpoint'> | string | null;
    query?: StringFilter<'Endpoint'> | string;
    queryParams?: JsonNullableFilter<'Endpoint'>;
    bodySchema?: JsonNullableFilter<'Endpoint'>;
    responseSchema?: JsonNullableFilter<'Endpoint'>;
    apiKey?: StringFilter<'Endpoint'> | string;
    isActive?: BoolFilter<'Endpoint'> | boolean;
    rateLimitPerMinute?: IntFilter<'Endpoint'> | number;
    requiresAuth?: BoolFilter<'Endpoint'> | boolean;
    createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
    organizationId?: StringFilter<'Endpoint'> | string;
    createdBy?: StringFilter<'Endpoint'> | string;
    connectionId?: StringNullableFilter<'Endpoint'> | string | null;
    usageLogs?: ApiActivityLogListRelationFilter;
    connection?: XOR<
      DatabaseConnectionNullableScalarRelationFilter,
      DatabaseConnectionWhereInput
    > | null;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type EndpointOrderByWithRelationInput = {
    id?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    query?: SortOrder;
    queryParams?: SortOrderInput | SortOrder;
    bodySchema?: SortOrderInput | SortOrder;
    responseSchema?: SortOrderInput | SortOrder;
    apiKey?: SortOrder;
    isActive?: SortOrder;
    rateLimitPerMinute?: SortOrder;
    requiresAuth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    usageLogs?: ApiActivityLogOrderByRelationAggregateInput;
    connection?: DatabaseConnectionOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type EndpointWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      apiKey?: string;
      connectionId_path_method?: EndpointConnectionIdPathMethodCompoundUniqueInput;
      AND?: EndpointWhereInput | EndpointWhereInput[];
      OR?: EndpointWhereInput[];
      NOT?: EndpointWhereInput | EndpointWhereInput[];
      path?: StringFilter<'Endpoint'> | string;
      method?: EnumHttpMethodFilter<'Endpoint'> | $Enums.HttpMethod;
      description?: StringNullableFilter<'Endpoint'> | string | null;
      query?: StringFilter<'Endpoint'> | string;
      queryParams?: JsonNullableFilter<'Endpoint'>;
      bodySchema?: JsonNullableFilter<'Endpoint'>;
      responseSchema?: JsonNullableFilter<'Endpoint'>;
      isActive?: BoolFilter<'Endpoint'> | boolean;
      rateLimitPerMinute?: IntFilter<'Endpoint'> | number;
      requiresAuth?: BoolFilter<'Endpoint'> | boolean;
      createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
      updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
      organizationId?: StringFilter<'Endpoint'> | string;
      createdBy?: StringFilter<'Endpoint'> | string;
      connectionId?: StringNullableFilter<'Endpoint'> | string | null;
      usageLogs?: ApiActivityLogListRelationFilter;
      connection?: XOR<
        DatabaseConnectionNullableScalarRelationFilter,
        DatabaseConnectionWhereInput
      > | null;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'name' | 'apiKey' | 'connectionId_path_method'
  >;

  export type EndpointOrderByWithAggregationInput = {
    id?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    query?: SortOrder;
    queryParams?: SortOrderInput | SortOrder;
    bodySchema?: SortOrderInput | SortOrder;
    responseSchema?: SortOrderInput | SortOrder;
    apiKey?: SortOrder;
    isActive?: SortOrder;
    rateLimitPerMinute?: SortOrder;
    requiresAuth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    _count?: EndpointCountOrderByAggregateInput;
    _avg?: EndpointAvgOrderByAggregateInput;
    _max?: EndpointMaxOrderByAggregateInput;
    _min?: EndpointMinOrderByAggregateInput;
    _sum?: EndpointSumOrderByAggregateInput;
  };

  export type EndpointScalarWhereWithAggregatesInput = {
    AND?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[];
    OR?: EndpointScalarWhereWithAggregatesInput[];
    NOT?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Endpoint'> | string;
    path?: StringWithAggregatesFilter<'Endpoint'> | string;
    method?: EnumHttpMethodWithAggregatesFilter<'Endpoint'> | $Enums.HttpMethod;
    name?: StringWithAggregatesFilter<'Endpoint'> | string;
    description?: StringNullableWithAggregatesFilter<'Endpoint'> | string | null;
    query?: StringWithAggregatesFilter<'Endpoint'> | string;
    queryParams?: JsonNullableWithAggregatesFilter<'Endpoint'>;
    bodySchema?: JsonNullableWithAggregatesFilter<'Endpoint'>;
    responseSchema?: JsonNullableWithAggregatesFilter<'Endpoint'>;
    apiKey?: StringWithAggregatesFilter<'Endpoint'> | string;
    isActive?: BoolWithAggregatesFilter<'Endpoint'> | boolean;
    rateLimitPerMinute?: IntWithAggregatesFilter<'Endpoint'> | number;
    requiresAuth?: BoolWithAggregatesFilter<'Endpoint'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Endpoint'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Endpoint'> | string;
    createdBy?: StringWithAggregatesFilter<'Endpoint'> | string;
    connectionId?: StringNullableWithAggregatesFilter<'Endpoint'> | string | null;
  };

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[];
    OR?: ApiKeyWhereInput[];
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[];
    id?: StringFilter<'ApiKey'> | string;
    name?: StringFilter<'ApiKey'> | string;
    keyHash?: StringFilter<'ApiKey'> | string;
    keyPrefix?: StringFilter<'ApiKey'> | string;
    lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    isActive?: BoolFilter<'ApiKey'> | boolean;
    permissions?: StringNullableListFilter<'ApiKey'>;
    createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
    organizationId?: StringFilter<'ApiKey'> | string;
    createdById?: StringFilter<'ApiKey'> | string;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    usageMetrics?: UsageMetricListRelationFilter;
  };

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    keyHash?: SortOrder;
    keyPrefix?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    createdById?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    usageMetrics?: UsageMetricOrderByRelationAggregateInput;
  };

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      keyHash?: string;
      AND?: ApiKeyWhereInput | ApiKeyWhereInput[];
      OR?: ApiKeyWhereInput[];
      NOT?: ApiKeyWhereInput | ApiKeyWhereInput[];
      name?: StringFilter<'ApiKey'> | string;
      keyPrefix?: StringFilter<'ApiKey'> | string;
      lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
      expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
      isActive?: BoolFilter<'ApiKey'> | boolean;
      permissions?: StringNullableListFilter<'ApiKey'>;
      createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
      organizationId?: StringFilter<'ApiKey'> | string;
      createdById?: StringFilter<'ApiKey'> | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      usageMetrics?: UsageMetricListRelationFilter;
    },
    'id' | 'keyHash'
  >;

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    keyHash?: SortOrder;
    keyPrefix?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    createdById?: SortOrder;
    _count?: ApiKeyCountOrderByAggregateInput;
    _max?: ApiKeyMaxOrderByAggregateInput;
    _min?: ApiKeyMinOrderByAggregateInput;
  };

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[];
    OR?: ApiKeyScalarWhereWithAggregatesInput[];
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApiKey'> | string;
    name?: StringWithAggregatesFilter<'ApiKey'> | string;
    keyHash?: StringWithAggregatesFilter<'ApiKey'> | string;
    keyPrefix?: StringWithAggregatesFilter<'ApiKey'> | string;
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableWithAggregatesFilter<'ApiKey'> | Date | string | null;
    isActive?: BoolWithAggregatesFilter<'ApiKey'> | boolean;
    permissions?: StringNullableListFilter<'ApiKey'>;
    createdAt?: DateTimeWithAggregatesFilter<'ApiKey'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'ApiKey'> | string;
    createdById?: StringWithAggregatesFilter<'ApiKey'> | string;
  };

  export type UsageMetricWhereInput = {
    AND?: UsageMetricWhereInput | UsageMetricWhereInput[];
    OR?: UsageMetricWhereInput[];
    NOT?: UsageMetricWhereInput | UsageMetricWhereInput[];
    id?: StringFilter<'UsageMetric'> | string;
    endpoint?: StringFilter<'UsageMetric'> | string;
    method?: StringFilter<'UsageMetric'> | string;
    statusCode?: IntFilter<'UsageMetric'> | number;
    responseTimeMs?: IntFilter<'UsageMetric'> | number;
    timestamp?: DateTimeFilter<'UsageMetric'> | Date | string;
    organizationId?: StringFilter<'UsageMetric'> | string;
    apiKeyId?: StringNullableFilter<'UsageMetric'> | string | null;
    apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type UsageMetricOrderByWithRelationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    apiKeyId?: SortOrderInput | SortOrder;
    apiKey?: ApiKeyOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type UsageMetricWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: UsageMetricWhereInput | UsageMetricWhereInput[];
      OR?: UsageMetricWhereInput[];
      NOT?: UsageMetricWhereInput | UsageMetricWhereInput[];
      endpoint?: StringFilter<'UsageMetric'> | string;
      method?: StringFilter<'UsageMetric'> | string;
      statusCode?: IntFilter<'UsageMetric'> | number;
      responseTimeMs?: IntFilter<'UsageMetric'> | number;
      timestamp?: DateTimeFilter<'UsageMetric'> | Date | string;
      organizationId?: StringFilter<'UsageMetric'> | string;
      apiKeyId?: StringNullableFilter<'UsageMetric'> | string | null;
      apiKey?: XOR<ApiKeyNullableScalarRelationFilter, ApiKeyWhereInput> | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id'
  >;

  export type UsageMetricOrderByWithAggregationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    apiKeyId?: SortOrderInput | SortOrder;
    _count?: UsageMetricCountOrderByAggregateInput;
    _avg?: UsageMetricAvgOrderByAggregateInput;
    _max?: UsageMetricMaxOrderByAggregateInput;
    _min?: UsageMetricMinOrderByAggregateInput;
    _sum?: UsageMetricSumOrderByAggregateInput;
  };

  export type UsageMetricScalarWhereWithAggregatesInput = {
    AND?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[];
    OR?: UsageMetricScalarWhereWithAggregatesInput[];
    NOT?: UsageMetricScalarWhereWithAggregatesInput | UsageMetricScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UsageMetric'> | string;
    endpoint?: StringWithAggregatesFilter<'UsageMetric'> | string;
    method?: StringWithAggregatesFilter<'UsageMetric'> | string;
    statusCode?: IntWithAggregatesFilter<'UsageMetric'> | number;
    responseTimeMs?: IntWithAggregatesFilter<'UsageMetric'> | number;
    timestamp?: DateTimeWithAggregatesFilter<'UsageMetric'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'UsageMetric'> | string;
    apiKeyId?: StringNullableWithAggregatesFilter<'UsageMetric'> | string | null;
  };

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[];
    OR?: WorkflowWhereInput[];
    NOT?: WorkflowWhereInput | WorkflowWhereInput[];
    id?: StringFilter<'Workflow'> | string;
    name?: StringFilter<'Workflow'> | string;
    description?: StringNullableFilter<'Workflow'> | string | null;
    definition?: JsonFilter<'Workflow'>;
    isActive?: BoolFilter<'Workflow'> | boolean;
    trigger?: JsonFilter<'Workflow'>;
    lastRunAt?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    runCount?: IntFilter<'Workflow'> | number;
    createdAt?: DateTimeFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
    organizationId?: StringFilter<'Workflow'> | string;
    createdBy?: StringNullableFilter<'Workflow'> | string | null;
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    executions?: WorkflowExecutionListRelationFilter;
  };

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    definition?: SortOrder;
    isActive?: SortOrder;
    trigger?: SortOrder;
    lastRunAt?: SortOrderInput | SortOrder;
    runCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    executions?: WorkflowExecutionOrderByRelationAggregateInput;
  };

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WorkflowWhereInput | WorkflowWhereInput[];
      OR?: WorkflowWhereInput[];
      NOT?: WorkflowWhereInput | WorkflowWhereInput[];
      name?: StringFilter<'Workflow'> | string;
      description?: StringNullableFilter<'Workflow'> | string | null;
      definition?: JsonFilter<'Workflow'>;
      isActive?: BoolFilter<'Workflow'> | boolean;
      trigger?: JsonFilter<'Workflow'>;
      lastRunAt?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
      runCount?: IntFilter<'Workflow'> | number;
      createdAt?: DateTimeFilter<'Workflow'> | Date | string;
      updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
      organizationId?: StringFilter<'Workflow'> | string;
      createdBy?: StringNullableFilter<'Workflow'> | string | null;
      creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      executions?: WorkflowExecutionListRelationFilter;
    },
    'id'
  >;

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    definition?: SortOrder;
    isActive?: SortOrder;
    trigger?: SortOrder;
    lastRunAt?: SortOrderInput | SortOrder;
    runCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    _count?: WorkflowCountOrderByAggregateInput;
    _avg?: WorkflowAvgOrderByAggregateInput;
    _max?: WorkflowMaxOrderByAggregateInput;
    _min?: WorkflowMinOrderByAggregateInput;
    _sum?: WorkflowSumOrderByAggregateInput;
  };

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[];
    OR?: WorkflowScalarWhereWithAggregatesInput[];
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Workflow'> | string;
    name?: StringWithAggregatesFilter<'Workflow'> | string;
    description?: StringNullableWithAggregatesFilter<'Workflow'> | string | null;
    definition?: JsonWithAggregatesFilter<'Workflow'>;
    isActive?: BoolWithAggregatesFilter<'Workflow'> | boolean;
    trigger?: JsonWithAggregatesFilter<'Workflow'>;
    lastRunAt?: DateTimeNullableWithAggregatesFilter<'Workflow'> | Date | string | null;
    runCount?: IntWithAggregatesFilter<'Workflow'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Workflow'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Workflow'> | string;
    createdBy?: StringNullableWithAggregatesFilter<'Workflow'> | string | null;
  };

  export type WorkflowExecutionWhereInput = {
    AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[];
    OR?: WorkflowExecutionWhereInput[];
    NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[];
    id?: StringFilter<'WorkflowExecution'> | string;
    status?: EnumExecutionStatusFilter<'WorkflowExecution'> | $Enums.ExecutionStatus;
    startedAt?: DateTimeFilter<'WorkflowExecution'> | Date | string;
    completedAt?: DateTimeNullableFilter<'WorkflowExecution'> | Date | string | null;
    error?: StringNullableFilter<'WorkflowExecution'> | string | null;
    logs?: JsonNullableFilter<'WorkflowExecution'>;
    workflowId?: StringFilter<'WorkflowExecution'> | string;
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>;
  };

  export type WorkflowExecutionOrderByWithRelationInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    error?: SortOrderInput | SortOrder;
    logs?: SortOrderInput | SortOrder;
    workflowId?: SortOrder;
    workflow?: WorkflowOrderByWithRelationInput;
  };

  export type WorkflowExecutionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[];
      OR?: WorkflowExecutionWhereInput[];
      NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[];
      status?: EnumExecutionStatusFilter<'WorkflowExecution'> | $Enums.ExecutionStatus;
      startedAt?: DateTimeFilter<'WorkflowExecution'> | Date | string;
      completedAt?: DateTimeNullableFilter<'WorkflowExecution'> | Date | string | null;
      error?: StringNullableFilter<'WorkflowExecution'> | string | null;
      logs?: JsonNullableFilter<'WorkflowExecution'>;
      workflowId?: StringFilter<'WorkflowExecution'> | string;
      workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>;
    },
    'id'
  >;

  export type WorkflowExecutionOrderByWithAggregationInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    error?: SortOrderInput | SortOrder;
    logs?: SortOrderInput | SortOrder;
    workflowId?: SortOrder;
    _count?: WorkflowExecutionCountOrderByAggregateInput;
    _max?: WorkflowExecutionMaxOrderByAggregateInput;
    _min?: WorkflowExecutionMinOrderByAggregateInput;
  };

  export type WorkflowExecutionScalarWhereWithAggregatesInput = {
    AND?:
      | WorkflowExecutionScalarWhereWithAggregatesInput
      | WorkflowExecutionScalarWhereWithAggregatesInput[];
    OR?: WorkflowExecutionScalarWhereWithAggregatesInput[];
    NOT?:
      | WorkflowExecutionScalarWhereWithAggregatesInput
      | WorkflowExecutionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'WorkflowExecution'> | string;
    status?: EnumExecutionStatusWithAggregatesFilter<'WorkflowExecution'> | $Enums.ExecutionStatus;
    startedAt?: DateTimeWithAggregatesFilter<'WorkflowExecution'> | Date | string;
    completedAt?: DateTimeNullableWithAggregatesFilter<'WorkflowExecution'> | Date | string | null;
    error?: StringNullableWithAggregatesFilter<'WorkflowExecution'> | string | null;
    logs?: JsonNullableWithAggregatesFilter<'WorkflowExecution'>;
    workflowId?: StringWithAggregatesFilter<'WorkflowExecution'> | string;
  };

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[];
    OR?: WebhookWhereInput[];
    NOT?: WebhookWhereInput | WebhookWhereInput[];
    id?: StringFilter<'Webhook'> | string;
    url?: StringFilter<'Webhook'> | string;
    events?: StringNullableListFilter<'Webhook'>;
    secret?: StringFilter<'Webhook'> | string;
    isActive?: BoolFilter<'Webhook'> | boolean;
    lastTriggeredAt?: DateTimeNullableFilter<'Webhook'> | Date | string | null;
    failureCount?: IntFilter<'Webhook'> | number;
    createdAt?: DateTimeFilter<'Webhook'> | Date | string;
    updatedAt?: DateTimeFilter<'Webhook'> | Date | string;
    organizationId?: StringFilter<'Webhook'> | string;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder;
    url?: SortOrder;
    events?: SortOrder;
    secret?: SortOrder;
    isActive?: SortOrder;
    lastTriggeredAt?: SortOrderInput | SortOrder;
    failureCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type WebhookWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WebhookWhereInput | WebhookWhereInput[];
      OR?: WebhookWhereInput[];
      NOT?: WebhookWhereInput | WebhookWhereInput[];
      url?: StringFilter<'Webhook'> | string;
      events?: StringNullableListFilter<'Webhook'>;
      secret?: StringFilter<'Webhook'> | string;
      isActive?: BoolFilter<'Webhook'> | boolean;
      lastTriggeredAt?: DateTimeNullableFilter<'Webhook'> | Date | string | null;
      failureCount?: IntFilter<'Webhook'> | number;
      createdAt?: DateTimeFilter<'Webhook'> | Date | string;
      updatedAt?: DateTimeFilter<'Webhook'> | Date | string;
      organizationId?: StringFilter<'Webhook'> | string;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id'
  >;

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder;
    url?: SortOrder;
    events?: SortOrder;
    secret?: SortOrder;
    isActive?: SortOrder;
    lastTriggeredAt?: SortOrderInput | SortOrder;
    failureCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    _count?: WebhookCountOrderByAggregateInput;
    _avg?: WebhookAvgOrderByAggregateInput;
    _max?: WebhookMaxOrderByAggregateInput;
    _min?: WebhookMinOrderByAggregateInput;
    _sum?: WebhookSumOrderByAggregateInput;
  };

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[];
    OR?: WebhookScalarWhereWithAggregatesInput[];
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Webhook'> | string;
    url?: StringWithAggregatesFilter<'Webhook'> | string;
    events?: StringNullableListFilter<'Webhook'>;
    secret?: StringWithAggregatesFilter<'Webhook'> | string;
    isActive?: BoolWithAggregatesFilter<'Webhook'> | boolean;
    lastTriggeredAt?: DateTimeNullableWithAggregatesFilter<'Webhook'> | Date | string | null;
    failureCount?: IntWithAggregatesFilter<'Webhook'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Webhook'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Webhook'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Webhook'> | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringFilter<'AuditLog'> | string;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
    organizationId?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      action?: StringFilter<'AuditLog'> | string;
      entityType?: StringFilter<'AuditLog'> | string;
      entityId?: StringFilter<'AuditLog'> | string;
      metadata?: JsonNullableFilter<'AuditLog'>;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
      organizationId?: StringFilter<'AuditLog'> | string;
      userId?: StringNullableFilter<'AuditLog'> | string | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityType?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityId?: StringWithAggregatesFilter<'AuditLog'> | string;
    metadata?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'AuditLog'> | string;
    userId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
  };

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[];
    OR?: ServiceWhereInput[];
    NOT?: ServiceWhereInput | ServiceWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    label?: StringNullableFilter<'Service'> | string | null;
    description?: StringNullableFilter<'Service'> | string | null;
    host?: StringNullableFilter<'Service'> | string | null;
    port?: IntNullableFilter<'Service'> | number | null;
    database?: StringFilter<'Service'> | string;
    username?: StringNullableFilter<'Service'> | string | null;
    passwordEncrypted?: StringNullableFilter<'Service'> | string | null;
    isActive?: BoolFilter<'Service'> | boolean;
    failoverHost?: StringNullableFilter<'Service'> | string | null;
    objects?: JsonNullableFilter<'Service'>;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    organizationId?: StringFilter<'Service'> | string;
    createdBy?: StringFilter<'Service'> | string;
    connectionId?: StringNullableFilter<'Service'> | string | null;
    databaseObjects?: DatabaseObjectListRelationFilter;
    exposedEntities?: ExposedEntityListRelationFilter;
    roles?: RoleListRelationFilter;
    connection?: XOR<
      DatabaseConnectionNullableScalarRelationFilter,
      DatabaseConnectionWhereInput
    > | null;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    host?: SortOrderInput | SortOrder;
    port?: SortOrderInput | SortOrder;
    database?: SortOrder;
    username?: SortOrderInput | SortOrder;
    passwordEncrypted?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    objects?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    databaseObjects?: DatabaseObjectOrderByRelationAggregateInput;
    exposedEntities?: ExposedEntityOrderByRelationAggregateInput;
    roles?: RoleOrderByRelationAggregateInput;
    connection?: DatabaseConnectionOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type ServiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_name?: ServiceOrganizationIdNameCompoundUniqueInput;
      AND?: ServiceWhereInput | ServiceWhereInput[];
      OR?: ServiceWhereInput[];
      NOT?: ServiceWhereInput | ServiceWhereInput[];
      name?: StringFilter<'Service'> | string;
      label?: StringNullableFilter<'Service'> | string | null;
      description?: StringNullableFilter<'Service'> | string | null;
      host?: StringNullableFilter<'Service'> | string | null;
      port?: IntNullableFilter<'Service'> | number | null;
      database?: StringFilter<'Service'> | string;
      username?: StringNullableFilter<'Service'> | string | null;
      passwordEncrypted?: StringNullableFilter<'Service'> | string | null;
      isActive?: BoolFilter<'Service'> | boolean;
      failoverHost?: StringNullableFilter<'Service'> | string | null;
      objects?: JsonNullableFilter<'Service'>;
      createdAt?: DateTimeFilter<'Service'> | Date | string;
      updatedAt?: DateTimeFilter<'Service'> | Date | string;
      organizationId?: StringFilter<'Service'> | string;
      createdBy?: StringFilter<'Service'> | string;
      connectionId?: StringNullableFilter<'Service'> | string | null;
      databaseObjects?: DatabaseObjectListRelationFilter;
      exposedEntities?: ExposedEntityListRelationFilter;
      roles?: RoleListRelationFilter;
      connection?: XOR<
        DatabaseConnectionNullableScalarRelationFilter,
        DatabaseConnectionWhereInput
      > | null;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'organizationId_name'
  >;

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    host?: SortOrderInput | SortOrder;
    port?: SortOrderInput | SortOrder;
    database?: SortOrder;
    username?: SortOrderInput | SortOrder;
    passwordEncrypted?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    objects?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    _count?: ServiceCountOrderByAggregateInput;
    _avg?: ServiceAvgOrderByAggregateInput;
    _max?: ServiceMaxOrderByAggregateInput;
    _min?: ServiceMinOrderByAggregateInput;
    _sum?: ServiceSumOrderByAggregateInput;
  };

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    OR?: ServiceScalarWhereWithAggregatesInput[];
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Service'> | string;
    name?: StringWithAggregatesFilter<'Service'> | string;
    label?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    description?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    host?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    port?: IntNullableWithAggregatesFilter<'Service'> | number | null;
    database?: StringWithAggregatesFilter<'Service'> | string;
    username?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    passwordEncrypted?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    isActive?: BoolWithAggregatesFilter<'Service'> | boolean;
    failoverHost?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    objects?: JsonNullableWithAggregatesFilter<'Service'>;
    createdAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Service'> | string;
    createdBy?: StringWithAggregatesFilter<'Service'> | string;
    connectionId?: StringNullableWithAggregatesFilter<'Service'> | string | null;
  };

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[];
    OR?: ApplicationWhereInput[];
    NOT?: ApplicationWhereInput | ApplicationWhereInput[];
    id?: StringFilter<'Application'> | string;
    name?: StringFilter<'Application'> | string;
    description?: StringNullableFilter<'Application'> | string | null;
    apiKeyHash?: StringFilter<'Application'> | string;
    apiKeyEncrypted?: StringFilter<'Application'> | string;
    apiKeyPrefix?: StringFilter<'Application'> | string;
    apiKeyHint?: StringFilter<'Application'> | string;
    isActive?: BoolFilter<'Application'> | boolean;
    createdAt?: DateTimeFilter<'Application'> | Date | string;
    updatedAt?: DateTimeFilter<'Application'> | Date | string;
    organizationId?: StringFilter<'Application'> | string;
    createdBy?: StringFilter<'Application'> | string;
    defaultRoleId?: StringFilter<'Application'> | string;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    defaultRole?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    apiKeyHash?: SortOrder;
    apiKeyEncrypted?: SortOrder;
    apiKeyPrefix?: SortOrder;
    apiKeyHint?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    defaultRoleId?: SortOrder;
    creator?: UserOrderByWithRelationInput;
    defaultRole?: RoleOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      apiKeyHash?: string;
      organizationId_name?: ApplicationOrganizationIdNameCompoundUniqueInput;
      AND?: ApplicationWhereInput | ApplicationWhereInput[];
      OR?: ApplicationWhereInput[];
      NOT?: ApplicationWhereInput | ApplicationWhereInput[];
      name?: StringFilter<'Application'> | string;
      description?: StringNullableFilter<'Application'> | string | null;
      apiKeyEncrypted?: StringFilter<'Application'> | string;
      apiKeyPrefix?: StringFilter<'Application'> | string;
      apiKeyHint?: StringFilter<'Application'> | string;
      isActive?: BoolFilter<'Application'> | boolean;
      createdAt?: DateTimeFilter<'Application'> | Date | string;
      updatedAt?: DateTimeFilter<'Application'> | Date | string;
      organizationId?: StringFilter<'Application'> | string;
      createdBy?: StringFilter<'Application'> | string;
      defaultRoleId?: StringFilter<'Application'> | string;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      defaultRole?: XOR<RoleScalarRelationFilter, RoleWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'apiKeyHash' | 'organizationId_name'
  >;

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    apiKeyHash?: SortOrder;
    apiKeyEncrypted?: SortOrder;
    apiKeyPrefix?: SortOrder;
    apiKeyHint?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    defaultRoleId?: SortOrder;
    _count?: ApplicationCountOrderByAggregateInput;
    _max?: ApplicationMaxOrderByAggregateInput;
    _min?: ApplicationMinOrderByAggregateInput;
  };

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[];
    OR?: ApplicationScalarWhereWithAggregatesInput[];
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Application'> | string;
    name?: StringWithAggregatesFilter<'Application'> | string;
    description?: StringNullableWithAggregatesFilter<'Application'> | string | null;
    apiKeyHash?: StringWithAggregatesFilter<'Application'> | string;
    apiKeyEncrypted?: StringWithAggregatesFilter<'Application'> | string;
    apiKeyPrefix?: StringWithAggregatesFilter<'Application'> | string;
    apiKeyHint?: StringWithAggregatesFilter<'Application'> | string;
    isActive?: BoolWithAggregatesFilter<'Application'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Application'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Application'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Application'> | string;
    createdBy?: StringWithAggregatesFilter<'Application'> | string;
    defaultRoleId?: StringWithAggregatesFilter<'Application'> | string;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    description?: StringNullableFilter<'Role'> | string | null;
    isActive?: BoolFilter<'Role'> | boolean;
    permissions?: JsonFilter<'Role'>;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
    organizationId?: StringFilter<'Role'> | string;
    serviceId?: StringFilter<'Role'> | string;
    createdBy?: StringFilter<'Role'> | string;
    applications?: ApplicationListRelationFilter;
    exposedFieldPolicies?: ExposedFieldPolicyListRelationFilter;
    exposedRowPolicies?: ExposedRowPolicyListRelationFilter;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdBy?: SortOrder;
    applications?: ApplicationOrderByRelationAggregateInput;
    exposedFieldPolicies?: ExposedFieldPolicyOrderByRelationAggregateInput;
    exposedRowPolicies?: ExposedRowPolicyOrderByRelationAggregateInput;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_serviceId_name?: RoleOrganizationIdServiceIdNameCompoundUniqueInput;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      name?: StringFilter<'Role'> | string;
      description?: StringNullableFilter<'Role'> | string | null;
      isActive?: BoolFilter<'Role'> | boolean;
      permissions?: JsonFilter<'Role'>;
      createdAt?: DateTimeFilter<'Role'> | Date | string;
      updatedAt?: DateTimeFilter<'Role'> | Date | string;
      organizationId?: StringFilter<'Role'> | string;
      serviceId?: StringFilter<'Role'> | string;
      createdBy?: StringFilter<'Role'> | string;
      applications?: ApplicationListRelationFilter;
      exposedFieldPolicies?: ExposedFieldPolicyListRelationFilter;
      exposedRowPolicies?: ExposedRowPolicyListRelationFilter;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    },
    'id' | 'organizationId_serviceId_name'
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdBy?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Role'> | string;
    name?: StringWithAggregatesFilter<'Role'> | string;
    description?: StringNullableWithAggregatesFilter<'Role'> | string | null;
    isActive?: BoolWithAggregatesFilter<'Role'> | boolean;
    permissions?: JsonWithAggregatesFilter<'Role'>;
    createdAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Role'> | string;
    serviceId?: StringWithAggregatesFilter<'Role'> | string;
    createdBy?: StringWithAggregatesFilter<'Role'> | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    isRead?: BoolFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    metadata?: JsonNullableFilter<'Notification'>;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    organizationId?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    type?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
      priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      isRead?: BoolFilter<'Notification'> | boolean;
      readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      metadata?: JsonNullableFilter<'Notification'>;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      organizationId?: StringFilter<'Notification'> | string;
      userId?: StringFilter<'Notification'> | string;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    type?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    type?: EnumNotificationTypeWithAggregatesFilter<'Notification'> | $Enums.NotificationType;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'Notification'>
      | $Enums.NotificationPriority;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    isRead?: BoolWithAggregatesFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'Notification'>;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
  };

  export type ApiActivityLogWhereInput = {
    AND?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
    OR?: ApiActivityLogWhereInput[];
    NOT?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
    id?: StringFilter<'ApiActivityLog'> | string;
    requestId?: StringFilter<'ApiActivityLog'> | string;
    timestamp?: DateTimeFilter<'ApiActivityLog'> | Date | string;
    method?: EnumHttpMethodFilter<'ApiActivityLog'> | $Enums.HttpMethod;
    url?: StringFilter<'ApiActivityLog'> | string;
    endpoint?: StringNullableFilter<'ApiActivityLog'> | string | null;
    statusCode?: IntFilter<'ApiActivityLog'> | number;
    responseTime?: IntNullableFilter<'ApiActivityLog'> | number | null;
    userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
    category?: StringNullableFilter<'ApiActivityLog'> | string | null;
    endpointType?: StringNullableFilter<'ApiActivityLog'> | string | null;
    importance?: StringNullableFilter<'ApiActivityLog'> | string | null;
    error?: StringNullableFilter<'ApiActivityLog'> | string | null;
    metadata?: JsonNullableFilter<'ApiActivityLog'>;
    organizationId?: StringFilter<'ApiActivityLog'> | string;
    userId?: StringNullableFilter<'ApiActivityLog'> | string | null;
    endpointId?: StringNullableFilter<'ApiActivityLog'> | string | null;
    endpointUsage?: XOR<EndpointNullableScalarRelationFilter, EndpointWhereInput> | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type ApiActivityLogOrderByWithRelationInput = {
    id?: SortOrder;
    requestId?: SortOrder;
    timestamp?: SortOrder;
    method?: SortOrder;
    url?: SortOrder;
    endpoint?: SortOrderInput | SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    category?: SortOrderInput | SortOrder;
    endpointType?: SortOrderInput | SortOrder;
    importance?: SortOrderInput | SortOrder;
    error?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    endpointId?: SortOrderInput | SortOrder;
    endpointUsage?: EndpointOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type ApiActivityLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      requestId?: string;
      AND?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
      OR?: ApiActivityLogWhereInput[];
      NOT?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
      timestamp?: DateTimeFilter<'ApiActivityLog'> | Date | string;
      method?: EnumHttpMethodFilter<'ApiActivityLog'> | $Enums.HttpMethod;
      url?: StringFilter<'ApiActivityLog'> | string;
      endpoint?: StringNullableFilter<'ApiActivityLog'> | string | null;
      statusCode?: IntFilter<'ApiActivityLog'> | number;
      responseTime?: IntNullableFilter<'ApiActivityLog'> | number | null;
      userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
      ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
      category?: StringNullableFilter<'ApiActivityLog'> | string | null;
      endpointType?: StringNullableFilter<'ApiActivityLog'> | string | null;
      importance?: StringNullableFilter<'ApiActivityLog'> | string | null;
      error?: StringNullableFilter<'ApiActivityLog'> | string | null;
      metadata?: JsonNullableFilter<'ApiActivityLog'>;
      organizationId?: StringFilter<'ApiActivityLog'> | string;
      userId?: StringNullableFilter<'ApiActivityLog'> | string | null;
      endpointId?: StringNullableFilter<'ApiActivityLog'> | string | null;
      endpointUsage?: XOR<EndpointNullableScalarRelationFilter, EndpointWhereInput> | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id' | 'requestId'
  >;

  export type ApiActivityLogOrderByWithAggregationInput = {
    id?: SortOrder;
    requestId?: SortOrder;
    timestamp?: SortOrder;
    method?: SortOrder;
    url?: SortOrder;
    endpoint?: SortOrderInput | SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    category?: SortOrderInput | SortOrder;
    endpointType?: SortOrderInput | SortOrder;
    importance?: SortOrderInput | SortOrder;
    error?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    endpointId?: SortOrderInput | SortOrder;
    _count?: ApiActivityLogCountOrderByAggregateInput;
    _avg?: ApiActivityLogAvgOrderByAggregateInput;
    _max?: ApiActivityLogMaxOrderByAggregateInput;
    _min?: ApiActivityLogMinOrderByAggregateInput;
    _sum?: ApiActivityLogSumOrderByAggregateInput;
  };

  export type ApiActivityLogScalarWhereWithAggregatesInput = {
    AND?:
      | ApiActivityLogScalarWhereWithAggregatesInput
      | ApiActivityLogScalarWhereWithAggregatesInput[];
    OR?: ApiActivityLogScalarWhereWithAggregatesInput[];
    NOT?:
      | ApiActivityLogScalarWhereWithAggregatesInput
      | ApiActivityLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    requestId?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    timestamp?: DateTimeWithAggregatesFilter<'ApiActivityLog'> | Date | string;
    method?: EnumHttpMethodWithAggregatesFilter<'ApiActivityLog'> | $Enums.HttpMethod;
    url?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    endpoint?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    statusCode?: IntWithAggregatesFilter<'ApiActivityLog'> | number;
    responseTime?: IntNullableWithAggregatesFilter<'ApiActivityLog'> | number | null;
    userAgent?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    category?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    endpointType?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    importance?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    error?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'ApiActivityLog'>;
    organizationId?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    userId?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    endpointId?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
  };

  export type DatabaseObjectWhereInput = {
    AND?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
    OR?: DatabaseObjectWhereInput[];
    NOT?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
    id?: StringFilter<'DatabaseObject'> | string;
    name?: StringFilter<'DatabaseObject'> | string;
    schema?: StringNullableFilter<'DatabaseObject'> | string | null;
    type?: StringFilter<'DatabaseObject'> | string;
    path?: StringNullableFilter<'DatabaseObject'> | string | null;
    metadata?: JsonNullableFilter<'DatabaseObject'>;
    createdAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    updatedAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    organizationId?: StringFilter<'DatabaseObject'> | string;
    serviceId?: StringNullableFilter<'DatabaseObject'> | string | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
  };

  export type DatabaseObjectOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    type?: SortOrder;
    path?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
  };

  export type DatabaseObjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_serviceId_schema_name?: DatabaseObjectOrganizationIdServiceIdSchemaNameCompoundUniqueInput;
      AND?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
      OR?: DatabaseObjectWhereInput[];
      NOT?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
      name?: StringFilter<'DatabaseObject'> | string;
      schema?: StringNullableFilter<'DatabaseObject'> | string | null;
      type?: StringFilter<'DatabaseObject'> | string;
      path?: StringNullableFilter<'DatabaseObject'> | string | null;
      metadata?: JsonNullableFilter<'DatabaseObject'>;
      createdAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
      updatedAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
      organizationId?: StringFilter<'DatabaseObject'> | string;
      serviceId?: StringNullableFilter<'DatabaseObject'> | string | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null;
    },
    'id' | 'organizationId_serviceId_schema_name'
  >;

  export type DatabaseObjectOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    type?: SortOrder;
    path?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrderInput | SortOrder;
    _count?: DatabaseObjectCountOrderByAggregateInput;
    _max?: DatabaseObjectMaxOrderByAggregateInput;
    _min?: DatabaseObjectMinOrderByAggregateInput;
  };

  export type DatabaseObjectScalarWhereWithAggregatesInput = {
    AND?:
      | DatabaseObjectScalarWhereWithAggregatesInput
      | DatabaseObjectScalarWhereWithAggregatesInput[];
    OR?: DatabaseObjectScalarWhereWithAggregatesInput[];
    NOT?:
      | DatabaseObjectScalarWhereWithAggregatesInput
      | DatabaseObjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    name?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    schema?: StringNullableWithAggregatesFilter<'DatabaseObject'> | string | null;
    type?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    path?: StringNullableWithAggregatesFilter<'DatabaseObject'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'DatabaseObject'>;
    createdAt?: DateTimeWithAggregatesFilter<'DatabaseObject'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'DatabaseObject'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    serviceId?: StringNullableWithAggregatesFilter<'DatabaseObject'> | string | null;
  };

  export type ExposedEntityWhereInput = {
    AND?: ExposedEntityWhereInput | ExposedEntityWhereInput[];
    OR?: ExposedEntityWhereInput[];
    NOT?: ExposedEntityWhereInput | ExposedEntityWhereInput[];
    id?: StringFilter<'ExposedEntity'> | string;
    serviceId?: StringFilter<'ExposedEntity'> | string;
    connectionId?: StringFilter<'ExposedEntity'> | string;
    organizationId?: StringFilter<'ExposedEntity'> | string;
    database?: StringFilter<'ExposedEntity'> | string;
    schema?: StringNullableFilter<'ExposedEntity'> | string | null;
    name?: StringFilter<'ExposedEntity'> | string;
    type?: EnumExposedEntityTypeFilter<'ExposedEntity'> | $Enums.ExposedEntityType;
    primaryKey?: StringNullableFilter<'ExposedEntity'> | string | null;
    allowRead?: BoolFilter<'ExposedEntity'> | boolean;
    allowCreate?: BoolFilter<'ExposedEntity'> | boolean;
    allowUpdate?: BoolFilter<'ExposedEntity'> | boolean;
    allowDelete?: BoolFilter<'ExposedEntity'> | boolean;
    defaultSort?: StringNullableFilter<'ExposedEntity'> | string | null;
    softDeleteEnabled?: BoolFilter<'ExposedEntity'> | boolean;
    softDeleteColumn?: StringNullableFilter<'ExposedEntity'> | string | null;
    softDeleteValue?: StringNullableFilter<'ExposedEntity'> | string | null;
    pathSlug?: StringNullableFilter<'ExposedEntity'> | string | null;
    createdAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
    createdBy?: StringNullableFilter<'ExposedEntity'> | string | null;
    connection?: XOR<DatabaseConnectionScalarRelationFilter, DatabaseConnectionWhereInput>;
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    fieldPolicies?: ExposedFieldPolicyListRelationFilter;
    rowPolicies?: ExposedRowPolicyListRelationFilter;
  };

  export type ExposedEntityOrderByWithRelationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    connectionId?: SortOrder;
    organizationId?: SortOrder;
    database?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    primaryKey?: SortOrderInput | SortOrder;
    allowRead?: SortOrder;
    allowCreate?: SortOrder;
    allowUpdate?: SortOrder;
    allowDelete?: SortOrder;
    defaultSort?: SortOrderInput | SortOrder;
    softDeleteEnabled?: SortOrder;
    softDeleteColumn?: SortOrderInput | SortOrder;
    softDeleteValue?: SortOrderInput | SortOrder;
    pathSlug?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    connection?: DatabaseConnectionOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    organization?: OrganizationOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
    fieldPolicies?: ExposedFieldPolicyOrderByRelationAggregateInput;
    rowPolicies?: ExposedRowPolicyOrderByRelationAggregateInput;
  };

  export type ExposedEntityWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      serviceId_schema_name?: ExposedEntityServiceIdSchemaNameCompoundUniqueInput;
      AND?: ExposedEntityWhereInput | ExposedEntityWhereInput[];
      OR?: ExposedEntityWhereInput[];
      NOT?: ExposedEntityWhereInput | ExposedEntityWhereInput[];
      serviceId?: StringFilter<'ExposedEntity'> | string;
      connectionId?: StringFilter<'ExposedEntity'> | string;
      organizationId?: StringFilter<'ExposedEntity'> | string;
      database?: StringFilter<'ExposedEntity'> | string;
      schema?: StringNullableFilter<'ExposedEntity'> | string | null;
      name?: StringFilter<'ExposedEntity'> | string;
      type?: EnumExposedEntityTypeFilter<'ExposedEntity'> | $Enums.ExposedEntityType;
      primaryKey?: StringNullableFilter<'ExposedEntity'> | string | null;
      allowRead?: BoolFilter<'ExposedEntity'> | boolean;
      allowCreate?: BoolFilter<'ExposedEntity'> | boolean;
      allowUpdate?: BoolFilter<'ExposedEntity'> | boolean;
      allowDelete?: BoolFilter<'ExposedEntity'> | boolean;
      defaultSort?: StringNullableFilter<'ExposedEntity'> | string | null;
      softDeleteEnabled?: BoolFilter<'ExposedEntity'> | boolean;
      softDeleteColumn?: StringNullableFilter<'ExposedEntity'> | string | null;
      softDeleteValue?: StringNullableFilter<'ExposedEntity'> | string | null;
      pathSlug?: StringNullableFilter<'ExposedEntity'> | string | null;
      createdAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
      updatedAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
      createdBy?: StringNullableFilter<'ExposedEntity'> | string | null;
      connection?: XOR<DatabaseConnectionScalarRelationFilter, DatabaseConnectionWhereInput>;
      creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
      fieldPolicies?: ExposedFieldPolicyListRelationFilter;
      rowPolicies?: ExposedRowPolicyListRelationFilter;
    },
    'id' | 'serviceId_schema_name'
  >;

  export type ExposedEntityOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    connectionId?: SortOrder;
    organizationId?: SortOrder;
    database?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    primaryKey?: SortOrderInput | SortOrder;
    allowRead?: SortOrder;
    allowCreate?: SortOrder;
    allowUpdate?: SortOrder;
    allowDelete?: SortOrder;
    defaultSort?: SortOrderInput | SortOrder;
    softDeleteEnabled?: SortOrder;
    softDeleteColumn?: SortOrderInput | SortOrder;
    softDeleteValue?: SortOrderInput | SortOrder;
    pathSlug?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    _count?: ExposedEntityCountOrderByAggregateInput;
    _max?: ExposedEntityMaxOrderByAggregateInput;
    _min?: ExposedEntityMinOrderByAggregateInput;
  };

  export type ExposedEntityScalarWhereWithAggregatesInput = {
    AND?:
      | ExposedEntityScalarWhereWithAggregatesInput
      | ExposedEntityScalarWhereWithAggregatesInput[];
    OR?: ExposedEntityScalarWhereWithAggregatesInput[];
    NOT?:
      | ExposedEntityScalarWhereWithAggregatesInput
      | ExposedEntityScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    serviceId?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    connectionId?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    organizationId?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    database?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    schema?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    name?: StringWithAggregatesFilter<'ExposedEntity'> | string;
    type?: EnumExposedEntityTypeWithAggregatesFilter<'ExposedEntity'> | $Enums.ExposedEntityType;
    primaryKey?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    allowRead?: BoolWithAggregatesFilter<'ExposedEntity'> | boolean;
    allowCreate?: BoolWithAggregatesFilter<'ExposedEntity'> | boolean;
    allowUpdate?: BoolWithAggregatesFilter<'ExposedEntity'> | boolean;
    allowDelete?: BoolWithAggregatesFilter<'ExposedEntity'> | boolean;
    defaultSort?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    softDeleteEnabled?: BoolWithAggregatesFilter<'ExposedEntity'> | boolean;
    softDeleteColumn?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    softDeleteValue?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    pathSlug?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ExposedEntity'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ExposedEntity'> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<'ExposedEntity'> | string | null;
  };

  export type ExposedFieldPolicyWhereInput = {
    AND?: ExposedFieldPolicyWhereInput | ExposedFieldPolicyWhereInput[];
    OR?: ExposedFieldPolicyWhereInput[];
    NOT?: ExposedFieldPolicyWhereInput | ExposedFieldPolicyWhereInput[];
    id?: StringFilter<'ExposedFieldPolicy'> | string;
    exposedEntityId?: StringFilter<'ExposedFieldPolicy'> | string;
    roleId?: StringNullableFilter<'ExposedFieldPolicy'> | string | null;
    includeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    excludeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    writeProtected?: StringNullableListFilter<'ExposedFieldPolicy'>;
    maskedFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    createdAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
    exposedEntity?: XOR<ExposedEntityScalarRelationFilter, ExposedEntityWhereInput>;
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null;
  };

  export type ExposedFieldPolicyOrderByWithRelationInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrderInput | SortOrder;
    includeFields?: SortOrder;
    excludeFields?: SortOrder;
    writeProtected?: SortOrder;
    maskedFields?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    exposedEntity?: ExposedEntityOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
  };

  export type ExposedFieldPolicyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ExposedFieldPolicyWhereInput | ExposedFieldPolicyWhereInput[];
      OR?: ExposedFieldPolicyWhereInput[];
      NOT?: ExposedFieldPolicyWhereInput | ExposedFieldPolicyWhereInput[];
      exposedEntityId?: StringFilter<'ExposedFieldPolicy'> | string;
      roleId?: StringNullableFilter<'ExposedFieldPolicy'> | string | null;
      includeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
      excludeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
      writeProtected?: StringNullableListFilter<'ExposedFieldPolicy'>;
      maskedFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
      createdAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
      updatedAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
      exposedEntity?: XOR<ExposedEntityScalarRelationFilter, ExposedEntityWhereInput>;
      role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null;
    },
    'id'
  >;

  export type ExposedFieldPolicyOrderByWithAggregationInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrderInput | SortOrder;
    includeFields?: SortOrder;
    excludeFields?: SortOrder;
    writeProtected?: SortOrder;
    maskedFields?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ExposedFieldPolicyCountOrderByAggregateInput;
    _max?: ExposedFieldPolicyMaxOrderByAggregateInput;
    _min?: ExposedFieldPolicyMinOrderByAggregateInput;
  };

  export type ExposedFieldPolicyScalarWhereWithAggregatesInput = {
    AND?:
      | ExposedFieldPolicyScalarWhereWithAggregatesInput
      | ExposedFieldPolicyScalarWhereWithAggregatesInput[];
    OR?: ExposedFieldPolicyScalarWhereWithAggregatesInput[];
    NOT?:
      | ExposedFieldPolicyScalarWhereWithAggregatesInput
      | ExposedFieldPolicyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ExposedFieldPolicy'> | string;
    exposedEntityId?: StringWithAggregatesFilter<'ExposedFieldPolicy'> | string;
    roleId?: StringNullableWithAggregatesFilter<'ExposedFieldPolicy'> | string | null;
    includeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    excludeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    writeProtected?: StringNullableListFilter<'ExposedFieldPolicy'>;
    maskedFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    createdAt?: DateTimeWithAggregatesFilter<'ExposedFieldPolicy'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ExposedFieldPolicy'> | Date | string;
  };

  export type ExposedRowPolicyWhereInput = {
    AND?: ExposedRowPolicyWhereInput | ExposedRowPolicyWhereInput[];
    OR?: ExposedRowPolicyWhereInput[];
    NOT?: ExposedRowPolicyWhereInput | ExposedRowPolicyWhereInput[];
    id?: StringFilter<'ExposedRowPolicy'> | string;
    exposedEntityId?: StringFilter<'ExposedRowPolicy'> | string;
    roleId?: StringNullableFilter<'ExposedRowPolicy'> | string | null;
    filterTemplate?: JsonFilter<'ExposedRowPolicy'>;
    createdAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
    exposedEntity?: XOR<ExposedEntityScalarRelationFilter, ExposedEntityWhereInput>;
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null;
  };

  export type ExposedRowPolicyOrderByWithRelationInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrderInput | SortOrder;
    filterTemplate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    exposedEntity?: ExposedEntityOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
  };

  export type ExposedRowPolicyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ExposedRowPolicyWhereInput | ExposedRowPolicyWhereInput[];
      OR?: ExposedRowPolicyWhereInput[];
      NOT?: ExposedRowPolicyWhereInput | ExposedRowPolicyWhereInput[];
      exposedEntityId?: StringFilter<'ExposedRowPolicy'> | string;
      roleId?: StringNullableFilter<'ExposedRowPolicy'> | string | null;
      filterTemplate?: JsonFilter<'ExposedRowPolicy'>;
      createdAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
      updatedAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
      exposedEntity?: XOR<ExposedEntityScalarRelationFilter, ExposedEntityWhereInput>;
      role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null;
    },
    'id'
  >;

  export type ExposedRowPolicyOrderByWithAggregationInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrderInput | SortOrder;
    filterTemplate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ExposedRowPolicyCountOrderByAggregateInput;
    _max?: ExposedRowPolicyMaxOrderByAggregateInput;
    _min?: ExposedRowPolicyMinOrderByAggregateInput;
  };

  export type ExposedRowPolicyScalarWhereWithAggregatesInput = {
    AND?:
      | ExposedRowPolicyScalarWhereWithAggregatesInput
      | ExposedRowPolicyScalarWhereWithAggregatesInput[];
    OR?: ExposedRowPolicyScalarWhereWithAggregatesInput[];
    NOT?:
      | ExposedRowPolicyScalarWhereWithAggregatesInput
      | ExposedRowPolicyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ExposedRowPolicy'> | string;
    exposedEntityId?: StringWithAggregatesFilter<'ExposedRowPolicy'> | string;
    roleId?: StringNullableWithAggregatesFilter<'ExposedRowPolicy'> | string | null;
    filterTemplate?: JsonWithAggregatesFilter<'ExposedRowPolicy'>;
    createdAt?: DateTimeWithAggregatesFilter<'ExposedRowPolicy'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ExposedRowPolicy'> | Date | string;
  };

  export type TermsAndConditionsWhereInput = {
    AND?: TermsAndConditionsWhereInput | TermsAndConditionsWhereInput[];
    OR?: TermsAndConditionsWhereInput[];
    NOT?: TermsAndConditionsWhereInput | TermsAndConditionsWhereInput[];
    id?: StringFilter<'TermsAndConditions'> | string;
    version?: StringFilter<'TermsAndConditions'> | string;
    content?: StringFilter<'TermsAndConditions'> | string;
    summary?: StringNullableFilter<'TermsAndConditions'> | string | null;
    effectiveDate?: DateTimeFilter<'TermsAndConditions'> | Date | string;
    isActive?: BoolFilter<'TermsAndConditions'> | boolean;
    createdAt?: DateTimeFilter<'TermsAndConditions'> | Date | string;
    updatedAt?: DateTimeFilter<'TermsAndConditions'> | Date | string;
    acceptances?: TermsAcceptanceListRelationFilter;
  };

  export type TermsAndConditionsOrderByWithRelationInput = {
    id?: SortOrder;
    version?: SortOrder;
    content?: SortOrder;
    summary?: SortOrderInput | SortOrder;
    effectiveDate?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    acceptances?: TermsAcceptanceOrderByRelationAggregateInput;
  };

  export type TermsAndConditionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      version?: string;
      AND?: TermsAndConditionsWhereInput | TermsAndConditionsWhereInput[];
      OR?: TermsAndConditionsWhereInput[];
      NOT?: TermsAndConditionsWhereInput | TermsAndConditionsWhereInput[];
      content?: StringFilter<'TermsAndConditions'> | string;
      summary?: StringNullableFilter<'TermsAndConditions'> | string | null;
      effectiveDate?: DateTimeFilter<'TermsAndConditions'> | Date | string;
      isActive?: BoolFilter<'TermsAndConditions'> | boolean;
      createdAt?: DateTimeFilter<'TermsAndConditions'> | Date | string;
      updatedAt?: DateTimeFilter<'TermsAndConditions'> | Date | string;
      acceptances?: TermsAcceptanceListRelationFilter;
    },
    'id' | 'version'
  >;

  export type TermsAndConditionsOrderByWithAggregationInput = {
    id?: SortOrder;
    version?: SortOrder;
    content?: SortOrder;
    summary?: SortOrderInput | SortOrder;
    effectiveDate?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TermsAndConditionsCountOrderByAggregateInput;
    _max?: TermsAndConditionsMaxOrderByAggregateInput;
    _min?: TermsAndConditionsMinOrderByAggregateInput;
  };

  export type TermsAndConditionsScalarWhereWithAggregatesInput = {
    AND?:
      | TermsAndConditionsScalarWhereWithAggregatesInput
      | TermsAndConditionsScalarWhereWithAggregatesInput[];
    OR?: TermsAndConditionsScalarWhereWithAggregatesInput[];
    NOT?:
      | TermsAndConditionsScalarWhereWithAggregatesInput
      | TermsAndConditionsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TermsAndConditions'> | string;
    version?: StringWithAggregatesFilter<'TermsAndConditions'> | string;
    content?: StringWithAggregatesFilter<'TermsAndConditions'> | string;
    summary?: StringNullableWithAggregatesFilter<'TermsAndConditions'> | string | null;
    effectiveDate?: DateTimeWithAggregatesFilter<'TermsAndConditions'> | Date | string;
    isActive?: BoolWithAggregatesFilter<'TermsAndConditions'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'TermsAndConditions'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'TermsAndConditions'> | Date | string;
  };

  export type TermsAcceptanceWhereInput = {
    AND?: TermsAcceptanceWhereInput | TermsAcceptanceWhereInput[];
    OR?: TermsAcceptanceWhereInput[];
    NOT?: TermsAcceptanceWhereInput | TermsAcceptanceWhereInput[];
    id?: StringFilter<'TermsAcceptance'> | string;
    acceptedAt?: DateTimeFilter<'TermsAcceptance'> | Date | string;
    ipAddress?: StringFilter<'TermsAcceptance'> | string;
    userAgent?: StringNullableFilter<'TermsAcceptance'> | string | null;
    geolocation?: JsonNullableFilter<'TermsAcceptance'>;
    acceptanceMethod?: EnumAcceptanceMethodFilter<'TermsAcceptance'> | $Enums.AcceptanceMethod;
    organizationId?: StringFilter<'TermsAcceptance'> | string;
    userId?: StringFilter<'TermsAcceptance'> | string;
    termsId?: StringFilter<'TermsAcceptance'> | string;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    terms?: XOR<TermsAndConditionsScalarRelationFilter, TermsAndConditionsWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TermsAcceptanceOrderByWithRelationInput = {
    id?: SortOrder;
    acceptedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    geolocation?: SortOrderInput | SortOrder;
    acceptanceMethod?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    termsId?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    terms?: TermsAndConditionsOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type TermsAcceptanceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_userId_termsId?: TermsAcceptanceOrganizationIdUserIdTermsIdCompoundUniqueInput;
      AND?: TermsAcceptanceWhereInput | TermsAcceptanceWhereInput[];
      OR?: TermsAcceptanceWhereInput[];
      NOT?: TermsAcceptanceWhereInput | TermsAcceptanceWhereInput[];
      acceptedAt?: DateTimeFilter<'TermsAcceptance'> | Date | string;
      ipAddress?: StringFilter<'TermsAcceptance'> | string;
      userAgent?: StringNullableFilter<'TermsAcceptance'> | string | null;
      geolocation?: JsonNullableFilter<'TermsAcceptance'>;
      acceptanceMethod?: EnumAcceptanceMethodFilter<'TermsAcceptance'> | $Enums.AcceptanceMethod;
      organizationId?: StringFilter<'TermsAcceptance'> | string;
      userId?: StringFilter<'TermsAcceptance'> | string;
      termsId?: StringFilter<'TermsAcceptance'> | string;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      terms?: XOR<TermsAndConditionsScalarRelationFilter, TermsAndConditionsWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'organizationId_userId_termsId'
  >;

  export type TermsAcceptanceOrderByWithAggregationInput = {
    id?: SortOrder;
    acceptedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    geolocation?: SortOrderInput | SortOrder;
    acceptanceMethod?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    termsId?: SortOrder;
    _count?: TermsAcceptanceCountOrderByAggregateInput;
    _max?: TermsAcceptanceMaxOrderByAggregateInput;
    _min?: TermsAcceptanceMinOrderByAggregateInput;
  };

  export type TermsAcceptanceScalarWhereWithAggregatesInput = {
    AND?:
      | TermsAcceptanceScalarWhereWithAggregatesInput
      | TermsAcceptanceScalarWhereWithAggregatesInput[];
    OR?: TermsAcceptanceScalarWhereWithAggregatesInput[];
    NOT?:
      | TermsAcceptanceScalarWhereWithAggregatesInput
      | TermsAcceptanceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'TermsAcceptance'> | string;
    acceptedAt?: DateTimeWithAggregatesFilter<'TermsAcceptance'> | Date | string;
    ipAddress?: StringWithAggregatesFilter<'TermsAcceptance'> | string;
    userAgent?: StringNullableWithAggregatesFilter<'TermsAcceptance'> | string | null;
    geolocation?: JsonNullableWithAggregatesFilter<'TermsAcceptance'>;
    acceptanceMethod?:
      | EnumAcceptanceMethodWithAggregatesFilter<'TermsAcceptance'>
      | $Enums.AcceptanceMethod;
    organizationId?: StringWithAggregatesFilter<'TermsAcceptance'> | string;
    userId?: StringWithAggregatesFilter<'TermsAcceptance'> | string;
    termsId?: StringWithAggregatesFilter<'TermsAcceptance'> | string;
  };

  export type RateLimitConfigWhereInput = {
    AND?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
    OR?: RateLimitConfigWhereInput[];
    NOT?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
    id?: StringFilter<'RateLimitConfig'> | string;
    name?: StringFilter<'RateLimitConfig'> | string;
    displayName?: StringFilter<'RateLimitConfig'> | string;
    type?: EnumRateLimitTypeFilter<'RateLimitConfig'> | $Enums.RateLimitType;
    max?: IntFilter<'RateLimitConfig'> | number;
    windowMs?: IntFilter<'RateLimitConfig'> | number;
    keyStrategy?: EnumRateLimitKeyStrategyFilter<'RateLimitConfig'> | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFilter<'RateLimitConfig'> | boolean;
    description?: StringNullableFilter<'RateLimitConfig'> | string | null;
    createdAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    updatedAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    applicationLimits?: JsonNullableFilter<'RateLimitConfig'>;
    roleLimits?: JsonNullableFilter<'RateLimitConfig'>;
    componentLimits?: JsonNullableFilter<'RateLimitConfig'>;
    changeHistory?: JsonNullableFilter<'RateLimitConfig'>;
    changeReason?: StringNullableFilter<'RateLimitConfig'> | string | null;
    organizationId?: StringFilter<'RateLimitConfig'> | string;
    createdBy?: StringFilter<'RateLimitConfig'> | string;
    updatedBy?: StringNullableFilter<'RateLimitConfig'> | string | null;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type RateLimitConfigOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    displayName?: SortOrder;
    type?: SortOrder;
    max?: SortOrder;
    windowMs?: SortOrder;
    keyStrategy?: SortOrder;
    enabled?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    applicationLimits?: SortOrderInput | SortOrder;
    roleLimits?: SortOrderInput | SortOrder;
    componentLimits?: SortOrderInput | SortOrder;
    changeHistory?: SortOrderInput | SortOrder;
    changeReason?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    updatedBy?: SortOrderInput | SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    updater?: UserOrderByWithRelationInput;
  };

  export type RateLimitConfigWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_name?: RateLimitConfigOrganizationIdNameCompoundUniqueInput;
      AND?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
      OR?: RateLimitConfigWhereInput[];
      NOT?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
      name?: StringFilter<'RateLimitConfig'> | string;
      displayName?: StringFilter<'RateLimitConfig'> | string;
      type?: EnumRateLimitTypeFilter<'RateLimitConfig'> | $Enums.RateLimitType;
      max?: IntFilter<'RateLimitConfig'> | number;
      windowMs?: IntFilter<'RateLimitConfig'> | number;
      keyStrategy?: EnumRateLimitKeyStrategyFilter<'RateLimitConfig'> | $Enums.RateLimitKeyStrategy;
      enabled?: BoolFilter<'RateLimitConfig'> | boolean;
      description?: StringNullableFilter<'RateLimitConfig'> | string | null;
      createdAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
      updatedAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
      applicationLimits?: JsonNullableFilter<'RateLimitConfig'>;
      roleLimits?: JsonNullableFilter<'RateLimitConfig'>;
      componentLimits?: JsonNullableFilter<'RateLimitConfig'>;
      changeHistory?: JsonNullableFilter<'RateLimitConfig'>;
      changeReason?: StringNullableFilter<'RateLimitConfig'> | string | null;
      organizationId?: StringFilter<'RateLimitConfig'> | string;
      createdBy?: StringFilter<'RateLimitConfig'> | string;
      updatedBy?: StringNullableFilter<'RateLimitConfig'> | string | null;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      updater?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id' | 'organizationId_name'
  >;

  export type RateLimitConfigOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    displayName?: SortOrder;
    type?: SortOrder;
    max?: SortOrder;
    windowMs?: SortOrder;
    keyStrategy?: SortOrder;
    enabled?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    applicationLimits?: SortOrderInput | SortOrder;
    roleLimits?: SortOrderInput | SortOrder;
    componentLimits?: SortOrderInput | SortOrder;
    changeHistory?: SortOrderInput | SortOrder;
    changeReason?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    updatedBy?: SortOrderInput | SortOrder;
    _count?: RateLimitConfigCountOrderByAggregateInput;
    _avg?: RateLimitConfigAvgOrderByAggregateInput;
    _max?: RateLimitConfigMaxOrderByAggregateInput;
    _min?: RateLimitConfigMinOrderByAggregateInput;
    _sum?: RateLimitConfigSumOrderByAggregateInput;
  };

  export type RateLimitConfigScalarWhereWithAggregatesInput = {
    AND?:
      | RateLimitConfigScalarWhereWithAggregatesInput
      | RateLimitConfigScalarWhereWithAggregatesInput[];
    OR?: RateLimitConfigScalarWhereWithAggregatesInput[];
    NOT?:
      | RateLimitConfigScalarWhereWithAggregatesInput
      | RateLimitConfigScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    name?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    displayName?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    type?: EnumRateLimitTypeWithAggregatesFilter<'RateLimitConfig'> | $Enums.RateLimitType;
    max?: IntWithAggregatesFilter<'RateLimitConfig'> | number;
    windowMs?: IntWithAggregatesFilter<'RateLimitConfig'> | number;
    keyStrategy?:
      | EnumRateLimitKeyStrategyWithAggregatesFilter<'RateLimitConfig'>
      | $Enums.RateLimitKeyStrategy;
    enabled?: BoolWithAggregatesFilter<'RateLimitConfig'> | boolean;
    description?: StringNullableWithAggregatesFilter<'RateLimitConfig'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'RateLimitConfig'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RateLimitConfig'> | Date | string;
    applicationLimits?: JsonNullableWithAggregatesFilter<'RateLimitConfig'>;
    roleLimits?: JsonNullableWithAggregatesFilter<'RateLimitConfig'>;
    componentLimits?: JsonNullableWithAggregatesFilter<'RateLimitConfig'>;
    changeHistory?: JsonNullableWithAggregatesFilter<'RateLimitConfig'>;
    changeReason?: StringNullableWithAggregatesFilter<'RateLimitConfig'> | string | null;
    organizationId?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    createdBy?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    updatedBy?: StringNullableWithAggregatesFilter<'RateLimitConfig'> | string | null;
  };

  export type RateLimitUsageWhereInput = {
    AND?: RateLimitUsageWhereInput | RateLimitUsageWhereInput[];
    OR?: RateLimitUsageWhereInput[];
    NOT?: RateLimitUsageWhereInput | RateLimitUsageWhereInput[];
    id?: StringFilter<'RateLimitUsage'> | string;
    configName?: StringFilter<'RateLimitUsage'> | string;
    limitKey?: StringFilter<'RateLimitUsage'> | string;
    currentCount?: IntFilter<'RateLimitUsage'> | number;
    resetAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    blocked?: BoolFilter<'RateLimitUsage'> | boolean;
    createdAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    updatedAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    organizationId?: StringFilter<'RateLimitUsage'> | string;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
  };

  export type RateLimitUsageOrderByWithRelationInput = {
    id?: SortOrder;
    configName?: SortOrder;
    limitKey?: SortOrder;
    currentCount?: SortOrder;
    resetAt?: SortOrder;
    blocked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    organization?: OrganizationOrderByWithRelationInput;
  };

  export type RateLimitUsageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      organizationId_configName_limitKey?: RateLimitUsageOrganizationIdConfigNameLimitKeyCompoundUniqueInput;
      AND?: RateLimitUsageWhereInput | RateLimitUsageWhereInput[];
      OR?: RateLimitUsageWhereInput[];
      NOT?: RateLimitUsageWhereInput | RateLimitUsageWhereInput[];
      configName?: StringFilter<'RateLimitUsage'> | string;
      limitKey?: StringFilter<'RateLimitUsage'> | string;
      currentCount?: IntFilter<'RateLimitUsage'> | number;
      resetAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
      blocked?: BoolFilter<'RateLimitUsage'> | boolean;
      createdAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
      updatedAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
      organizationId?: StringFilter<'RateLimitUsage'> | string;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    },
    'id' | 'organizationId_configName_limitKey'
  >;

  export type RateLimitUsageOrderByWithAggregationInput = {
    id?: SortOrder;
    configName?: SortOrder;
    limitKey?: SortOrder;
    currentCount?: SortOrder;
    resetAt?: SortOrder;
    blocked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    _count?: RateLimitUsageCountOrderByAggregateInput;
    _avg?: RateLimitUsageAvgOrderByAggregateInput;
    _max?: RateLimitUsageMaxOrderByAggregateInput;
    _min?: RateLimitUsageMinOrderByAggregateInput;
    _sum?: RateLimitUsageSumOrderByAggregateInput;
  };

  export type RateLimitUsageScalarWhereWithAggregatesInput = {
    AND?:
      | RateLimitUsageScalarWhereWithAggregatesInput
      | RateLimitUsageScalarWhereWithAggregatesInput[];
    OR?: RateLimitUsageScalarWhereWithAggregatesInput[];
    NOT?:
      | RateLimitUsageScalarWhereWithAggregatesInput
      | RateLimitUsageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RateLimitUsage'> | string;
    configName?: StringWithAggregatesFilter<'RateLimitUsage'> | string;
    limitKey?: StringWithAggregatesFilter<'RateLimitUsage'> | string;
    currentCount?: IntWithAggregatesFilter<'RateLimitUsage'> | number;
    resetAt?: DateTimeWithAggregatesFilter<'RateLimitUsage'> | Date | string;
    blocked?: BoolWithAggregatesFilter<'RateLimitUsage'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'RateLimitUsage'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RateLimitUsage'> | Date | string;
    organizationId?: StringWithAggregatesFilter<'RateLimitUsage'> | string;
  };

  export type SocialAccountWhereInput = {
    AND?: SocialAccountWhereInput | SocialAccountWhereInput[];
    OR?: SocialAccountWhereInput[];
    NOT?: SocialAccountWhereInput | SocialAccountWhereInput[];
    id?: StringFilter<'SocialAccount'> | string;
    userId?: StringFilter<'SocialAccount'> | string;
    provider?: StringFilter<'SocialAccount'> | string;
    providerId?: StringFilter<'SocialAccount'> | string;
    email?: StringNullableFilter<'SocialAccount'> | string | null;
    name?: StringNullableFilter<'SocialAccount'> | string | null;
    profileUrl?: StringNullableFilter<'SocialAccount'> | string | null;
    avatarUrl?: StringNullableFilter<'SocialAccount'> | string | null;
    accessToken?: StringNullableFilter<'SocialAccount'> | string | null;
    refreshToken?: StringNullableFilter<'SocialAccount'> | string | null;
    profileData?: StringNullableFilter<'SocialAccount'> | string | null;
    createdAt?: DateTimeFilter<'SocialAccount'> | Date | string;
    updatedAt?: DateTimeFilter<'SocialAccount'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SocialAccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    providerId?: SortOrder;
    email?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    profileUrl?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    profileData?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SocialAccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerId?: SocialAccountProviderProviderIdCompoundUniqueInput;
      AND?: SocialAccountWhereInput | SocialAccountWhereInput[];
      OR?: SocialAccountWhereInput[];
      NOT?: SocialAccountWhereInput | SocialAccountWhereInput[];
      userId?: StringFilter<'SocialAccount'> | string;
      provider?: StringFilter<'SocialAccount'> | string;
      providerId?: StringFilter<'SocialAccount'> | string;
      email?: StringNullableFilter<'SocialAccount'> | string | null;
      name?: StringNullableFilter<'SocialAccount'> | string | null;
      profileUrl?: StringNullableFilter<'SocialAccount'> | string | null;
      avatarUrl?: StringNullableFilter<'SocialAccount'> | string | null;
      accessToken?: StringNullableFilter<'SocialAccount'> | string | null;
      refreshToken?: StringNullableFilter<'SocialAccount'> | string | null;
      profileData?: StringNullableFilter<'SocialAccount'> | string | null;
      createdAt?: DateTimeFilter<'SocialAccount'> | Date | string;
      updatedAt?: DateTimeFilter<'SocialAccount'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'provider_providerId'
  >;

  export type SocialAccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    providerId?: SortOrder;
    email?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    profileUrl?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    profileData?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SocialAccountCountOrderByAggregateInput;
    _max?: SocialAccountMaxOrderByAggregateInput;
    _min?: SocialAccountMinOrderByAggregateInput;
  };

  export type SocialAccountScalarWhereWithAggregatesInput = {
    AND?:
      | SocialAccountScalarWhereWithAggregatesInput
      | SocialAccountScalarWhereWithAggregatesInput[];
    OR?: SocialAccountScalarWhereWithAggregatesInput[];
    NOT?:
      | SocialAccountScalarWhereWithAggregatesInput
      | SocialAccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SocialAccount'> | string;
    userId?: StringWithAggregatesFilter<'SocialAccount'> | string;
    provider?: StringWithAggregatesFilter<'SocialAccount'> | string;
    providerId?: StringWithAggregatesFilter<'SocialAccount'> | string;
    email?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    name?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    profileUrl?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    avatarUrl?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    accessToken?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    refreshToken?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    profileData?: StringNullableWithAggregatesFilter<'SocialAccount'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'SocialAccount'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'SocialAccount'> | Date | string;
  };

  export type OrganizationCreateInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
  };

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipCreateInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutMembershipsInput;
    user: UserCreateNestedOneWithoutMembershipsInput;
  };

  export type MembershipUncheckedCreateInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    userId: string;
    organizationId: string;
  };

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type MembershipCreateManyInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    userId: string;
    organizationId: string;
  };

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type InvitationCreateInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    invitedBy: UserCreateNestedOneWithoutInvitationsSentInput;
    organization: OrganizationCreateNestedOneWithoutInvitationsInput;
  };

  export type InvitationUncheckedCreateInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    organizationId: string;
    invitedById: string;
  };

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    invitedBy?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput;
  };

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    invitedById?: StringFieldUpdateOperationsInput | string;
  };

  export type InvitationCreateManyInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    organizationId: string;
    invitedById: string;
  };

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    invitedById?: StringFieldUpdateOperationsInput | string;
  };

  export type EmailVerificationTokenCreateInput = {
    id?: string;
    token: string;
    email: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string;
    token: string;
    email: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenCreateManyInput = {
    id?: string;
    token: string;
    email: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BillingEventCreateInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organization?: OrganizationCreateNestedOneWithoutBillingEventsInput;
    subscription?: SubscriptionCreateNestedOneWithoutBillingEventsInput;
  };

  export type BillingEventUncheckedCreateInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId?: string | null;
    subscriptionId?: string | null;
  };

  export type BillingEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneWithoutBillingEventsNestedInput;
    subscription?: SubscriptionUpdateOneWithoutBillingEventsNestedInput;
  };

  export type BillingEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BillingEventCreateManyInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId?: string | null;
    subscriptionId?: string | null;
  };

  export type BillingEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BillingEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SubscriptionCreateInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput;
    billingEvents?: BillingEventCreateNestedManyWithoutSubscriptionInput;
    organization: OrganizationCreateNestedOneWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    organizationId: string;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutSubscriptionNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionCreateManyInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    organizationId: string;
  };

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
  };

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type InvoiceCreateInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput;
  };

  export type InvoiceUncheckedCreateInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
    subscriptionId: string;
  };

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput;
  };

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptionId?: StringFieldUpdateOperationsInput | string;
  };

  export type InvoiceCreateManyInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
    subscriptionId: string;
  };

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptionId?: StringFieldUpdateOperationsInput | string;
  };

  export type DatabaseConnectionCreateInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutDatabaseConnectionsInput;
    endpoints?: EndpointCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutConnectionInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput;
    endpoints?: EndpointUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionCreateManyInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type DatabaseConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type DatabaseConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type EndpointCreateInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    usageLogs?: ApiActivityLogCreateNestedManyWithoutEndpointUsageInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutEndpointsInput;
    creator: UserCreateNestedOneWithoutEndpointsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
    usageLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutEndpointUsageInput;
  };

  export type EndpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageLogs?: ApiActivityLogUpdateManyWithoutEndpointUsageNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutEndpointsNestedInput;
    creator?: UserUpdateOneRequiredWithoutEndpointsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    usageLogs?: ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageNestedInput;
  };

  export type EndpointCreateManyInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
  };

  export type EndpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiKeyCreateInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApiKeysCreatedInput;
    organization: OrganizationCreateNestedOneWithoutApiKeysInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyUncheckedCreateInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organizationId: string;
    createdById: string;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApiKeysCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApiKeysNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyCreateManyInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organizationId: string;
    createdById: string;
  };

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
  };

  export type UsageMetricCreateInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    apiKey?: ApiKeyCreateNestedOneWithoutUsageMetricsInput;
    organization: OrganizationCreateNestedOneWithoutUsageMetricsInput;
  };

  export type UsageMetricUncheckedCreateInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    organizationId: string;
    apiKeyId?: string | null;
  };

  export type UsageMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKey?: ApiKeyUpdateOneWithoutUsageMetricsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsageMetricsNestedInput;
  };

  export type UsageMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UsageMetricCreateManyInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    organizationId: string;
    apiKeyId?: string | null;
  };

  export type UsageMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UsageMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WorkflowCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator?: UserCreateNestedOneWithoutWorkflowsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput;
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneWithoutWorkflowsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput;
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
  };

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WorkflowExecutionCreateInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflow: WorkflowCreateNestedOneWithoutExecutionsInput;
  };

  export type WorkflowExecutionUncheckedCreateInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
  };

  export type WorkflowExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput;
  };

  export type WorkflowExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
  };

  export type WorkflowExecutionCreateManyInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
  };

  export type WorkflowExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
  };

  export type WebhookCreateInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutWebhooksInput;
  };

  export type WebhookUncheckedCreateInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutWebhooksNestedInput;
  };

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type WebhookCreateManyInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organization: OrganizationCreateNestedOneWithoutAuditLogsInput;
    user?: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organizationId: string;
    userId?: string | null;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput;
    user?: UserUpdateOneWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organizationId: string;
    userId?: string | null;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ServiceCreateInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceCreateManyInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
  };

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApplicationCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator: UserCreateNestedOneWithoutApplicationsCreatedInput;
    defaultRole: RoleCreateNestedOneWithoutApplicationsInput;
    organization: OrganizationCreateNestedOneWithoutApplicationsInput;
  };

  export type ApplicationUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    defaultRoleId: string;
  };

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneRequiredWithoutApplicationsCreatedNestedInput;
    defaultRole?: RoleUpdateOneRequiredWithoutApplicationsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApplicationsNestedInput;
  };

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    defaultRoleId: string;
  };

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type RoleCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    createdBy: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    createdBy: string;
  };

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutNotificationsInput;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId: string;
    userId: string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutNotificationsNestedInput;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId: string;
    userId: string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type ApiActivityLogCreateInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointCreateNestedOneWithoutUsageLogsInput;
    organization: OrganizationCreateNestedOneWithoutApiActivityLogsInput;
    user?: UserCreateNestedOneWithoutApiActivityLogsInput;
  };

  export type ApiActivityLogUncheckedCreateInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    userId?: string | null;
    endpointId?: string | null;
  };

  export type ApiActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointUpdateOneWithoutUsageLogsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApiActivityLogsNestedInput;
    user?: UserUpdateOneWithoutApiActivityLogsNestedInput;
  };

  export type ApiActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiActivityLogCreateManyInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    userId?: string | null;
    endpointId?: string | null;
  };

  export type ApiActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type ApiActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DatabaseObjectCreateInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutDatabaseObjectsInput;
    service?: ServiceCreateNestedOneWithoutDatabaseObjectsInput;
  };

  export type DatabaseObjectUncheckedCreateInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId?: string | null;
  };

  export type DatabaseObjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseObjectsNestedInput;
    service?: ServiceUpdateOneWithoutDatabaseObjectsNestedInput;
  };

  export type DatabaseObjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DatabaseObjectCreateManyInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId?: string | null;
  };

  export type DatabaseObjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DatabaseObjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExposedEntityCreateInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityCreateManyInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type ExposedEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExposedFieldPolicyCreateInput = {
    id?: string;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedEntity: ExposedEntityCreateNestedOneWithoutFieldPoliciesInput;
    role?: RoleCreateNestedOneWithoutExposedFieldPoliciesInput;
  };

  export type ExposedFieldPolicyUncheckedCreateInput = {
    id?: string;
    exposedEntityId: string;
    roleId?: string | null;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedFieldPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedEntity?: ExposedEntityUpdateOneRequiredWithoutFieldPoliciesNestedInput;
    role?: RoleUpdateOneWithoutExposedFieldPoliciesNestedInput;
  };

  export type ExposedFieldPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedFieldPolicyCreateManyInput = {
    id?: string;
    exposedEntityId: string;
    roleId?: string | null;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedFieldPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedFieldPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyCreateInput = {
    id?: string;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedEntity: ExposedEntityCreateNestedOneWithoutRowPoliciesInput;
    role?: RoleCreateNestedOneWithoutExposedRowPoliciesInput;
  };

  export type ExposedRowPolicyUncheckedCreateInput = {
    id?: string;
    exposedEntityId: string;
    roleId?: string | null;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedEntity?: ExposedEntityUpdateOneRequiredWithoutRowPoliciesNestedInput;
    role?: RoleUpdateOneWithoutExposedRowPoliciesNestedInput;
  };

  export type ExposedRowPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyCreateManyInput = {
    id?: string;
    exposedEntityId: string;
    roleId?: string | null;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TermsAndConditionsCreateInput = {
    id?: string;
    version: string;
    content: string;
    summary?: string | null;
    effectiveDate: Date | string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    acceptances?: TermsAcceptanceCreateNestedManyWithoutTermsInput;
  };

  export type TermsAndConditionsUncheckedCreateInput = {
    id?: string;
    version: string;
    content: string;
    summary?: string | null;
    effectiveDate: Date | string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    acceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutTermsInput;
  };

  export type TermsAndConditionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptances?: TermsAcceptanceUpdateManyWithoutTermsNestedInput;
  };

  export type TermsAndConditionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptances?: TermsAcceptanceUncheckedUpdateManyWithoutTermsNestedInput;
  };

  export type TermsAndConditionsCreateManyInput = {
    id?: string;
    version: string;
    content: string;
    summary?: string | null;
    effectiveDate: Date | string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TermsAndConditionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TermsAndConditionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TermsAcceptanceCreateInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organization: OrganizationCreateNestedOneWithoutTermsAcceptancesInput;
    terms: TermsAndConditionsCreateNestedOneWithoutAcceptancesInput;
    user: UserCreateNestedOneWithoutTermsAcceptancesInput;
  };

  export type TermsAcceptanceUncheckedCreateInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    userId: string;
    termsId: string;
  };

  export type TermsAcceptanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organization?: OrganizationUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
    terms?: TermsAndConditionsUpdateOneRequiredWithoutAcceptancesNestedInput;
    user?: UserUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
  };

  export type TermsAcceptanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type TermsAcceptanceCreateManyInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    userId: string;
    termsId: string;
  };

  export type TermsAcceptanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
  };

  export type TermsAcceptanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type RateLimitConfigCreateInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organization: OrganizationCreateNestedOneWithoutRateLimitConfigsInput;
    creator: UserCreateNestedOneWithoutRateLimitCreatedInput;
    updater?: UserCreateNestedOneWithoutRateLimitUpdatedInput;
  };

  export type RateLimitConfigUncheckedCreateInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    createdBy: string;
    updatedBy?: string | null;
  };

  export type RateLimitConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: OrganizationUpdateOneRequiredWithoutRateLimitConfigsNestedInput;
    creator?: UserUpdateOneRequiredWithoutRateLimitCreatedNestedInput;
    updater?: UserUpdateOneWithoutRateLimitUpdatedNestedInput;
  };

  export type RateLimitConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigCreateManyInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    createdBy: string;
    updatedBy?: string | null;
  };

  export type RateLimitConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitUsageCreateInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutRateLimitUsageInput;
  };

  export type RateLimitUsageUncheckedCreateInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type RateLimitUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutRateLimitUsageNestedInput;
  };

  export type RateLimitUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type RateLimitUsageCreateManyInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type RateLimitUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type SocialAccountCreateInput = {
    id?: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutSocialAccountsInput;
  };

  export type SocialAccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SocialAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput;
  };

  export type SocialAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SocialAccountCreateManyInput = {
    id?: string;
    userId: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SocialAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SocialAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type ApiActivityLogListRelationFilter = {
    every?: ApiActivityLogWhereInput;
    some?: ApiActivityLogWhereInput;
    none?: ApiActivityLogWhereInput;
  };

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput;
    some?: ApiKeyWhereInput;
    none?: ApiKeyWhereInput;
  };

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput;
    some?: ApplicationWhereInput;
    none?: ApplicationWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type DatabaseConnectionListRelationFilter = {
    every?: DatabaseConnectionWhereInput;
    some?: DatabaseConnectionWhereInput;
    none?: DatabaseConnectionWhereInput;
  };

  export type DatabaseObjectListRelationFilter = {
    every?: DatabaseObjectWhereInput;
    some?: DatabaseObjectWhereInput;
    none?: DatabaseObjectWhereInput;
  };

  export type EndpointListRelationFilter = {
    every?: EndpointWhereInput;
    some?: EndpointWhereInput;
    none?: EndpointWhereInput;
  };

  export type ExposedEntityListRelationFilter = {
    every?: ExposedEntityWhereInput;
    some?: ExposedEntityWhereInput;
    none?: ExposedEntityWhereInput;
  };

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput;
    some?: InvitationWhereInput;
    none?: InvitationWhereInput;
  };

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput;
    some?: MembershipWhereInput;
    none?: MembershipWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type RoleListRelationFilter = {
    every?: RoleWhereInput;
    some?: RoleWhereInput;
    none?: RoleWhereInput;
  };

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput;
    some?: ServiceWhereInput;
    none?: ServiceWhereInput;
  };

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null;
    isNot?: SubscriptionWhereInput | null;
  };

  export type TermsAcceptanceListRelationFilter = {
    every?: TermsAcceptanceWhereInput;
    some?: TermsAcceptanceWhereInput;
    none?: TermsAcceptanceWhereInput;
  };

  export type UsageMetricListRelationFilter = {
    every?: UsageMetricWhereInput;
    some?: UsageMetricWhereInput;
    none?: UsageMetricWhereInput;
  };

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput;
    some?: WebhookWhereInput;
    none?: WebhookWhereInput;
  };

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput;
    some?: WorkflowWhereInput;
    none?: WorkflowWhereInput;
  };

  export type RateLimitConfigListRelationFilter = {
    every?: RateLimitConfigWhereInput;
    some?: RateLimitConfigWhereInput;
    none?: RateLimitConfigWhereInput;
  };

  export type RateLimitUsageListRelationFilter = {
    every?: RateLimitUsageWhereInput;
    some?: RateLimitUsageWhereInput;
    none?: RateLimitUsageWhereInput;
  };

  export type BillingEventListRelationFilter = {
    every?: BillingEventWhereInput;
    some?: BillingEventWhereInput;
    none?: BillingEventWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type ApiActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DatabaseConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DatabaseObjectOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EndpointOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ExposedEntityOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TermsAcceptanceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UsageMetricOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RateLimitConfigOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RateLimitUsageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BillingEventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    domain?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastTermsPromptedAt?: SortOrder;
    requiresTermsAcceptance?: SortOrder;
  };

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    domain?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastTermsPromptedAt?: SortOrder;
    requiresTermsAcceptance?: SortOrder;
  };

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    domain?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastTermsPromptedAt?: SortOrder;
    requiresTermsAcceptance?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type SocialAccountListRelationFilter = {
    every?: SocialAccountWhereInput;
    some?: SocialAccountWhereInput;
    none?: SocialAccountWhereInput;
  };

  export type SocialAccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatarUrl?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    emailVerifiedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    phoneNumber?: SortOrder;
    phoneCarrier?: SortOrder;
    isSuperAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatarUrl?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    emailVerifiedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    phoneNumber?: SortOrder;
    phoneCarrier?: SortOrder;
    isSuperAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatarUrl?: SortOrder;
    isActive?: SortOrder;
    emailVerified?: SortOrder;
    emailVerifiedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    twoFactorEnabled?: SortOrder;
    twoFactorSecret?: SortOrder;
    phoneNumber?: SortOrder;
    phoneCarrier?: SortOrder;
    isSuperAdmin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole;
  };

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput;
    isNot?: OrganizationWhereInput;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type MembershipUserIdOrganizationIdCompoundUniqueInput = {
    userId: string;
    organizationId: string;
  };

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
  };

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
  };

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
  };

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>;
  };

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    role?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    acceptedAt?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    invitedById?: SortOrder;
  };

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    role?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    acceptedAt?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    invitedById?: SortOrder;
  };

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    role?: SortOrder;
    token?: SortOrder;
    expiresAt?: SortOrder;
    acceptedAt?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    invitedById?: SortOrder;
  };

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    email?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    email?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    email?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null;
    isNot?: OrganizationWhereInput | null;
  };

  export type BillingEventCountOrderByAggregateInput = {
    id?: SortOrder;
    eventType?: SortOrder;
    stripeEventId?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    subscriptionId?: SortOrder;
  };

  export type BillingEventMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventType?: SortOrder;
    stripeEventId?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    subscriptionId?: SortOrder;
  };

  export type BillingEventMinOrderByAggregateInput = {
    id?: SortOrder;
    eventType?: SortOrder;
    stripeEventId?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    subscriptionId?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan;
  };

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput;
    some?: InvoiceWhereInput;
    none?: InvoiceWhereInput;
  };

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder;
    plan?: SortOrder;
    status?: SortOrder;
    trialEndsAt?: SortOrder;
    currentPeriodStart?: SortOrder;
    currentPeriodEnd?: SortOrder;
    canceledAt?: SortOrder;
    stripeCustomerId?: SortOrder;
    stripeSubscriptionId?: SortOrder;
    stripePriceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
    organizationId?: SortOrder;
  };

  export type SubscriptionAvgOrderByAggregateInput = {
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
  };

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    plan?: SortOrder;
    status?: SortOrder;
    trialEndsAt?: SortOrder;
    currentPeriodStart?: SortOrder;
    currentPeriodEnd?: SortOrder;
    canceledAt?: SortOrder;
    stripeCustomerId?: SortOrder;
    stripeSubscriptionId?: SortOrder;
    stripePriceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
    organizationId?: SortOrder;
  };

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder;
    plan?: SortOrder;
    status?: SortOrder;
    trialEndsAt?: SortOrder;
    currentPeriodStart?: SortOrder;
    currentPeriodEnd?: SortOrder;
    canceledAt?: SortOrder;
    stripeCustomerId?: SortOrder;
    stripeSubscriptionId?: SortOrder;
    stripePriceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
    organizationId?: SortOrder;
  };

  export type SubscriptionSumOrderByAggregateInput = {
    maxDatabaseConnections?: SortOrder;
    maxApiCallsPerMonth?: SortOrder;
    maxUsersPerOrg?: SortOrder;
    maxWorkflows?: SortOrder;
  };

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>;
  };

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SubscriptionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput;
    isNot?: SubscriptionWhereInput;
  };

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidAt?: SortOrder;
    stripeInvoiceId?: SortOrder;
    stripePaymentIntentId?: SortOrder;
    hostedInvoiceUrl?: SortOrder;
    createdAt?: SortOrder;
    subscriptionId?: SortOrder;
  };

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidAt?: SortOrder;
    stripeInvoiceId?: SortOrder;
    stripePaymentIntentId?: SortOrder;
    hostedInvoiceUrl?: SortOrder;
    createdAt?: SortOrder;
    subscriptionId?: SortOrder;
  };

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder;
    invoiceNumber?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidAt?: SortOrder;
    stripeInvoiceId?: SortOrder;
    stripePaymentIntentId?: SortOrder;
    hostedInvoiceUrl?: SortOrder;
    createdAt?: SortOrder;
    subscriptionId?: SortOrder;
  };

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type EnumDatabaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseType | EnumDatabaseTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDatabaseTypeFilter<$PrismaModel> | $Enums.DatabaseType;
  };

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type DatabaseConnectionOrganizationIdNameCompoundUniqueInput = {
    organizationId: string;
    name: string;
  };

  export type DatabaseConnectionCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    sslEnabled?: SortOrder;
    isActive?: SortOrder;
    lastTestedAt?: SortOrder;
    lastTestResult?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    databases?: SortOrder;
  };

  export type DatabaseConnectionAvgOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type DatabaseConnectionMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    sslEnabled?: SortOrder;
    isActive?: SortOrder;
    lastTestedAt?: SortOrder;
    lastTestResult?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type DatabaseConnectionMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    sslEnabled?: SortOrder;
    isActive?: SortOrder;
    lastTestedAt?: SortOrder;
    lastTestResult?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type DatabaseConnectionSumOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type EnumDatabaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseType | EnumDatabaseTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDatabaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatabaseType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDatabaseTypeFilter<$PrismaModel>;
    _max?: NestedEnumDatabaseTypeFilter<$PrismaModel>;
  };

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EnumHttpMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumHttpMethodFilter<$PrismaModel> | $Enums.HttpMethod;
  };

  export type DatabaseConnectionNullableScalarRelationFilter = {
    is?: DatabaseConnectionWhereInput | null;
    isNot?: DatabaseConnectionWhereInput | null;
  };

  export type EndpointConnectionIdPathMethodCompoundUniqueInput = {
    connectionId: string;
    path: string;
    method: $Enums.HttpMethod;
  };

  export type EndpointCountOrderByAggregateInput = {
    id?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    query?: SortOrder;
    queryParams?: SortOrder;
    bodySchema?: SortOrder;
    responseSchema?: SortOrder;
    apiKey?: SortOrder;
    isActive?: SortOrder;
    rateLimitPerMinute?: SortOrder;
    requiresAuth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type EndpointAvgOrderByAggregateInput = {
    rateLimitPerMinute?: SortOrder;
  };

  export type EndpointMaxOrderByAggregateInput = {
    id?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    query?: SortOrder;
    apiKey?: SortOrder;
    isActive?: SortOrder;
    rateLimitPerMinute?: SortOrder;
    requiresAuth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type EndpointMinOrderByAggregateInput = {
    id?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    query?: SortOrder;
    apiKey?: SortOrder;
    isActive?: SortOrder;
    rateLimitPerMinute?: SortOrder;
    requiresAuth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type EndpointSumOrderByAggregateInput = {
    rateLimitPerMinute?: SortOrder;
  };

  export type EnumHttpMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel> | $Enums.HttpMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHttpMethodFilter<$PrismaModel>;
    _max?: NestedEnumHttpMethodFilter<$PrismaModel>;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    keyHash?: SortOrder;
    keyPrefix?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    createdById?: SortOrder;
  };

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    keyHash?: SortOrder;
    keyPrefix?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    createdById?: SortOrder;
  };

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    keyHash?: SortOrder;
    keyPrefix?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    createdById?: SortOrder;
  };

  export type ApiKeyNullableScalarRelationFilter = {
    is?: ApiKeyWhereInput | null;
    isNot?: ApiKeyWhereInput | null;
  };

  export type UsageMetricCountOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    apiKeyId?: SortOrder;
  };

  export type UsageMetricAvgOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
  };

  export type UsageMetricMaxOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    apiKeyId?: SortOrder;
  };

  export type UsageMetricMinOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    apiKeyId?: SortOrder;
  };

  export type UsageMetricSumOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTimeMs?: SortOrder;
  };

  export type WorkflowExecutionListRelationFilter = {
    every?: WorkflowExecutionWhereInput;
    some?: WorkflowExecutionWhereInput;
    none?: WorkflowExecutionWhereInput;
  };

  export type WorkflowExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    definition?: SortOrder;
    isActive?: SortOrder;
    trigger?: SortOrder;
    lastRunAt?: SortOrder;
    runCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type WorkflowAvgOrderByAggregateInput = {
    runCount?: SortOrder;
  };

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    lastRunAt?: SortOrder;
    runCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    lastRunAt?: SortOrder;
    runCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type WorkflowSumOrderByAggregateInput = {
    runCount?: SortOrder;
  };

  export type EnumExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumExecutionStatusFilter<$PrismaModel> | $Enums.ExecutionStatus;
  };

  export type WorkflowScalarRelationFilter = {
    is?: WorkflowWhereInput;
    isNot?: WorkflowWhereInput;
  };

  export type WorkflowExecutionCountOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    error?: SortOrder;
    logs?: SortOrder;
    workflowId?: SortOrder;
  };

  export type WorkflowExecutionMaxOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    error?: SortOrder;
    workflowId?: SortOrder;
  };

  export type WorkflowExecutionMinOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    error?: SortOrder;
    workflowId?: SortOrder;
  };

  export type EnumExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExecutionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExecutionStatusFilter<$PrismaModel>;
    _max?: NestedEnumExecutionStatusFilter<$PrismaModel>;
  };

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    events?: SortOrder;
    secret?: SortOrder;
    isActive?: SortOrder;
    lastTriggeredAt?: SortOrder;
    failureCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type WebhookAvgOrderByAggregateInput = {
    failureCount?: SortOrder;
  };

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    secret?: SortOrder;
    isActive?: SortOrder;
    lastTriggeredAt?: SortOrder;
    failureCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    secret?: SortOrder;
    isActive?: SortOrder;
    lastTriggeredAt?: SortOrder;
    failureCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type WebhookSumOrderByAggregateInput = {
    failureCount?: SortOrder;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    metadata?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type ServiceOrganizationIdNameCompoundUniqueInput = {
    organizationId: string;
    name: string;
  };

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    objects?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type ServiceAvgOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    passwordEncrypted?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    connectionId?: SortOrder;
  };

  export type ServiceSumOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type ApplicationOrganizationIdNameCompoundUniqueInput = {
    organizationId: string;
    name: string;
  };

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    apiKeyHash?: SortOrder;
    apiKeyEncrypted?: SortOrder;
    apiKeyPrefix?: SortOrder;
    apiKeyHint?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    defaultRoleId?: SortOrder;
  };

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    apiKeyHash?: SortOrder;
    apiKeyEncrypted?: SortOrder;
    apiKeyPrefix?: SortOrder;
    apiKeyHint?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    defaultRoleId?: SortOrder;
  };

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    apiKeyHash?: SortOrder;
    apiKeyEncrypted?: SortOrder;
    apiKeyPrefix?: SortOrder;
    apiKeyHint?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    defaultRoleId?: SortOrder;
  };

  export type ExposedFieldPolicyListRelationFilter = {
    every?: ExposedFieldPolicyWhereInput;
    some?: ExposedFieldPolicyWhereInput;
    none?: ExposedFieldPolicyWhereInput;
  };

  export type ExposedRowPolicyListRelationFilter = {
    every?: ExposedRowPolicyWhereInput;
    some?: ExposedRowPolicyWhereInput;
    none?: ExposedRowPolicyWhereInput;
  };

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput;
    isNot?: ServiceWhereInput;
  };

  export type ExposedFieldPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ExposedRowPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleOrganizationIdServiceIdNameCompoundUniqueInput = {
    organizationId: string;
    serviceId: string;
    name: string;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    permissions?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdBy?: SortOrder;
  };

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType;
  };

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
  };

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
  };

  export type EndpointNullableScalarRelationFilter = {
    is?: EndpointWhereInput | null;
    isNot?: EndpointWhereInput | null;
  };

  export type ApiActivityLogCountOrderByAggregateInput = {
    id?: SortOrder;
    requestId?: SortOrder;
    timestamp?: SortOrder;
    method?: SortOrder;
    url?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    category?: SortOrder;
    endpointType?: SortOrder;
    importance?: SortOrder;
    error?: SortOrder;
    metadata?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    endpointId?: SortOrder;
  };

  export type ApiActivityLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTime?: SortOrder;
  };

  export type ApiActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    requestId?: SortOrder;
    timestamp?: SortOrder;
    method?: SortOrder;
    url?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    category?: SortOrder;
    endpointType?: SortOrder;
    importance?: SortOrder;
    error?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    endpointId?: SortOrder;
  };

  export type ApiActivityLogMinOrderByAggregateInput = {
    id?: SortOrder;
    requestId?: SortOrder;
    timestamp?: SortOrder;
    method?: SortOrder;
    url?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    category?: SortOrder;
    endpointType?: SortOrder;
    importance?: SortOrder;
    error?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    endpointId?: SortOrder;
  };

  export type ApiActivityLogSumOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTime?: SortOrder;
  };

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null;
    isNot?: ServiceWhereInput | null;
  };

  export type DatabaseObjectOrganizationIdServiceIdSchemaNameCompoundUniqueInput = {
    organizationId: string;
    serviceId: string;
    schema: string;
    name: string;
  };

  export type DatabaseObjectCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    schema?: SortOrder;
    type?: SortOrder;
    path?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
  };

  export type DatabaseObjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    schema?: SortOrder;
    type?: SortOrder;
    path?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
  };

  export type DatabaseObjectMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    schema?: SortOrder;
    type?: SortOrder;
    path?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
  };

  export type EnumExposedEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExposedEntityType | EnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExposedEntityTypeFilter<$PrismaModel> | $Enums.ExposedEntityType;
  };

  export type DatabaseConnectionScalarRelationFilter = {
    is?: DatabaseConnectionWhereInput;
    isNot?: DatabaseConnectionWhereInput;
  };

  export type ExposedEntityServiceIdSchemaNameCompoundUniqueInput = {
    serviceId: string;
    schema: string;
    name: string;
  };

  export type ExposedEntityCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    connectionId?: SortOrder;
    organizationId?: SortOrder;
    database?: SortOrder;
    schema?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    primaryKey?: SortOrder;
    allowRead?: SortOrder;
    allowCreate?: SortOrder;
    allowUpdate?: SortOrder;
    allowDelete?: SortOrder;
    defaultSort?: SortOrder;
    softDeleteEnabled?: SortOrder;
    softDeleteColumn?: SortOrder;
    softDeleteValue?: SortOrder;
    pathSlug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type ExposedEntityMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    connectionId?: SortOrder;
    organizationId?: SortOrder;
    database?: SortOrder;
    schema?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    primaryKey?: SortOrder;
    allowRead?: SortOrder;
    allowCreate?: SortOrder;
    allowUpdate?: SortOrder;
    allowDelete?: SortOrder;
    defaultSort?: SortOrder;
    softDeleteEnabled?: SortOrder;
    softDeleteColumn?: SortOrder;
    softDeleteValue?: SortOrder;
    pathSlug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type ExposedEntityMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    connectionId?: SortOrder;
    organizationId?: SortOrder;
    database?: SortOrder;
    schema?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    primaryKey?: SortOrder;
    allowRead?: SortOrder;
    allowCreate?: SortOrder;
    allowUpdate?: SortOrder;
    allowDelete?: SortOrder;
    defaultSort?: SortOrder;
    softDeleteEnabled?: SortOrder;
    softDeleteColumn?: SortOrder;
    softDeleteValue?: SortOrder;
    pathSlug?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type EnumExposedEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExposedEntityType | EnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExposedEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExposedEntityType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExposedEntityTypeFilter<$PrismaModel>;
    _max?: NestedEnumExposedEntityTypeFilter<$PrismaModel>;
  };

  export type ExposedEntityScalarRelationFilter = {
    is?: ExposedEntityWhereInput;
    isNot?: ExposedEntityWhereInput;
  };

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null;
    isNot?: RoleWhereInput | null;
  };

  export type ExposedFieldPolicyCountOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    includeFields?: SortOrder;
    excludeFields?: SortOrder;
    writeProtected?: SortOrder;
    maskedFields?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExposedFieldPolicyMaxOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExposedFieldPolicyMinOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExposedRowPolicyCountOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    filterTemplate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExposedRowPolicyMaxOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExposedRowPolicyMinOrderByAggregateInput = {
    id?: SortOrder;
    exposedEntityId?: SortOrder;
    roleId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TermsAndConditionsCountOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    effectiveDate?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TermsAndConditionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    effectiveDate?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TermsAndConditionsMinOrderByAggregateInput = {
    id?: SortOrder;
    version?: SortOrder;
    content?: SortOrder;
    summary?: SortOrder;
    effectiveDate?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumAcceptanceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceMethod | EnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumAcceptanceMethodFilter<$PrismaModel> | $Enums.AcceptanceMethod;
  };

  export type TermsAndConditionsScalarRelationFilter = {
    is?: TermsAndConditionsWhereInput;
    isNot?: TermsAndConditionsWhereInput;
  };

  export type TermsAcceptanceOrganizationIdUserIdTermsIdCompoundUniqueInput = {
    organizationId: string;
    userId: string;
    termsId: string;
  };

  export type TermsAcceptanceCountOrderByAggregateInput = {
    id?: SortOrder;
    acceptedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    geolocation?: SortOrder;
    acceptanceMethod?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    termsId?: SortOrder;
  };

  export type TermsAcceptanceMaxOrderByAggregateInput = {
    id?: SortOrder;
    acceptedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    acceptanceMethod?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    termsId?: SortOrder;
  };

  export type TermsAcceptanceMinOrderByAggregateInput = {
    id?: SortOrder;
    acceptedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    acceptanceMethod?: SortOrder;
    organizationId?: SortOrder;
    userId?: SortOrder;
    termsId?: SortOrder;
  };

  export type EnumAcceptanceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceMethod | EnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumAcceptanceMethodWithAggregatesFilter<$PrismaModel> | $Enums.AcceptanceMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAcceptanceMethodFilter<$PrismaModel>;
    _max?: NestedEnumAcceptanceMethodFilter<$PrismaModel>;
  };

  export type EnumRateLimitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitTypeFilter<$PrismaModel> | $Enums.RateLimitType;
  };

  export type EnumRateLimitKeyStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitKeyStrategy | EnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel> | $Enums.RateLimitKeyStrategy;
  };

  export type RateLimitConfigOrganizationIdNameCompoundUniqueInput = {
    organizationId: string;
    name: string;
  };

  export type RateLimitConfigCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    displayName?: SortOrder;
    type?: SortOrder;
    max?: SortOrder;
    windowMs?: SortOrder;
    keyStrategy?: SortOrder;
    enabled?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    applicationLimits?: SortOrder;
    roleLimits?: SortOrder;
    componentLimits?: SortOrder;
    changeHistory?: SortOrder;
    changeReason?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type RateLimitConfigAvgOrderByAggregateInput = {
    max?: SortOrder;
    windowMs?: SortOrder;
  };

  export type RateLimitConfigMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    displayName?: SortOrder;
    type?: SortOrder;
    max?: SortOrder;
    windowMs?: SortOrder;
    keyStrategy?: SortOrder;
    enabled?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    changeReason?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type RateLimitConfigMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    displayName?: SortOrder;
    type?: SortOrder;
    max?: SortOrder;
    windowMs?: SortOrder;
    keyStrategy?: SortOrder;
    enabled?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    changeReason?: SortOrder;
    organizationId?: SortOrder;
    createdBy?: SortOrder;
    updatedBy?: SortOrder;
  };

  export type RateLimitConfigSumOrderByAggregateInput = {
    max?: SortOrder;
    windowMs?: SortOrder;
  };

  export type EnumRateLimitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel> | $Enums.RateLimitType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRateLimitTypeFilter<$PrismaModel>;
    _max?: NestedEnumRateLimitTypeFilter<$PrismaModel>;
  };

  export type EnumRateLimitKeyStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitKeyStrategy | EnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRateLimitKeyStrategyWithAggregatesFilter<$PrismaModel>
      | $Enums.RateLimitKeyStrategy;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel>;
    _max?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel>;
  };

  export type RateLimitUsageOrganizationIdConfigNameLimitKeyCompoundUniqueInput = {
    organizationId: string;
    configName: string;
    limitKey: string;
  };

  export type RateLimitUsageCountOrderByAggregateInput = {
    id?: SortOrder;
    configName?: SortOrder;
    limitKey?: SortOrder;
    currentCount?: SortOrder;
    resetAt?: SortOrder;
    blocked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type RateLimitUsageAvgOrderByAggregateInput = {
    currentCount?: SortOrder;
  };

  export type RateLimitUsageMaxOrderByAggregateInput = {
    id?: SortOrder;
    configName?: SortOrder;
    limitKey?: SortOrder;
    currentCount?: SortOrder;
    resetAt?: SortOrder;
    blocked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type RateLimitUsageMinOrderByAggregateInput = {
    id?: SortOrder;
    configName?: SortOrder;
    limitKey?: SortOrder;
    currentCount?: SortOrder;
    resetAt?: SortOrder;
    blocked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    organizationId?: SortOrder;
  };

  export type RateLimitUsageSumOrderByAggregateInput = {
    currentCount?: SortOrder;
  };

  export type SocialAccountProviderProviderIdCompoundUniqueInput = {
    provider: string;
    providerId: string;
  };

  export type SocialAccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    providerId?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profileUrl?: SortOrder;
    avatarUrl?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    profileData?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SocialAccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    providerId?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profileUrl?: SortOrder;
    avatarUrl?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    profileData?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SocialAccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    provider?: SortOrder;
    providerId?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    profileUrl?: SortOrder;
    avatarUrl?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    profileData?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApiActivityLogCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutOrganizationInput,
          ApiActivityLogUncheckedCreateWithoutOrganizationInput
        >
      | ApiActivityLogCreateWithoutOrganizationInput[]
      | ApiActivityLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApiActivityLogCreateManyOrganizationInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiKeyCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
      | ApiKeyCreateWithoutOrganizationInput[]
      | ApiKeyUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutOrganizationInput
      | ApiKeyCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type ApplicationCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutOrganizationInput,
          ApplicationUncheckedCreateWithoutOrganizationInput
        >
      | ApplicationCreateWithoutOrganizationInput[]
      | ApplicationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutOrganizationInput
      | ApplicationCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApplicationCreateManyOrganizationInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
      | AuditLogCreateWithoutOrganizationInput[]
      | AuditLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutOrganizationInput
      | AuditLogCreateOrConnectWithoutOrganizationInput[];
    createMany?: AuditLogCreateManyOrganizationInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type DatabaseConnectionCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutOrganizationInput,
          DatabaseConnectionUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseConnectionCreateWithoutOrganizationInput[]
      | DatabaseConnectionUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput[];
    createMany?: DatabaseConnectionCreateManyOrganizationInputEnvelope;
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
  };

  export type DatabaseObjectCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutOrganizationInput,
          DatabaseObjectUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseObjectCreateWithoutOrganizationInput[]
      | DatabaseObjectUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput[];
    createMany?: DatabaseObjectCreateManyOrganizationInputEnvelope;
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
  };

  export type EndpointCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<EndpointCreateWithoutOrganizationInput, EndpointUncheckedCreateWithoutOrganizationInput>
      | EndpointCreateWithoutOrganizationInput[]
      | EndpointUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutOrganizationInput
      | EndpointCreateOrConnectWithoutOrganizationInput[];
    createMany?: EndpointCreateManyOrganizationInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutOrganizationInput,
          ExposedEntityUncheckedCreateWithoutOrganizationInput
        >
      | ExposedEntityCreateWithoutOrganizationInput[]
      | ExposedEntityUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutOrganizationInput
      | ExposedEntityCreateOrConnectWithoutOrganizationInput[];
    createMany?: ExposedEntityCreateManyOrganizationInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type InvitationCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          InvitationCreateWithoutOrganizationInput,
          InvitationUncheckedCreateWithoutOrganizationInput
        >
      | InvitationCreateWithoutOrganizationInput[]
      | InvitationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutOrganizationInput
      | InvitationCreateOrConnectWithoutOrganizationInput[];
    createMany?: InvitationCreateManyOrganizationInputEnvelope;
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
  };

  export type MembershipCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          NotificationCreateWithoutOrganizationInput,
          NotificationUncheckedCreateWithoutOrganizationInput
        >
      | NotificationCreateWithoutOrganizationInput[]
      | NotificationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutOrganizationInput
      | NotificationCreateOrConnectWithoutOrganizationInput[];
    createMany?: NotificationCreateManyOrganizationInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
      | RoleCreateWithoutOrganizationInput[]
      | RoleUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutOrganizationInput
      | RoleCreateOrConnectWithoutOrganizationInput[];
    createMany?: RoleCreateManyOrganizationInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<ServiceCreateWithoutOrganizationInput, ServiceUncheckedCreateWithoutOrganizationInput>
      | ServiceCreateWithoutOrganizationInput[]
      | ServiceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutOrganizationInput
      | ServiceCreateOrConnectWithoutOrganizationInput[];
    createMany?: ServiceCreateManyOrganizationInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type SubscriptionCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type TermsAcceptanceCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          TermsAcceptanceCreateWithoutOrganizationInput,
          TermsAcceptanceUncheckedCreateWithoutOrganizationInput
        >
      | TermsAcceptanceCreateWithoutOrganizationInput[]
      | TermsAcceptanceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput[];
    createMany?: TermsAcceptanceCreateManyOrganizationInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type UsageMetricCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          UsageMetricCreateWithoutOrganizationInput,
          UsageMetricUncheckedCreateWithoutOrganizationInput
        >
      | UsageMetricCreateWithoutOrganizationInput[]
      | UsageMetricUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutOrganizationInput
      | UsageMetricCreateOrConnectWithoutOrganizationInput[];
    createMany?: UsageMetricCreateManyOrganizationInputEnvelope;
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
  };

  export type WebhookCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
      | WebhookCreateWithoutOrganizationInput[]
      | WebhookUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WebhookCreateOrConnectWithoutOrganizationInput
      | WebhookCreateOrConnectWithoutOrganizationInput[];
    createMany?: WebhookCreateManyOrganizationInputEnvelope;
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
  };

  export type WorkflowCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<WorkflowCreateWithoutOrganizationInput, WorkflowUncheckedCreateWithoutOrganizationInput>
      | WorkflowCreateWithoutOrganizationInput[]
      | WorkflowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutOrganizationInput
      | WorkflowCreateOrConnectWithoutOrganizationInput[];
    createMany?: WorkflowCreateManyOrganizationInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type RateLimitConfigCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutOrganizationInput,
          RateLimitConfigUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitConfigCreateWithoutOrganizationInput[]
      | RateLimitConfigUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput[];
    createMany?: RateLimitConfigCreateManyOrganizationInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type RateLimitUsageCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          RateLimitUsageCreateWithoutOrganizationInput,
          RateLimitUsageUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitUsageCreateWithoutOrganizationInput[]
      | RateLimitUsageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput[];
    createMany?: RateLimitUsageCreateManyOrganizationInputEnvelope;
    connect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
  };

  export type BillingEventCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutOrganizationInput,
          BillingEventUncheckedCreateWithoutOrganizationInput
        >
      | BillingEventCreateWithoutOrganizationInput[]
      | BillingEventUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutOrganizationInput
      | BillingEventCreateOrConnectWithoutOrganizationInput[];
    createMany?: BillingEventCreateManyOrganizationInputEnvelope;
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
  };

  export type ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutOrganizationInput,
          ApiActivityLogUncheckedCreateWithoutOrganizationInput
        >
      | ApiActivityLogCreateWithoutOrganizationInput[]
      | ApiActivityLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApiActivityLogCreateManyOrganizationInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
      | ApiKeyCreateWithoutOrganizationInput[]
      | ApiKeyUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutOrganizationInput
      | ApiKeyCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type ApplicationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutOrganizationInput,
          ApplicationUncheckedCreateWithoutOrganizationInput
        >
      | ApplicationCreateWithoutOrganizationInput[]
      | ApplicationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutOrganizationInput
      | ApplicationCreateOrConnectWithoutOrganizationInput[];
    createMany?: ApplicationCreateManyOrganizationInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
      | AuditLogCreateWithoutOrganizationInput[]
      | AuditLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutOrganizationInput
      | AuditLogCreateOrConnectWithoutOrganizationInput[];
    createMany?: AuditLogCreateManyOrganizationInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutOrganizationInput,
          DatabaseConnectionUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseConnectionCreateWithoutOrganizationInput[]
      | DatabaseConnectionUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput[];
    createMany?: DatabaseConnectionCreateManyOrganizationInputEnvelope;
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
  };

  export type DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutOrganizationInput,
          DatabaseObjectUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseObjectCreateWithoutOrganizationInput[]
      | DatabaseObjectUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput[];
    createMany?: DatabaseObjectCreateManyOrganizationInputEnvelope;
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<EndpointCreateWithoutOrganizationInput, EndpointUncheckedCreateWithoutOrganizationInput>
      | EndpointCreateWithoutOrganizationInput[]
      | EndpointUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutOrganizationInput
      | EndpointCreateOrConnectWithoutOrganizationInput[];
    createMany?: EndpointCreateManyOrganizationInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutOrganizationInput,
          ExposedEntityUncheckedCreateWithoutOrganizationInput
        >
      | ExposedEntityCreateWithoutOrganizationInput[]
      | ExposedEntityUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutOrganizationInput
      | ExposedEntityCreateOrConnectWithoutOrganizationInput[];
    createMany?: ExposedEntityCreateManyOrganizationInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type InvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          InvitationCreateWithoutOrganizationInput,
          InvitationUncheckedCreateWithoutOrganizationInput
        >
      | InvitationCreateWithoutOrganizationInput[]
      | InvitationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutOrganizationInput
      | InvitationCreateOrConnectWithoutOrganizationInput[];
    createMany?: InvitationCreateManyOrganizationInputEnvelope;
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
  };

  export type MembershipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          NotificationCreateWithoutOrganizationInput,
          NotificationUncheckedCreateWithoutOrganizationInput
        >
      | NotificationCreateWithoutOrganizationInput[]
      | NotificationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutOrganizationInput
      | NotificationCreateOrConnectWithoutOrganizationInput[];
    createMany?: NotificationCreateManyOrganizationInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
      | RoleCreateWithoutOrganizationInput[]
      | RoleUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutOrganizationInput
      | RoleCreateOrConnectWithoutOrganizationInput[];
    createMany?: RoleCreateManyOrganizationInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<ServiceCreateWithoutOrganizationInput, ServiceUncheckedCreateWithoutOrganizationInput>
      | ServiceCreateWithoutOrganizationInput[]
      | ServiceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutOrganizationInput
      | ServiceCreateOrConnectWithoutOrganizationInput[];
    createMany?: ServiceCreateManyOrganizationInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          TermsAcceptanceCreateWithoutOrganizationInput,
          TermsAcceptanceUncheckedCreateWithoutOrganizationInput
        >
      | TermsAcceptanceCreateWithoutOrganizationInput[]
      | TermsAcceptanceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput[];
    createMany?: TermsAcceptanceCreateManyOrganizationInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          UsageMetricCreateWithoutOrganizationInput,
          UsageMetricUncheckedCreateWithoutOrganizationInput
        >
      | UsageMetricCreateWithoutOrganizationInput[]
      | UsageMetricUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutOrganizationInput
      | UsageMetricCreateOrConnectWithoutOrganizationInput[];
    createMany?: UsageMetricCreateManyOrganizationInputEnvelope;
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
  };

  export type WebhookUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
      | WebhookCreateWithoutOrganizationInput[]
      | WebhookUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WebhookCreateOrConnectWithoutOrganizationInput
      | WebhookCreateOrConnectWithoutOrganizationInput[];
    createMany?: WebhookCreateManyOrganizationInputEnvelope;
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
  };

  export type WorkflowUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<WorkflowCreateWithoutOrganizationInput, WorkflowUncheckedCreateWithoutOrganizationInput>
      | WorkflowCreateWithoutOrganizationInput[]
      | WorkflowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutOrganizationInput
      | WorkflowCreateOrConnectWithoutOrganizationInput[];
    createMany?: WorkflowCreateManyOrganizationInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutOrganizationInput,
          RateLimitConfigUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitConfigCreateWithoutOrganizationInput[]
      | RateLimitConfigUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput[];
    createMany?: RateLimitConfigCreateManyOrganizationInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          RateLimitUsageCreateWithoutOrganizationInput,
          RateLimitUsageUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitUsageCreateWithoutOrganizationInput[]
      | RateLimitUsageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput[];
    createMany?: RateLimitUsageCreateManyOrganizationInputEnvelope;
    connect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
  };

  export type BillingEventUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutOrganizationInput,
          BillingEventUncheckedCreateWithoutOrganizationInput
        >
      | BillingEventCreateWithoutOrganizationInput[]
      | BillingEventUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutOrganizationInput
      | BillingEventCreateOrConnectWithoutOrganizationInput[];
    createMany?: BillingEventCreateManyOrganizationInputEnvelope;
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type ApiActivityLogUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutOrganizationInput,
          ApiActivityLogUncheckedCreateWithoutOrganizationInput
        >
      | ApiActivityLogCreateWithoutOrganizationInput[]
      | ApiActivityLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutOrganizationInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApiActivityLogCreateManyOrganizationInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutOrganizationInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutOrganizationInput
      | ApiActivityLogUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiKeyUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
      | ApiKeyCreateWithoutOrganizationInput[]
      | ApiKeyUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutOrganizationInput
      | ApiKeyCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput
      | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput
      | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutOrganizationInput
      | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type ApplicationUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutOrganizationInput,
          ApplicationUncheckedCreateWithoutOrganizationInput
        >
      | ApplicationCreateWithoutOrganizationInput[]
      | ApplicationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutOrganizationInput
      | ApplicationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput
      | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApplicationCreateManyOrganizationInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput
      | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutOrganizationInput
      | ApplicationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
      | AuditLogCreateWithoutOrganizationInput[]
      | AuditLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutOrganizationInput
      | AuditLogCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput
      | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: AuditLogCreateManyOrganizationInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput
      | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutOrganizationInput
      | AuditLogUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type DatabaseConnectionUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutOrganizationInput,
          DatabaseConnectionUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseConnectionCreateWithoutOrganizationInput[]
      | DatabaseConnectionUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | DatabaseConnectionUpsertWithWhereUniqueWithoutOrganizationInput
      | DatabaseConnectionUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: DatabaseConnectionCreateManyOrganizationInputEnvelope;
    set?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    disconnect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    delete?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    update?:
      | DatabaseConnectionUpdateWithWhereUniqueWithoutOrganizationInput
      | DatabaseConnectionUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | DatabaseConnectionUpdateManyWithWhereWithoutOrganizationInput
      | DatabaseConnectionUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
  };

  export type DatabaseObjectUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutOrganizationInput,
          DatabaseObjectUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseObjectCreateWithoutOrganizationInput[]
      | DatabaseObjectUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | DatabaseObjectUpsertWithWhereUniqueWithoutOrganizationInput
      | DatabaseObjectUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: DatabaseObjectCreateManyOrganizationInputEnvelope;
    set?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    disconnect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    delete?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    update?:
      | DatabaseObjectUpdateWithWhereUniqueWithoutOrganizationInput
      | DatabaseObjectUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | DatabaseObjectUpdateManyWithWhereWithoutOrganizationInput
      | DatabaseObjectUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
  };

  export type EndpointUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutOrganizationInput, EndpointUncheckedCreateWithoutOrganizationInput>
      | EndpointCreateWithoutOrganizationInput[]
      | EndpointUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutOrganizationInput
      | EndpointCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutOrganizationInput
      | EndpointUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: EndpointCreateManyOrganizationInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutOrganizationInput
      | EndpointUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutOrganizationInput
      | EndpointUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutOrganizationInput,
          ExposedEntityUncheckedCreateWithoutOrganizationInput
        >
      | ExposedEntityCreateWithoutOrganizationInput[]
      | ExposedEntityUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutOrganizationInput
      | ExposedEntityCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutOrganizationInput
      | ExposedEntityUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ExposedEntityCreateManyOrganizationInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutOrganizationInput
      | ExposedEntityUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutOrganizationInput
      | ExposedEntityUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type InvitationUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          InvitationCreateWithoutOrganizationInput,
          InvitationUncheckedCreateWithoutOrganizationInput
        >
      | InvitationCreateWithoutOrganizationInput[]
      | InvitationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutOrganizationInput
      | InvitationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | InvitationUpsertWithWhereUniqueWithoutOrganizationInput
      | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: InvitationCreateManyOrganizationInputEnvelope;
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    update?:
      | InvitationUpdateWithWhereUniqueWithoutOrganizationInput
      | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | InvitationUpdateManyWithWhereWithoutOrganizationInput
      | InvitationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
  };

  export type MembershipUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutOrganizationInput
      | MembershipUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutOrganizationInput,
          NotificationUncheckedCreateWithoutOrganizationInput
        >
      | NotificationCreateWithoutOrganizationInput[]
      | NotificationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutOrganizationInput
      | NotificationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutOrganizationInput
      | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: NotificationCreateManyOrganizationInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutOrganizationInput
      | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutOrganizationInput
      | NotificationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
      | RoleCreateWithoutOrganizationInput[]
      | RoleUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutOrganizationInput
      | RoleCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutOrganizationInput
      | RoleUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RoleCreateManyOrganizationInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutOrganizationInput
      | RoleUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutOrganizationInput
      | RoleUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutOrganizationInput, ServiceUncheckedCreateWithoutOrganizationInput>
      | ServiceCreateWithoutOrganizationInput[]
      | ServiceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutOrganizationInput
      | ServiceCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutOrganizationInput
      | ServiceUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ServiceCreateManyOrganizationInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutOrganizationInput
      | ServiceUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutOrganizationInput
      | ServiceUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type SubscriptionUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput;
    upsert?: SubscriptionUpsertWithoutOrganizationInput;
    disconnect?: SubscriptionWhereInput | boolean;
    delete?: SubscriptionWhereInput | boolean;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutOrganizationInput,
        SubscriptionUpdateWithoutOrganizationInput
      >,
      SubscriptionUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          TermsAcceptanceCreateWithoutOrganizationInput,
          TermsAcceptanceUncheckedCreateWithoutOrganizationInput
        >
      | TermsAcceptanceCreateWithoutOrganizationInput[]
      | TermsAcceptanceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutOrganizationInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: TermsAcceptanceCreateManyOrganizationInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutOrganizationInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutOrganizationInput
      | TermsAcceptanceUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type UsageMetricUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          UsageMetricCreateWithoutOrganizationInput,
          UsageMetricUncheckedCreateWithoutOrganizationInput
        >
      | UsageMetricCreateWithoutOrganizationInput[]
      | UsageMetricUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutOrganizationInput
      | UsageMetricCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | UsageMetricUpsertWithWhereUniqueWithoutOrganizationInput
      | UsageMetricUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: UsageMetricCreateManyOrganizationInputEnvelope;
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    update?:
      | UsageMetricUpdateWithWhereUniqueWithoutOrganizationInput
      | UsageMetricUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | UsageMetricUpdateManyWithWhereWithoutOrganizationInput
      | UsageMetricUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
  };

  export type WebhookUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
      | WebhookCreateWithoutOrganizationInput[]
      | WebhookUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WebhookCreateOrConnectWithoutOrganizationInput
      | WebhookCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | WebhookUpsertWithWhereUniqueWithoutOrganizationInput
      | WebhookUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: WebhookCreateManyOrganizationInputEnvelope;
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    update?:
      | WebhookUpdateWithWhereUniqueWithoutOrganizationInput
      | WebhookUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | WebhookUpdateManyWithWhereWithoutOrganizationInput
      | WebhookUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[];
  };

  export type WorkflowUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutOrganizationInput, WorkflowUncheckedCreateWithoutOrganizationInput>
      | WorkflowCreateWithoutOrganizationInput[]
      | WorkflowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutOrganizationInput
      | WorkflowCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutOrganizationInput
      | WorkflowUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: WorkflowCreateManyOrganizationInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutOrganizationInput
      | WorkflowUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutOrganizationInput
      | WorkflowUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type RateLimitConfigUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutOrganizationInput,
          RateLimitConfigUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitConfigCreateWithoutOrganizationInput[]
      | RateLimitConfigUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutOrganizationInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RateLimitConfigCreateManyOrganizationInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutOrganizationInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutOrganizationInput
      | RateLimitConfigUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type RateLimitUsageUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          RateLimitUsageCreateWithoutOrganizationInput,
          RateLimitUsageUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitUsageCreateWithoutOrganizationInput[]
      | RateLimitUsageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RateLimitUsageUpsertWithWhereUniqueWithoutOrganizationInput
      | RateLimitUsageUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RateLimitUsageCreateManyOrganizationInputEnvelope;
    set?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    disconnect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    delete?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    connect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    update?:
      | RateLimitUsageUpdateWithWhereUniqueWithoutOrganizationInput
      | RateLimitUsageUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RateLimitUsageUpdateManyWithWhereWithoutOrganizationInput
      | RateLimitUsageUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RateLimitUsageScalarWhereInput | RateLimitUsageScalarWhereInput[];
  };

  export type BillingEventUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutOrganizationInput,
          BillingEventUncheckedCreateWithoutOrganizationInput
        >
      | BillingEventCreateWithoutOrganizationInput[]
      | BillingEventUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutOrganizationInput
      | BillingEventCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | BillingEventUpsertWithWhereUniqueWithoutOrganizationInput
      | BillingEventUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: BillingEventCreateManyOrganizationInputEnvelope;
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    update?:
      | BillingEventUpdateWithWhereUniqueWithoutOrganizationInput
      | BillingEventUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | BillingEventUpdateManyWithWhereWithoutOrganizationInput
      | BillingEventUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutOrganizationInput,
          ApiActivityLogUncheckedCreateWithoutOrganizationInput
        >
      | ApiActivityLogCreateWithoutOrganizationInput[]
      | ApiActivityLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput
      | ApiActivityLogCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutOrganizationInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApiActivityLogCreateManyOrganizationInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutOrganizationInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutOrganizationInput
      | ApiActivityLogUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutOrganizationInput, ApiKeyUncheckedCreateWithoutOrganizationInput>
      | ApiKeyCreateWithoutOrganizationInput[]
      | ApiKeyUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutOrganizationInput
      | ApiKeyCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput
      | ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApiKeyCreateManyOrganizationInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput
      | ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutOrganizationInput
      | ApiKeyUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutOrganizationInput,
          ApplicationUncheckedCreateWithoutOrganizationInput
        >
      | ApplicationCreateWithoutOrganizationInput[]
      | ApplicationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutOrganizationInput
      | ApplicationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput
      | ApplicationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ApplicationCreateManyOrganizationInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput
      | ApplicationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutOrganizationInput
      | ApplicationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
      | AuditLogCreateWithoutOrganizationInput[]
      | AuditLogUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutOrganizationInput
      | AuditLogCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput
      | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: AuditLogCreateManyOrganizationInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput
      | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutOrganizationInput
      | AuditLogUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutOrganizationInput,
          DatabaseConnectionUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseConnectionCreateWithoutOrganizationInput[]
      | DatabaseConnectionUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput
      | DatabaseConnectionCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | DatabaseConnectionUpsertWithWhereUniqueWithoutOrganizationInput
      | DatabaseConnectionUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: DatabaseConnectionCreateManyOrganizationInputEnvelope;
    set?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    disconnect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    delete?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    update?:
      | DatabaseConnectionUpdateWithWhereUniqueWithoutOrganizationInput
      | DatabaseConnectionUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | DatabaseConnectionUpdateManyWithWhereWithoutOrganizationInput
      | DatabaseConnectionUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
  };

  export type DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutOrganizationInput,
          DatabaseObjectUncheckedCreateWithoutOrganizationInput
        >
      | DatabaseObjectCreateWithoutOrganizationInput[]
      | DatabaseObjectUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput
      | DatabaseObjectCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | DatabaseObjectUpsertWithWhereUniqueWithoutOrganizationInput
      | DatabaseObjectUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: DatabaseObjectCreateManyOrganizationInputEnvelope;
    set?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    disconnect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    delete?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    update?:
      | DatabaseObjectUpdateWithWhereUniqueWithoutOrganizationInput
      | DatabaseObjectUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | DatabaseObjectUpdateManyWithWhereWithoutOrganizationInput
      | DatabaseObjectUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutOrganizationInput, EndpointUncheckedCreateWithoutOrganizationInput>
      | EndpointCreateWithoutOrganizationInput[]
      | EndpointUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutOrganizationInput
      | EndpointCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutOrganizationInput
      | EndpointUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: EndpointCreateManyOrganizationInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutOrganizationInput
      | EndpointUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutOrganizationInput
      | EndpointUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutOrganizationInput,
          ExposedEntityUncheckedCreateWithoutOrganizationInput
        >
      | ExposedEntityCreateWithoutOrganizationInput[]
      | ExposedEntityUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutOrganizationInput
      | ExposedEntityCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutOrganizationInput
      | ExposedEntityUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ExposedEntityCreateManyOrganizationInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutOrganizationInput
      | ExposedEntityUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutOrganizationInput
      | ExposedEntityUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type InvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          InvitationCreateWithoutOrganizationInput,
          InvitationUncheckedCreateWithoutOrganizationInput
        >
      | InvitationCreateWithoutOrganizationInput[]
      | InvitationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutOrganizationInput
      | InvitationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | InvitationUpsertWithWhereUniqueWithoutOrganizationInput
      | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: InvitationCreateManyOrganizationInputEnvelope;
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    update?:
      | InvitationUpdateWithWhereUniqueWithoutOrganizationInput
      | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | InvitationUpdateManyWithWhereWithoutOrganizationInput
      | InvitationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
  };

  export type MembershipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          MembershipCreateWithoutOrganizationInput,
          MembershipUncheckedCreateWithoutOrganizationInput
        >
      | MembershipCreateWithoutOrganizationInput[]
      | MembershipUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutOrganizationInput
      | MembershipCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput
      | MembershipUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: MembershipCreateManyOrganizationInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput
      | MembershipUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutOrganizationInput
      | MembershipUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutOrganizationInput,
          NotificationUncheckedCreateWithoutOrganizationInput
        >
      | NotificationCreateWithoutOrganizationInput[]
      | NotificationUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutOrganizationInput
      | NotificationCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutOrganizationInput
      | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: NotificationCreateManyOrganizationInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutOrganizationInput
      | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutOrganizationInput
      | NotificationUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>
      | RoleCreateWithoutOrganizationInput[]
      | RoleUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutOrganizationInput
      | RoleCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutOrganizationInput
      | RoleUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RoleCreateManyOrganizationInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutOrganizationInput
      | RoleUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutOrganizationInput
      | RoleUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutOrganizationInput, ServiceUncheckedCreateWithoutOrganizationInput>
      | ServiceCreateWithoutOrganizationInput[]
      | ServiceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutOrganizationInput
      | ServiceCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutOrganizationInput
      | ServiceUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: ServiceCreateManyOrganizationInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutOrganizationInput
      | ServiceUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutOrganizationInput
      | ServiceUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOrganizationInput;
    upsert?: SubscriptionUpsertWithoutOrganizationInput;
    disconnect?: SubscriptionWhereInput | boolean;
    delete?: SubscriptionWhereInput | boolean;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutOrganizationInput,
        SubscriptionUpdateWithoutOrganizationInput
      >,
      SubscriptionUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          TermsAcceptanceCreateWithoutOrganizationInput,
          TermsAcceptanceUncheckedCreateWithoutOrganizationInput
        >
      | TermsAcceptanceCreateWithoutOrganizationInput[]
      | TermsAcceptanceUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput
      | TermsAcceptanceCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutOrganizationInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: TermsAcceptanceCreateManyOrganizationInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutOrganizationInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutOrganizationInput
      | TermsAcceptanceUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          UsageMetricCreateWithoutOrganizationInput,
          UsageMetricUncheckedCreateWithoutOrganizationInput
        >
      | UsageMetricCreateWithoutOrganizationInput[]
      | UsageMetricUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutOrganizationInput
      | UsageMetricCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | UsageMetricUpsertWithWhereUniqueWithoutOrganizationInput
      | UsageMetricUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: UsageMetricCreateManyOrganizationInputEnvelope;
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    update?:
      | UsageMetricUpdateWithWhereUniqueWithoutOrganizationInput
      | UsageMetricUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | UsageMetricUpdateManyWithWhereWithoutOrganizationInput
      | UsageMetricUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
  };

  export type WebhookUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<WebhookCreateWithoutOrganizationInput, WebhookUncheckedCreateWithoutOrganizationInput>
      | WebhookCreateWithoutOrganizationInput[]
      | WebhookUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WebhookCreateOrConnectWithoutOrganizationInput
      | WebhookCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | WebhookUpsertWithWhereUniqueWithoutOrganizationInput
      | WebhookUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: WebhookCreateManyOrganizationInputEnvelope;
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[];
    update?:
      | WebhookUpdateWithWhereUniqueWithoutOrganizationInput
      | WebhookUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | WebhookUpdateManyWithWhereWithoutOrganizationInput
      | WebhookUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[];
  };

  export type WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutOrganizationInput, WorkflowUncheckedCreateWithoutOrganizationInput>
      | WorkflowCreateWithoutOrganizationInput[]
      | WorkflowUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutOrganizationInput
      | WorkflowCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutOrganizationInput
      | WorkflowUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: WorkflowCreateManyOrganizationInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutOrganizationInput
      | WorkflowUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutOrganizationInput
      | WorkflowUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutOrganizationInput,
          RateLimitConfigUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitConfigCreateWithoutOrganizationInput[]
      | RateLimitConfigUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput
      | RateLimitConfigCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutOrganizationInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RateLimitConfigCreateManyOrganizationInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutOrganizationInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutOrganizationInput
      | RateLimitConfigUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          RateLimitUsageCreateWithoutOrganizationInput,
          RateLimitUsageUncheckedCreateWithoutOrganizationInput
        >
      | RateLimitUsageCreateWithoutOrganizationInput[]
      | RateLimitUsageUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput
      | RateLimitUsageCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | RateLimitUsageUpsertWithWhereUniqueWithoutOrganizationInput
      | RateLimitUsageUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: RateLimitUsageCreateManyOrganizationInputEnvelope;
    set?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    disconnect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    delete?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    connect?: RateLimitUsageWhereUniqueInput | RateLimitUsageWhereUniqueInput[];
    update?:
      | RateLimitUsageUpdateWithWhereUniqueWithoutOrganizationInput
      | RateLimitUsageUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | RateLimitUsageUpdateManyWithWhereWithoutOrganizationInput
      | RateLimitUsageUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: RateLimitUsageScalarWhereInput | RateLimitUsageScalarWhereInput[];
  };

  export type BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutOrganizationInput,
          BillingEventUncheckedCreateWithoutOrganizationInput
        >
      | BillingEventCreateWithoutOrganizationInput[]
      | BillingEventUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutOrganizationInput
      | BillingEventCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | BillingEventUpsertWithWhereUniqueWithoutOrganizationInput
      | BillingEventUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: BillingEventCreateManyOrganizationInputEnvelope;
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    update?:
      | BillingEventUpdateWithWhereUniqueWithoutOrganizationInput
      | BillingEventUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | BillingEventUpdateManyWithWhereWithoutOrganizationInput
      | BillingEventUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
  };

  export type ApiActivityLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiKeyCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>
      | ApiKeyCreateWithoutCreatedByInput[]
      | ApiKeyUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutCreatedByInput
      | ApiKeyCreateOrConnectWithoutCreatedByInput[];
    createMany?: ApiKeyCreateManyCreatedByInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type ApplicationCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatorInput, ApplicationUncheckedCreateWithoutCreatorInput>
      | ApplicationCreateWithoutCreatorInput[]
      | ApplicationUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatorInput
      | ApplicationCreateOrConnectWithoutCreatorInput[];
    createMany?: ApplicationCreateManyCreatorInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type DatabaseConnectionCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutCreatorInput,
          DatabaseConnectionUncheckedCreateWithoutCreatorInput
        >
      | DatabaseConnectionCreateWithoutCreatorInput[]
      | DatabaseConnectionUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput[];
    createMany?: DatabaseConnectionCreateManyCreatorInputEnvelope;
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
  };

  export type EndpointCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>
      | EndpointCreateWithoutCreatorInput[]
      | EndpointUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatorInput
      | EndpointCreateOrConnectWithoutCreatorInput[];
    createMany?: EndpointCreateManyCreatorInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutCreatorInput, ExposedEntityUncheckedCreateWithoutCreatorInput>
      | ExposedEntityCreateWithoutCreatorInput[]
      | ExposedEntityUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutCreatorInput
      | ExposedEntityCreateOrConnectWithoutCreatorInput[];
    createMany?: ExposedEntityCreateManyCreatorInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type InvitationCreateNestedManyWithoutInvitedByInput = {
    create?:
      | XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
      | InvitationCreateWithoutInvitedByInput[]
      | InvitationUncheckedCreateWithoutInvitedByInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutInvitedByInput
      | InvitationCreateOrConnectWithoutInvitedByInput[];
    createMany?: InvitationCreateManyInvitedByInputEnvelope;
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
  };

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
      | RoleCreateWithoutCreatorInput[]
      | RoleUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatorInput
      | RoleCreateOrConnectWithoutCreatorInput[];
    createMany?: RoleCreateManyCreatorInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>
      | ServiceCreateWithoutCreatorInput[]
      | ServiceUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatorInput
      | ServiceCreateOrConnectWithoutCreatorInput[];
    createMany?: ServiceCreateManyCreatorInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type TermsAcceptanceCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutUserInput, TermsAcceptanceUncheckedCreateWithoutUserInput>
      | TermsAcceptanceCreateWithoutUserInput[]
      | TermsAcceptanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutUserInput
      | TermsAcceptanceCreateOrConnectWithoutUserInput[];
    createMany?: TermsAcceptanceCreateManyUserInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type WorkflowCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>
      | WorkflowCreateWithoutCreatorInput[]
      | WorkflowUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatorInput
      | WorkflowCreateOrConnectWithoutCreatorInput[];
    createMany?: WorkflowCreateManyCreatorInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type RateLimitConfigCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutCreatorInput,
          RateLimitConfigUncheckedCreateWithoutCreatorInput
        >
      | RateLimitConfigCreateWithoutCreatorInput[]
      | RateLimitConfigUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutCreatorInput
      | RateLimitConfigCreateOrConnectWithoutCreatorInput[];
    createMany?: RateLimitConfigCreateManyCreatorInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type RateLimitConfigCreateNestedManyWithoutUpdaterInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutUpdaterInput,
          RateLimitConfigUncheckedCreateWithoutUpdaterInput
        >
      | RateLimitConfigCreateWithoutUpdaterInput[]
      | RateLimitConfigUncheckedCreateWithoutUpdaterInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput[];
    createMany?: RateLimitConfigCreateManyUpdaterInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type SocialAccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
      | SocialAccountCreateWithoutUserInput[]
      | SocialAccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SocialAccountCreateOrConnectWithoutUserInput
      | SocialAccountCreateOrConnectWithoutUserInput[];
    createMany?: SocialAccountCreateManyUserInputEnvelope;
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
  };

  export type ApiActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>
      | ApiKeyCreateWithoutCreatedByInput[]
      | ApiKeyUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutCreatedByInput
      | ApiKeyCreateOrConnectWithoutCreatedByInput[];
    createMany?: ApiKeyCreateManyCreatedByInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type ApplicationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatorInput, ApplicationUncheckedCreateWithoutCreatorInput>
      | ApplicationCreateWithoutCreatorInput[]
      | ApplicationUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatorInput
      | ApplicationCreateOrConnectWithoutCreatorInput[];
    createMany?: ApplicationCreateManyCreatorInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutCreatorInput,
          DatabaseConnectionUncheckedCreateWithoutCreatorInput
        >
      | DatabaseConnectionCreateWithoutCreatorInput[]
      | DatabaseConnectionUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput[];
    createMany?: DatabaseConnectionCreateManyCreatorInputEnvelope;
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>
      | EndpointCreateWithoutCreatorInput[]
      | EndpointUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatorInput
      | EndpointCreateOrConnectWithoutCreatorInput[];
    createMany?: EndpointCreateManyCreatorInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutCreatorInput, ExposedEntityUncheckedCreateWithoutCreatorInput>
      | ExposedEntityCreateWithoutCreatorInput[]
      | ExposedEntityUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutCreatorInput
      | ExposedEntityCreateOrConnectWithoutCreatorInput[];
    createMany?: ExposedEntityCreateManyCreatorInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type InvitationUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?:
      | XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
      | InvitationCreateWithoutInvitedByInput[]
      | InvitationUncheckedCreateWithoutInvitedByInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutInvitedByInput
      | InvitationCreateOrConnectWithoutInvitedByInput[];
    createMany?: InvitationCreateManyInvitedByInputEnvelope;
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
  };

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
      | RoleCreateWithoutCreatorInput[]
      | RoleUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatorInput
      | RoleCreateOrConnectWithoutCreatorInput[];
    createMany?: RoleCreateManyCreatorInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>
      | ServiceCreateWithoutCreatorInput[]
      | ServiceUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatorInput
      | ServiceCreateOrConnectWithoutCreatorInput[];
    createMany?: ServiceCreateManyCreatorInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutUserInput, TermsAcceptanceUncheckedCreateWithoutUserInput>
      | TermsAcceptanceCreateWithoutUserInput[]
      | TermsAcceptanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutUserInput
      | TermsAcceptanceCreateOrConnectWithoutUserInput[];
    createMany?: TermsAcceptanceCreateManyUserInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type WorkflowUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>
      | WorkflowCreateWithoutCreatorInput[]
      | WorkflowUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatorInput
      | WorkflowCreateOrConnectWithoutCreatorInput[];
    createMany?: WorkflowCreateManyCreatorInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutCreatorInput,
          RateLimitConfigUncheckedCreateWithoutCreatorInput
        >
      | RateLimitConfigCreateWithoutCreatorInput[]
      | RateLimitConfigUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutCreatorInput
      | RateLimitConfigCreateOrConnectWithoutCreatorInput[];
    createMany?: RateLimitConfigCreateManyCreatorInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutUpdaterInput,
          RateLimitConfigUncheckedCreateWithoutUpdaterInput
        >
      | RateLimitConfigCreateWithoutUpdaterInput[]
      | RateLimitConfigUncheckedCreateWithoutUpdaterInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput[];
    createMany?: RateLimitConfigCreateManyUpdaterInputEnvelope;
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
  };

  export type SocialAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
      | SocialAccountCreateWithoutUserInput[]
      | SocialAccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SocialAccountCreateOrConnectWithoutUserInput
      | SocialAccountCreateOrConnectWithoutUserInput[];
    createMany?: SocialAccountCreateManyUserInputEnvelope;
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
  };

  export type ApiActivityLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiKeyUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>
      | ApiKeyCreateWithoutCreatedByInput[]
      | ApiKeyUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutCreatedByInput
      | ApiKeyCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutCreatedByInput
      | ApiKeyUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ApiKeyCreateManyCreatedByInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutCreatedByInput
      | ApiKeyUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutCreatedByInput
      | ApiKeyUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type ApplicationUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatorInput, ApplicationUncheckedCreateWithoutCreatorInput>
      | ApplicationCreateWithoutCreatorInput[]
      | ApplicationUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatorInput
      | ApplicationCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutCreatorInput
      | ApplicationUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ApplicationCreateManyCreatorInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutCreatorInput
      | ApplicationUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutCreatorInput
      | ApplicationUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type DatabaseConnectionUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutCreatorInput,
          DatabaseConnectionUncheckedCreateWithoutCreatorInput
        >
      | DatabaseConnectionCreateWithoutCreatorInput[]
      | DatabaseConnectionUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | DatabaseConnectionUpsertWithWhereUniqueWithoutCreatorInput
      | DatabaseConnectionUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: DatabaseConnectionCreateManyCreatorInputEnvelope;
    set?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    disconnect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    delete?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    update?:
      | DatabaseConnectionUpdateWithWhereUniqueWithoutCreatorInput
      | DatabaseConnectionUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | DatabaseConnectionUpdateManyWithWhereWithoutCreatorInput
      | DatabaseConnectionUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
  };

  export type EndpointUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>
      | EndpointCreateWithoutCreatorInput[]
      | EndpointUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatorInput
      | EndpointCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutCreatorInput
      | EndpointUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: EndpointCreateManyCreatorInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutCreatorInput
      | EndpointUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutCreatorInput
      | EndpointUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutCreatorInput, ExposedEntityUncheckedCreateWithoutCreatorInput>
      | ExposedEntityCreateWithoutCreatorInput[]
      | ExposedEntityUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutCreatorInput
      | ExposedEntityCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutCreatorInput
      | ExposedEntityUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ExposedEntityCreateManyCreatorInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutCreatorInput
      | ExposedEntityUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutCreatorInput
      | ExposedEntityUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type InvitationUpdateManyWithoutInvitedByNestedInput = {
    create?:
      | XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
      | InvitationCreateWithoutInvitedByInput[]
      | InvitationUncheckedCreateWithoutInvitedByInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutInvitedByInput
      | InvitationCreateOrConnectWithoutInvitedByInput[];
    upsert?:
      | InvitationUpsertWithWhereUniqueWithoutInvitedByInput
      | InvitationUpsertWithWhereUniqueWithoutInvitedByInput[];
    createMany?: InvitationCreateManyInvitedByInputEnvelope;
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    update?:
      | InvitationUpdateWithWhereUniqueWithoutInvitedByInput
      | InvitationUpdateWithWhereUniqueWithoutInvitedByInput[];
    updateMany?:
      | InvitationUpdateManyWithWhereWithoutInvitedByInput
      | InvitationUpdateManyWithWhereWithoutInvitedByInput[];
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
  };

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutUserInput
      | MembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutUserInput
      | MembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutUserInput
      | MembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
      | RoleCreateWithoutCreatorInput[]
      | RoleUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatorInput
      | RoleCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutCreatorInput
      | RoleUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RoleCreateManyCreatorInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutCreatorInput
      | RoleUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutCreatorInput
      | RoleUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>
      | ServiceCreateWithoutCreatorInput[]
      | ServiceUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatorInput
      | ServiceCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatorInput
      | ServiceUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ServiceCreateManyCreatorInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatorInput
      | ServiceUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatorInput
      | ServiceUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type TermsAcceptanceUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutUserInput, TermsAcceptanceUncheckedCreateWithoutUserInput>
      | TermsAcceptanceCreateWithoutUserInput[]
      | TermsAcceptanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutUserInput
      | TermsAcceptanceCreateOrConnectWithoutUserInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutUserInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TermsAcceptanceCreateManyUserInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutUserInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutUserInput
      | TermsAcceptanceUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type WorkflowUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>
      | WorkflowCreateWithoutCreatorInput[]
      | WorkflowUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatorInput
      | WorkflowCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutCreatorInput
      | WorkflowUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: WorkflowCreateManyCreatorInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutCreatorInput
      | WorkflowUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutCreatorInput
      | WorkflowUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type RateLimitConfigUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutCreatorInput,
          RateLimitConfigUncheckedCreateWithoutCreatorInput
        >
      | RateLimitConfigCreateWithoutCreatorInput[]
      | RateLimitConfigUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutCreatorInput
      | RateLimitConfigCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutCreatorInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RateLimitConfigCreateManyCreatorInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutCreatorInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutCreatorInput
      | RateLimitConfigUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type RateLimitConfigUpdateManyWithoutUpdaterNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutUpdaterInput,
          RateLimitConfigUncheckedCreateWithoutUpdaterInput
        >
      | RateLimitConfigCreateWithoutUpdaterInput[]
      | RateLimitConfigUncheckedCreateWithoutUpdaterInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutUpdaterInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutUpdaterInput[];
    createMany?: RateLimitConfigCreateManyUpdaterInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutUpdaterInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutUpdaterInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutUpdaterInput
      | RateLimitConfigUpdateManyWithWhereWithoutUpdaterInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type SocialAccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
      | SocialAccountCreateWithoutUserInput[]
      | SocialAccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SocialAccountCreateOrConnectWithoutUserInput
      | SocialAccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | SocialAccountUpsertWithWhereUniqueWithoutUserInput
      | SocialAccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SocialAccountCreateManyUserInputEnvelope;
    set?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    disconnect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    delete?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    update?:
      | SocialAccountUpdateWithWhereUniqueWithoutUserInput
      | SocialAccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SocialAccountUpdateManyWithWhereWithoutUserInput
      | SocialAccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[];
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>
      | ApiKeyCreateWithoutCreatedByInput[]
      | ApiKeyUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutCreatedByInput
      | ApiKeyCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutCreatedByInput
      | ApiKeyUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ApiKeyCreateManyCreatedByInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutCreatedByInput
      | ApiKeyUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutCreatedByInput
      | ApiKeyUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type ApplicationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatorInput, ApplicationUncheckedCreateWithoutCreatorInput>
      | ApplicationCreateWithoutCreatorInput[]
      | ApplicationUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatorInput
      | ApplicationCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutCreatorInput
      | ApplicationUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ApplicationCreateManyCreatorInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutCreatorInput
      | ApplicationUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutCreatorInput
      | ApplicationUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          DatabaseConnectionCreateWithoutCreatorInput,
          DatabaseConnectionUncheckedCreateWithoutCreatorInput
        >
      | DatabaseConnectionCreateWithoutCreatorInput[]
      | DatabaseConnectionUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput
      | DatabaseConnectionCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | DatabaseConnectionUpsertWithWhereUniqueWithoutCreatorInput
      | DatabaseConnectionUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: DatabaseConnectionCreateManyCreatorInputEnvelope;
    set?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    disconnect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    delete?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    connect?: DatabaseConnectionWhereUniqueInput | DatabaseConnectionWhereUniqueInput[];
    update?:
      | DatabaseConnectionUpdateWithWhereUniqueWithoutCreatorInput
      | DatabaseConnectionUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | DatabaseConnectionUpdateManyWithWhereWithoutCreatorInput
      | DatabaseConnectionUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>
      | EndpointCreateWithoutCreatorInput[]
      | EndpointUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatorInput
      | EndpointCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutCreatorInput
      | EndpointUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: EndpointCreateManyCreatorInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutCreatorInput
      | EndpointUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutCreatorInput
      | EndpointUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutCreatorInput, ExposedEntityUncheckedCreateWithoutCreatorInput>
      | ExposedEntityCreateWithoutCreatorInput[]
      | ExposedEntityUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutCreatorInput
      | ExposedEntityCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutCreatorInput
      | ExposedEntityUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ExposedEntityCreateManyCreatorInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutCreatorInput
      | ExposedEntityUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutCreatorInput
      | ExposedEntityUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type InvitationUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?:
      | XOR<InvitationCreateWithoutInvitedByInput, InvitationUncheckedCreateWithoutInvitedByInput>
      | InvitationCreateWithoutInvitedByInput[]
      | InvitationUncheckedCreateWithoutInvitedByInput[];
    connectOrCreate?:
      | InvitationCreateOrConnectWithoutInvitedByInput
      | InvitationCreateOrConnectWithoutInvitedByInput[];
    upsert?:
      | InvitationUpsertWithWhereUniqueWithoutInvitedByInput
      | InvitationUpsertWithWhereUniqueWithoutInvitedByInput[];
    createMany?: InvitationCreateManyInvitedByInputEnvelope;
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[];
    update?:
      | InvitationUpdateWithWhereUniqueWithoutInvitedByInput
      | InvitationUpdateWithWhereUniqueWithoutInvitedByInput[];
    updateMany?:
      | InvitationUpdateManyWithWhereWithoutInvitedByInput
      | InvitationUpdateManyWithWhereWithoutInvitedByInput[];
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
  };

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
      | MembershipCreateWithoutUserInput[]
      | MembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MembershipCreateOrConnectWithoutUserInput
      | MembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | MembershipUpsertWithWhereUniqueWithoutUserInput
      | MembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MembershipCreateManyUserInputEnvelope;
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[];
    update?:
      | MembershipUpdateWithWhereUniqueWithoutUserInput
      | MembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MembershipUpdateManyWithWhereWithoutUserInput
      | MembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
      | RoleCreateWithoutCreatorInput[]
      | RoleUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatorInput
      | RoleCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutCreatorInput
      | RoleUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RoleCreateManyCreatorInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutCreatorInput
      | RoleUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutCreatorInput
      | RoleUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>
      | ServiceCreateWithoutCreatorInput[]
      | ServiceUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatorInput
      | ServiceCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatorInput
      | ServiceUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: ServiceCreateManyCreatorInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatorInput
      | ServiceUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatorInput
      | ServiceUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutUserInput, TermsAcceptanceUncheckedCreateWithoutUserInput>
      | TermsAcceptanceCreateWithoutUserInput[]
      | TermsAcceptanceUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutUserInput
      | TermsAcceptanceCreateOrConnectWithoutUserInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutUserInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TermsAcceptanceCreateManyUserInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutUserInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutUserInput
      | TermsAcceptanceUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type WorkflowUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>
      | WorkflowCreateWithoutCreatorInput[]
      | WorkflowUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatorInput
      | WorkflowCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutCreatorInput
      | WorkflowUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: WorkflowCreateManyCreatorInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutCreatorInput
      | WorkflowUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutCreatorInput
      | WorkflowUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutCreatorInput,
          RateLimitConfigUncheckedCreateWithoutCreatorInput
        >
      | RateLimitConfigCreateWithoutCreatorInput[]
      | RateLimitConfigUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutCreatorInput
      | RateLimitConfigCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutCreatorInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RateLimitConfigCreateManyCreatorInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutCreatorInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutCreatorInput
      | RateLimitConfigUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?:
      | XOR<
          RateLimitConfigCreateWithoutUpdaterInput,
          RateLimitConfigUncheckedCreateWithoutUpdaterInput
        >
      | RateLimitConfigCreateWithoutUpdaterInput[]
      | RateLimitConfigUncheckedCreateWithoutUpdaterInput[];
    connectOrCreate?:
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput
      | RateLimitConfigCreateOrConnectWithoutUpdaterInput[];
    upsert?:
      | RateLimitConfigUpsertWithWhereUniqueWithoutUpdaterInput
      | RateLimitConfigUpsertWithWhereUniqueWithoutUpdaterInput[];
    createMany?: RateLimitConfigCreateManyUpdaterInputEnvelope;
    set?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    disconnect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    delete?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    connect?: RateLimitConfigWhereUniqueInput | RateLimitConfigWhereUniqueInput[];
    update?:
      | RateLimitConfigUpdateWithWhereUniqueWithoutUpdaterInput
      | RateLimitConfigUpdateWithWhereUniqueWithoutUpdaterInput[];
    updateMany?:
      | RateLimitConfigUpdateManyWithWhereWithoutUpdaterInput
      | RateLimitConfigUpdateManyWithWhereWithoutUpdaterInput[];
    deleteMany?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
  };

  export type SocialAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
      | SocialAccountCreateWithoutUserInput[]
      | SocialAccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SocialAccountCreateOrConnectWithoutUserInput
      | SocialAccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | SocialAccountUpsertWithWhereUniqueWithoutUserInput
      | SocialAccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SocialAccountCreateManyUserInputEnvelope;
    set?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    disconnect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    delete?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[];
    update?:
      | SocialAccountUpdateWithWhereUniqueWithoutUserInput
      | SocialAccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SocialAccountUpdateManyWithWhereWithoutUserInput
      | SocialAccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[];
  };

  export type OrganizationCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole;
  };

  export type OrganizationUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput;
    upsert?: OrganizationUpsertWithoutMembershipsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutMembershipsInput,
        OrganizationUpdateWithoutMembershipsInput
      >,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    upsert?: UserUpsertWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<
      UserCreateWithoutInvitationsSentInput,
      UserUncheckedCreateWithoutInvitationsSentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<
      OrganizationCreateWithoutInvitationsInput,
      OrganizationUncheckedCreateWithoutInvitationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutInvitationsSentNestedInput = {
    create?: XOR<
      UserCreateWithoutInvitationsSentInput,
      UserUncheckedCreateWithoutInvitationsSentInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput;
    upsert?: UserUpsertWithoutInvitationsSentInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutInvitationsSentInput,
        UserUpdateWithoutInvitationsSentInput
      >,
      UserUncheckedUpdateWithoutInvitationsSentInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutInvitationsInput,
      OrganizationUncheckedCreateWithoutInvitationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput;
    upsert?: OrganizationUpsertWithoutInvitationsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutInvitationsInput,
        OrganizationUpdateWithoutInvitationsInput
      >,
      OrganizationUncheckedUpdateWithoutInvitationsInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutBillingEventsInput = {
    create?: XOR<
      OrganizationCreateWithoutBillingEventsInput,
      OrganizationUncheckedCreateWithoutBillingEventsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingEventsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type SubscriptionCreateNestedOneWithoutBillingEventsInput = {
    create?: XOR<
      SubscriptionCreateWithoutBillingEventsInput,
      SubscriptionUncheckedCreateWithoutBillingEventsInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBillingEventsInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type OrganizationUpdateOneWithoutBillingEventsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutBillingEventsInput,
      OrganizationUncheckedCreateWithoutBillingEventsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutBillingEventsInput;
    upsert?: OrganizationUpsertWithoutBillingEventsInput;
    disconnect?: OrganizationWhereInput | boolean;
    delete?: OrganizationWhereInput | boolean;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutBillingEventsInput,
        OrganizationUpdateWithoutBillingEventsInput
      >,
      OrganizationUncheckedUpdateWithoutBillingEventsInput
    >;
  };

  export type SubscriptionUpdateOneWithoutBillingEventsNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutBillingEventsInput,
      SubscriptionUncheckedCreateWithoutBillingEventsInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutBillingEventsInput;
    upsert?: SubscriptionUpsertWithoutBillingEventsInput;
    disconnect?: SubscriptionWhereInput | boolean;
    delete?: SubscriptionWhereInput | boolean;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutBillingEventsInput,
        SubscriptionUpdateWithoutBillingEventsInput
      >,
      SubscriptionUncheckedUpdateWithoutBillingEventsInput
    >;
  };

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
      | InvoiceCreateWithoutSubscriptionInput[]
      | InvoiceUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSubscriptionInput
      | InvoiceCreateOrConnectWithoutSubscriptionInput[];
    createMany?: InvoiceCreateManySubscriptionInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type BillingEventCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutSubscriptionInput,
          BillingEventUncheckedCreateWithoutSubscriptionInput
        >
      | BillingEventCreateWithoutSubscriptionInput[]
      | BillingEventUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutSubscriptionInput
      | BillingEventCreateOrConnectWithoutSubscriptionInput[];
    createMany?: BillingEventCreateManySubscriptionInputEnvelope;
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
  };

  export type OrganizationCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<
      OrganizationCreateWithoutSubscriptionInput,
      OrganizationUncheckedCreateWithoutSubscriptionInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
      | InvoiceCreateWithoutSubscriptionInput[]
      | InvoiceUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSubscriptionInput
      | InvoiceCreateOrConnectWithoutSubscriptionInput[];
    createMany?: InvoiceCreateManySubscriptionInputEnvelope;
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
  };

  export type BillingEventUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutSubscriptionInput,
          BillingEventUncheckedCreateWithoutSubscriptionInput
        >
      | BillingEventCreateWithoutSubscriptionInput[]
      | BillingEventUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutSubscriptionInput
      | BillingEventCreateOrConnectWithoutSubscriptionInput[];
    createMany?: BillingEventCreateManySubscriptionInputEnvelope;
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
  };

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan;
  };

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
      | InvoiceCreateWithoutSubscriptionInput[]
      | InvoiceUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSubscriptionInput
      | InvoiceCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput
      | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: InvoiceCreateManySubscriptionInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput
      | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutSubscriptionInput
      | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type BillingEventUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutSubscriptionInput,
          BillingEventUncheckedCreateWithoutSubscriptionInput
        >
      | BillingEventCreateWithoutSubscriptionInput[]
      | BillingEventUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutSubscriptionInput
      | BillingEventCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | BillingEventUpsertWithWhereUniqueWithoutSubscriptionInput
      | BillingEventUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: BillingEventCreateManySubscriptionInputEnvelope;
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    update?:
      | BillingEventUpdateWithWhereUniqueWithoutSubscriptionInput
      | BillingEventUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | BillingEventUpdateManyWithWhereWithoutSubscriptionInput
      | BillingEventUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
  };

  export type OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutSubscriptionInput,
      OrganizationUncheckedCreateWithoutSubscriptionInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput;
    upsert?: OrganizationUpsertWithoutSubscriptionInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutSubscriptionInput,
        OrganizationUpdateWithoutSubscriptionInput
      >,
      OrganizationUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
      | InvoiceCreateWithoutSubscriptionInput[]
      | InvoiceUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | InvoiceCreateOrConnectWithoutSubscriptionInput
      | InvoiceCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput
      | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: InvoiceCreateManySubscriptionInputEnvelope;
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[];
    update?:
      | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput
      | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | InvoiceUpdateManyWithWhereWithoutSubscriptionInput
      | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
  };

  export type BillingEventUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?:
      | XOR<
          BillingEventCreateWithoutSubscriptionInput,
          BillingEventUncheckedCreateWithoutSubscriptionInput
        >
      | BillingEventCreateWithoutSubscriptionInput[]
      | BillingEventUncheckedCreateWithoutSubscriptionInput[];
    connectOrCreate?:
      | BillingEventCreateOrConnectWithoutSubscriptionInput
      | BillingEventCreateOrConnectWithoutSubscriptionInput[];
    upsert?:
      | BillingEventUpsertWithWhereUniqueWithoutSubscriptionInput
      | BillingEventUpsertWithWhereUniqueWithoutSubscriptionInput[];
    createMany?: BillingEventCreateManySubscriptionInputEnvelope;
    set?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    disconnect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    delete?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    connect?: BillingEventWhereUniqueInput | BillingEventWhereUniqueInput[];
    update?:
      | BillingEventUpdateWithWhereUniqueWithoutSubscriptionInput
      | BillingEventUpdateWithWhereUniqueWithoutSubscriptionInput[];
    updateMany?:
      | BillingEventUpdateManyWithWhereWithoutSubscriptionInput
      | BillingEventUpdateManyWithWhereWithoutSubscriptionInput[];
    deleteMany?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
  };

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<
      SubscriptionCreateWithoutInvoicesInput,
      SubscriptionUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput;
    connect?: SubscriptionWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus;
  };

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<
      SubscriptionCreateWithoutInvoicesInput,
      SubscriptionUncheckedCreateWithoutInvoicesInput
    >;
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput;
    upsert?: SubscriptionUpsertWithoutInvoicesInput;
    connect?: SubscriptionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubscriptionUpdateToOneWithWhereWithoutInvoicesInput,
        SubscriptionUpdateWithoutInvoicesInput
      >,
      SubscriptionUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput = {
    create?: XOR<
      UserCreateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedCreateWithoutDatabaseConnectionsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDatabaseConnectionsCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutDatabaseConnectionsInput = {
    create?: XOR<
      OrganizationCreateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedCreateWithoutDatabaseConnectionsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutDatabaseConnectionsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type EndpointCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<EndpointCreateWithoutConnectionInput, EndpointUncheckedCreateWithoutConnectionInput>
      | EndpointCreateWithoutConnectionInput[]
      | EndpointUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutConnectionInput
      | EndpointCreateOrConnectWithoutConnectionInput[];
    createMany?: EndpointCreateManyConnectionInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutConnectionInput,
          ExposedEntityUncheckedCreateWithoutConnectionInput
        >
      | ExposedEntityCreateWithoutConnectionInput[]
      | ExposedEntityUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutConnectionInput
      | ExposedEntityCreateOrConnectWithoutConnectionInput[];
    createMany?: ExposedEntityCreateManyConnectionInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<EndpointCreateWithoutConnectionInput, EndpointUncheckedCreateWithoutConnectionInput>
      | EndpointCreateWithoutConnectionInput[]
      | EndpointUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutConnectionInput
      | EndpointCreateOrConnectWithoutConnectionInput[];
    createMany?: EndpointCreateManyConnectionInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutConnectionInput,
          ExposedEntityUncheckedCreateWithoutConnectionInput
        >
      | ExposedEntityCreateWithoutConnectionInput[]
      | ExposedEntityUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutConnectionInput
      | ExposedEntityCreateOrConnectWithoutConnectionInput[];
    createMany?: ExposedEntityCreateManyConnectionInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type EnumDatabaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.DatabaseType;
  };

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
  };

  export type UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedCreateWithoutDatabaseConnectionsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDatabaseConnectionsCreatedInput;
    upsert?: UserUpsertWithoutDatabaseConnectionsCreatedInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutDatabaseConnectionsCreatedInput,
        UserUpdateWithoutDatabaseConnectionsCreatedInput
      >,
      UserUncheckedUpdateWithoutDatabaseConnectionsCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedCreateWithoutDatabaseConnectionsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutDatabaseConnectionsInput;
    upsert?: OrganizationUpsertWithoutDatabaseConnectionsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutDatabaseConnectionsInput,
        OrganizationUpdateWithoutDatabaseConnectionsInput
      >,
      OrganizationUncheckedUpdateWithoutDatabaseConnectionsInput
    >;
  };

  export type EndpointUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutConnectionInput, EndpointUncheckedCreateWithoutConnectionInput>
      | EndpointCreateWithoutConnectionInput[]
      | EndpointUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutConnectionInput
      | EndpointCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutConnectionInput
      | EndpointUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: EndpointCreateManyConnectionInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutConnectionInput
      | EndpointUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutConnectionInput
      | EndpointUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutConnectionInput,
          ExposedEntityUncheckedCreateWithoutConnectionInput
        >
      | ExposedEntityCreateWithoutConnectionInput[]
      | ExposedEntityUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutConnectionInput
      | ExposedEntityCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutConnectionInput
      | ExposedEntityUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ExposedEntityCreateManyConnectionInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutConnectionInput
      | ExposedEntityUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutConnectionInput
      | ExposedEntityUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutConnectionInput
      | ServiceUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutConnectionInput, EndpointUncheckedCreateWithoutConnectionInput>
      | EndpointCreateWithoutConnectionInput[]
      | EndpointUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutConnectionInput
      | EndpointCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutConnectionInput
      | EndpointUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: EndpointCreateManyConnectionInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutConnectionInput
      | EndpointUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutConnectionInput
      | EndpointUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<
          ExposedEntityCreateWithoutConnectionInput,
          ExposedEntityUncheckedCreateWithoutConnectionInput
        >
      | ExposedEntityCreateWithoutConnectionInput[]
      | ExposedEntityUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutConnectionInput
      | ExposedEntityCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutConnectionInput
      | ExposedEntityUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ExposedEntityCreateManyConnectionInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutConnectionInput
      | ExposedEntityUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutConnectionInput
      | ExposedEntityUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutConnectionInput
      | ServiceUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ApiActivityLogCreateNestedManyWithoutEndpointUsageInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutEndpointUsageInput,
          ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
        >
      | ApiActivityLogCreateWithoutEndpointUsageInput[]
      | ApiActivityLogUncheckedCreateWithoutEndpointUsageInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput[];
    createMany?: ApiActivityLogCreateManyEndpointUsageInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type DatabaseConnectionCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutEndpointsInput,
      DatabaseConnectionUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutEndpointsInput;
    connect?: DatabaseConnectionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutEndpointsCreatedInput = {
    create?: XOR<
      UserCreateWithoutEndpointsCreatedInput,
      UserUncheckedCreateWithoutEndpointsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEndpointsCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<
      OrganizationCreateWithoutEndpointsInput,
      OrganizationUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutEndpointsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type ApiActivityLogUncheckedCreateNestedManyWithoutEndpointUsageInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutEndpointUsageInput,
          ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
        >
      | ApiActivityLogCreateWithoutEndpointUsageInput[]
      | ApiActivityLogUncheckedCreateWithoutEndpointUsageInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput[];
    createMany?: ApiActivityLogCreateManyEndpointUsageInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type EnumHttpMethodFieldUpdateOperationsInput = {
    set?: $Enums.HttpMethod;
  };

  export type ApiActivityLogUpdateManyWithoutEndpointUsageNestedInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutEndpointUsageInput,
          ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
        >
      | ApiActivityLogCreateWithoutEndpointUsageInput[]
      | ApiActivityLogUncheckedCreateWithoutEndpointUsageInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutEndpointUsageInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutEndpointUsageInput[];
    createMany?: ApiActivityLogCreateManyEndpointUsageInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutEndpointUsageInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutEndpointUsageInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutEndpointUsageInput
      | ApiActivityLogUpdateManyWithWhereWithoutEndpointUsageInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type DatabaseConnectionUpdateOneWithoutEndpointsNestedInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutEndpointsInput,
      DatabaseConnectionUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutEndpointsInput;
    upsert?: DatabaseConnectionUpsertWithoutEndpointsInput;
    disconnect?: DatabaseConnectionWhereInput | boolean;
    delete?: DatabaseConnectionWhereInput | boolean;
    connect?: DatabaseConnectionWhereUniqueInput;
    update?: XOR<
      XOR<
        DatabaseConnectionUpdateToOneWithWhereWithoutEndpointsInput,
        DatabaseConnectionUpdateWithoutEndpointsInput
      >,
      DatabaseConnectionUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutEndpointsCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutEndpointsCreatedInput,
      UserUncheckedCreateWithoutEndpointsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEndpointsCreatedInput;
    upsert?: UserUpsertWithoutEndpointsCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutEndpointsCreatedInput,
        UserUpdateWithoutEndpointsCreatedInput
      >,
      UserUncheckedUpdateWithoutEndpointsCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutEndpointsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutEndpointsInput,
      OrganizationUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutEndpointsInput;
    upsert?: OrganizationUpsertWithoutEndpointsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutEndpointsInput,
        OrganizationUpdateWithoutEndpointsInput
      >,
      OrganizationUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageNestedInput = {
    create?:
      | XOR<
          ApiActivityLogCreateWithoutEndpointUsageInput,
          ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
        >
      | ApiActivityLogCreateWithoutEndpointUsageInput[]
      | ApiActivityLogUncheckedCreateWithoutEndpointUsageInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput
      | ApiActivityLogCreateOrConnectWithoutEndpointUsageInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutEndpointUsageInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutEndpointUsageInput[];
    createMany?: ApiActivityLogCreateManyEndpointUsageInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutEndpointUsageInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutEndpointUsageInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutEndpointUsageInput
      | ApiActivityLogUpdateManyWithWhereWithoutEndpointUsageInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiKeyCreatepermissionsInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutApiKeysCreatedInput = {
    create?: XOR<
      UserCreateWithoutApiKeysCreatedInput,
      UserUncheckedCreateWithoutApiKeysCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<
      OrganizationCreateWithoutApiKeysInput,
      OrganizationUncheckedCreateWithoutApiKeysInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UsageMetricCreateNestedManyWithoutApiKeyInput = {
    create?:
      | XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>
      | UsageMetricCreateWithoutApiKeyInput[]
      | UsageMetricUncheckedCreateWithoutApiKeyInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutApiKeyInput
      | UsageMetricCreateOrConnectWithoutApiKeyInput[];
    createMany?: UsageMetricCreateManyApiKeyInputEnvelope;
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
  };

  export type UsageMetricUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?:
      | XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>
      | UsageMetricCreateWithoutApiKeyInput[]
      | UsageMetricUncheckedCreateWithoutApiKeyInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutApiKeyInput
      | UsageMetricCreateOrConnectWithoutApiKeyInput[];
    createMany?: UsageMetricCreateManyApiKeyInputEnvelope;
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
  };

  export type ApiKeyUpdatepermissionsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutApiKeysCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutApiKeysCreatedInput,
      UserUncheckedCreateWithoutApiKeysCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysCreatedInput;
    upsert?: UserUpsertWithoutApiKeysCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutApiKeysCreatedInput, UserUpdateWithoutApiKeysCreatedInput>,
      UserUncheckedUpdateWithoutApiKeysCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutApiKeysInput,
      OrganizationUncheckedCreateWithoutApiKeysInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiKeysInput;
    upsert?: OrganizationUpsertWithoutApiKeysInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutApiKeysInput,
        OrganizationUpdateWithoutApiKeysInput
      >,
      OrganizationUncheckedUpdateWithoutApiKeysInput
    >;
  };

  export type UsageMetricUpdateManyWithoutApiKeyNestedInput = {
    create?:
      | XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>
      | UsageMetricCreateWithoutApiKeyInput[]
      | UsageMetricUncheckedCreateWithoutApiKeyInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutApiKeyInput
      | UsageMetricCreateOrConnectWithoutApiKeyInput[];
    upsert?:
      | UsageMetricUpsertWithWhereUniqueWithoutApiKeyInput
      | UsageMetricUpsertWithWhereUniqueWithoutApiKeyInput[];
    createMany?: UsageMetricCreateManyApiKeyInputEnvelope;
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    update?:
      | UsageMetricUpdateWithWhereUniqueWithoutApiKeyInput
      | UsageMetricUpdateWithWhereUniqueWithoutApiKeyInput[];
    updateMany?:
      | UsageMetricUpdateManyWithWhereWithoutApiKeyInput
      | UsageMetricUpdateManyWithWhereWithoutApiKeyInput[];
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
  };

  export type UsageMetricUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?:
      | XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>
      | UsageMetricCreateWithoutApiKeyInput[]
      | UsageMetricUncheckedCreateWithoutApiKeyInput[];
    connectOrCreate?:
      | UsageMetricCreateOrConnectWithoutApiKeyInput
      | UsageMetricCreateOrConnectWithoutApiKeyInput[];
    upsert?:
      | UsageMetricUpsertWithWhereUniqueWithoutApiKeyInput
      | UsageMetricUpsertWithWhereUniqueWithoutApiKeyInput[];
    createMany?: UsageMetricCreateManyApiKeyInputEnvelope;
    set?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    disconnect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    delete?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    connect?: UsageMetricWhereUniqueInput | UsageMetricWhereUniqueInput[];
    update?:
      | UsageMetricUpdateWithWhereUniqueWithoutApiKeyInput
      | UsageMetricUpdateWithWhereUniqueWithoutApiKeyInput[];
    updateMany?:
      | UsageMetricUpdateManyWithWhereWithoutApiKeyInput
      | UsageMetricUpdateManyWithWhereWithoutApiKeyInput[];
    deleteMany?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
  };

  export type ApiKeyCreateNestedOneWithoutUsageMetricsInput = {
    create?: XOR<
      ApiKeyCreateWithoutUsageMetricsInput,
      ApiKeyUncheckedCreateWithoutUsageMetricsInput
    >;
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageMetricsInput;
    connect?: ApiKeyWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutUsageMetricsInput = {
    create?: XOR<
      OrganizationCreateWithoutUsageMetricsInput,
      OrganizationUncheckedCreateWithoutUsageMetricsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsageMetricsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type ApiKeyUpdateOneWithoutUsageMetricsNestedInput = {
    create?: XOR<
      ApiKeyCreateWithoutUsageMetricsInput,
      ApiKeyUncheckedCreateWithoutUsageMetricsInput
    >;
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageMetricsInput;
    upsert?: ApiKeyUpsertWithoutUsageMetricsInput;
    disconnect?: ApiKeyWhereInput | boolean;
    delete?: ApiKeyWhereInput | boolean;
    connect?: ApiKeyWhereUniqueInput;
    update?: XOR<
      XOR<ApiKeyUpdateToOneWithWhereWithoutUsageMetricsInput, ApiKeyUpdateWithoutUsageMetricsInput>,
      ApiKeyUncheckedUpdateWithoutUsageMetricsInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutUsageMetricsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutUsageMetricsInput,
      OrganizationUncheckedCreateWithoutUsageMetricsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsageMetricsInput;
    upsert?: OrganizationUpsertWithoutUsageMetricsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutUsageMetricsInput,
        OrganizationUpdateWithoutUsageMetricsInput
      >,
      OrganizationUncheckedUpdateWithoutUsageMetricsInput
    >;
  };

  export type UserCreateNestedOneWithoutWorkflowsCreatedInput = {
    create?: XOR<
      UserCreateWithoutWorkflowsCreatedInput,
      UserUncheckedCreateWithoutWorkflowsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<
      OrganizationCreateWithoutWorkflowsInput,
      OrganizationUncheckedCreateWithoutWorkflowsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutWorkflowsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type WorkflowExecutionCreateNestedManyWithoutWorkflowInput = {
    create?:
      | XOR<
          WorkflowExecutionCreateWithoutWorkflowInput,
          WorkflowExecutionUncheckedCreateWithoutWorkflowInput
        >
      | WorkflowExecutionCreateWithoutWorkflowInput[]
      | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[];
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope;
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
  };

  export type WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?:
      | XOR<
          WorkflowExecutionCreateWithoutWorkflowInput,
          WorkflowExecutionUncheckedCreateWithoutWorkflowInput
        >
      | WorkflowExecutionCreateWithoutWorkflowInput[]
      | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[];
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope;
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
  };

  export type UserUpdateOneWithoutWorkflowsCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutWorkflowsCreatedInput,
      UserUncheckedCreateWithoutWorkflowsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsCreatedInput;
    upsert?: UserUpsertWithoutWorkflowsCreatedInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutWorkflowsCreatedInput,
        UserUpdateWithoutWorkflowsCreatedInput
      >,
      UserUncheckedUpdateWithoutWorkflowsCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutWorkflowsInput,
      OrganizationUncheckedCreateWithoutWorkflowsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutWorkflowsInput;
    upsert?: OrganizationUpsertWithoutWorkflowsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutWorkflowsInput,
        OrganizationUpdateWithoutWorkflowsInput
      >,
      OrganizationUncheckedUpdateWithoutWorkflowsInput
    >;
  };

  export type WorkflowExecutionUpdateManyWithoutWorkflowNestedInput = {
    create?:
      | XOR<
          WorkflowExecutionCreateWithoutWorkflowInput,
          WorkflowExecutionUncheckedCreateWithoutWorkflowInput
        >
      | WorkflowExecutionCreateWithoutWorkflowInput[]
      | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[];
    upsert?:
      | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput
      | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput[];
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope;
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    update?:
      | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput
      | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput[];
    updateMany?:
      | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput
      | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput[];
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[];
  };

  export type WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?:
      | XOR<
          WorkflowExecutionCreateWithoutWorkflowInput,
          WorkflowExecutionUncheckedCreateWithoutWorkflowInput
        >
      | WorkflowExecutionCreateWithoutWorkflowInput[]
      | WorkflowExecutionUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput
      | WorkflowExecutionCreateOrConnectWithoutWorkflowInput[];
    upsert?:
      | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput
      | WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput[];
    createMany?: WorkflowExecutionCreateManyWorkflowInputEnvelope;
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[];
    update?:
      | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput
      | WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput[];
    updateMany?:
      | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput
      | WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput[];
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[];
  };

  export type WorkflowCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<
      WorkflowCreateWithoutExecutionsInput,
      WorkflowUncheckedCreateWithoutExecutionsInput
    >;
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput;
    connect?: WorkflowWhereUniqueInput;
  };

  export type EnumExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExecutionStatus;
  };

  export type WorkflowUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<
      WorkflowCreateWithoutExecutionsInput,
      WorkflowUncheckedCreateWithoutExecutionsInput
    >;
    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput;
    upsert?: WorkflowUpsertWithoutExecutionsInput;
    connect?: WorkflowWhereUniqueInput;
    update?: XOR<
      XOR<WorkflowUpdateToOneWithWhereWithoutExecutionsInput, WorkflowUpdateWithoutExecutionsInput>,
      WorkflowUncheckedUpdateWithoutExecutionsInput
    >;
  };

  export type WebhookCreateeventsInput = {
    set: string[];
  };

  export type OrganizationCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<
      OrganizationCreateWithoutWebhooksInput,
      OrganizationUncheckedCreateWithoutWebhooksInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutWebhooksInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type WebhookUpdateeventsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type OrganizationUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutWebhooksInput,
      OrganizationUncheckedCreateWithoutWebhooksInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutWebhooksInput;
    upsert?: OrganizationUpsertWithoutWebhooksInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutWebhooksInput,
        OrganizationUpdateWithoutWebhooksInput
      >,
      OrganizationUncheckedUpdateWithoutWebhooksInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      OrganizationCreateWithoutAuditLogsInput,
      OrganizationUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuditLogsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutAuditLogsInput,
      OrganizationUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuditLogsInput;
    upsert?: OrganizationUpsertWithoutAuditLogsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutAuditLogsInput,
        OrganizationUpdateWithoutAuditLogsInput
      >,
      OrganizationUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    upsert?: UserUpsertWithoutAuditLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type DatabaseObjectCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutServiceInput,
          DatabaseObjectUncheckedCreateWithoutServiceInput
        >
      | DatabaseObjectCreateWithoutServiceInput[]
      | DatabaseObjectUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutServiceInput
      | DatabaseObjectCreateOrConnectWithoutServiceInput[];
    createMany?: DatabaseObjectCreateManyServiceInputEnvelope;
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
  };

  export type ExposedEntityCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutServiceInput, ExposedEntityUncheckedCreateWithoutServiceInput>
      | ExposedEntityCreateWithoutServiceInput[]
      | ExposedEntityUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutServiceInput
      | ExposedEntityCreateOrConnectWithoutServiceInput[];
    createMany?: ExposedEntityCreateManyServiceInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type RoleCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>
      | RoleCreateWithoutServiceInput[]
      | RoleUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutServiceInput
      | RoleCreateOrConnectWithoutServiceInput[];
    createMany?: RoleCreateManyServiceInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type DatabaseConnectionCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutServicesInput,
      DatabaseConnectionUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutServicesInput;
    connect?: DatabaseConnectionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutServicesCreatedInput = {
    create?: XOR<
      UserCreateWithoutServicesCreatedInput,
      UserUncheckedCreateWithoutServicesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutServicesCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      OrganizationCreateWithoutServicesInput,
      OrganizationUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutServicesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutServiceInput,
          DatabaseObjectUncheckedCreateWithoutServiceInput
        >
      | DatabaseObjectCreateWithoutServiceInput[]
      | DatabaseObjectUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutServiceInput
      | DatabaseObjectCreateOrConnectWithoutServiceInput[];
    createMany?: DatabaseObjectCreateManyServiceInputEnvelope;
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
  };

  export type ExposedEntityUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutServiceInput, ExposedEntityUncheckedCreateWithoutServiceInput>
      | ExposedEntityCreateWithoutServiceInput[]
      | ExposedEntityUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutServiceInput
      | ExposedEntityCreateOrConnectWithoutServiceInput[];
    createMany?: ExposedEntityCreateManyServiceInputEnvelope;
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
  };

  export type RoleUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>
      | RoleCreateWithoutServiceInput[]
      | RoleUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutServiceInput
      | RoleCreateOrConnectWithoutServiceInput[];
    createMany?: RoleCreateManyServiceInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type DatabaseObjectUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutServiceInput,
          DatabaseObjectUncheckedCreateWithoutServiceInput
        >
      | DatabaseObjectCreateWithoutServiceInput[]
      | DatabaseObjectUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutServiceInput
      | DatabaseObjectCreateOrConnectWithoutServiceInput[];
    upsert?:
      | DatabaseObjectUpsertWithWhereUniqueWithoutServiceInput
      | DatabaseObjectUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: DatabaseObjectCreateManyServiceInputEnvelope;
    set?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    disconnect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    delete?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    update?:
      | DatabaseObjectUpdateWithWhereUniqueWithoutServiceInput
      | DatabaseObjectUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | DatabaseObjectUpdateManyWithWhereWithoutServiceInput
      | DatabaseObjectUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
  };

  export type ExposedEntityUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutServiceInput, ExposedEntityUncheckedCreateWithoutServiceInput>
      | ExposedEntityCreateWithoutServiceInput[]
      | ExposedEntityUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutServiceInput
      | ExposedEntityCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutServiceInput
      | ExposedEntityUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ExposedEntityCreateManyServiceInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutServiceInput
      | ExposedEntityUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutServiceInput
      | ExposedEntityUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type RoleUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>
      | RoleCreateWithoutServiceInput[]
      | RoleUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutServiceInput
      | RoleCreateOrConnectWithoutServiceInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutServiceInput
      | RoleUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: RoleCreateManyServiceInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutServiceInput
      | RoleUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutServiceInput
      | RoleUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type DatabaseConnectionUpdateOneWithoutServicesNestedInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutServicesInput,
      DatabaseConnectionUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutServicesInput;
    upsert?: DatabaseConnectionUpsertWithoutServicesInput;
    disconnect?: DatabaseConnectionWhereInput | boolean;
    delete?: DatabaseConnectionWhereInput | boolean;
    connect?: DatabaseConnectionWhereUniqueInput;
    update?: XOR<
      XOR<
        DatabaseConnectionUpdateToOneWithWhereWithoutServicesInput,
        DatabaseConnectionUpdateWithoutServicesInput
      >,
      DatabaseConnectionUncheckedUpdateWithoutServicesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutServicesCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutServicesCreatedInput,
      UserUncheckedCreateWithoutServicesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutServicesCreatedInput;
    upsert?: UserUpsertWithoutServicesCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutServicesCreatedInput,
        UserUpdateWithoutServicesCreatedInput
      >,
      UserUncheckedUpdateWithoutServicesCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutServicesInput,
      OrganizationUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutServicesInput;
    upsert?: OrganizationUpsertWithoutServicesInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutServicesInput,
        OrganizationUpdateWithoutServicesInput
      >,
      OrganizationUncheckedUpdateWithoutServicesInput
    >;
  };

  export type DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          DatabaseObjectCreateWithoutServiceInput,
          DatabaseObjectUncheckedCreateWithoutServiceInput
        >
      | DatabaseObjectCreateWithoutServiceInput[]
      | DatabaseObjectUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | DatabaseObjectCreateOrConnectWithoutServiceInput
      | DatabaseObjectCreateOrConnectWithoutServiceInput[];
    upsert?:
      | DatabaseObjectUpsertWithWhereUniqueWithoutServiceInput
      | DatabaseObjectUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: DatabaseObjectCreateManyServiceInputEnvelope;
    set?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    disconnect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    delete?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    connect?: DatabaseObjectWhereUniqueInput | DatabaseObjectWhereUniqueInput[];
    update?:
      | DatabaseObjectUpdateWithWhereUniqueWithoutServiceInput
      | DatabaseObjectUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | DatabaseObjectUpdateManyWithWhereWithoutServiceInput
      | DatabaseObjectUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
  };

  export type ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ExposedEntityCreateWithoutServiceInput, ExposedEntityUncheckedCreateWithoutServiceInput>
      | ExposedEntityCreateWithoutServiceInput[]
      | ExposedEntityUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ExposedEntityCreateOrConnectWithoutServiceInput
      | ExposedEntityCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ExposedEntityUpsertWithWhereUniqueWithoutServiceInput
      | ExposedEntityUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ExposedEntityCreateManyServiceInputEnvelope;
    set?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    disconnect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    delete?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    connect?: ExposedEntityWhereUniqueInput | ExposedEntityWhereUniqueInput[];
    update?:
      | ExposedEntityUpdateWithWhereUniqueWithoutServiceInput
      | ExposedEntityUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ExposedEntityUpdateManyWithWhereWithoutServiceInput
      | ExposedEntityUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
  };

  export type RoleUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>
      | RoleCreateWithoutServiceInput[]
      | RoleUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutServiceInput
      | RoleCreateOrConnectWithoutServiceInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutServiceInput
      | RoleUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: RoleCreateManyServiceInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutServiceInput
      | RoleUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutServiceInput
      | RoleUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutApplicationsCreatedInput = {
    create?: XOR<
      UserCreateWithoutApplicationsCreatedInput,
      UserUncheckedCreateWithoutApplicationsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<RoleCreateWithoutApplicationsInput, RoleUncheckedCreateWithoutApplicationsInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutApplicationsInput;
    connect?: RoleWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<
      OrganizationCreateWithoutApplicationsInput,
      OrganizationUncheckedCreateWithoutApplicationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApplicationsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutApplicationsCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutApplicationsCreatedInput,
      UserUncheckedCreateWithoutApplicationsCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsCreatedInput;
    upsert?: UserUpsertWithoutApplicationsCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutApplicationsCreatedInput,
        UserUpdateWithoutApplicationsCreatedInput
      >,
      UserUncheckedUpdateWithoutApplicationsCreatedInput
    >;
  };

  export type RoleUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<RoleCreateWithoutApplicationsInput, RoleUncheckedCreateWithoutApplicationsInput>;
    connectOrCreate?: RoleCreateOrConnectWithoutApplicationsInput;
    upsert?: RoleUpsertWithoutApplicationsInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<RoleUpdateToOneWithWhereWithoutApplicationsInput, RoleUpdateWithoutApplicationsInput>,
      RoleUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutApplicationsInput,
      OrganizationUncheckedCreateWithoutApplicationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApplicationsInput;
    upsert?: OrganizationUpsertWithoutApplicationsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutApplicationsInput,
        OrganizationUpdateWithoutApplicationsInput
      >,
      OrganizationUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type ApplicationCreateNestedManyWithoutDefaultRoleInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutDefaultRoleInput,
          ApplicationUncheckedCreateWithoutDefaultRoleInput
        >
      | ApplicationCreateWithoutDefaultRoleInput[]
      | ApplicationUncheckedCreateWithoutDefaultRoleInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutDefaultRoleInput
      | ApplicationCreateOrConnectWithoutDefaultRoleInput[];
    createMany?: ApplicationCreateManyDefaultRoleInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type ExposedFieldPolicyCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutRoleInput,
          ExposedFieldPolicyUncheckedCreateWithoutRoleInput
        >
      | ExposedFieldPolicyCreateWithoutRoleInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput[];
    createMany?: ExposedFieldPolicyCreateManyRoleInputEnvelope;
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
  };

  export type ExposedRowPolicyCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<ExposedRowPolicyCreateWithoutRoleInput, ExposedRowPolicyUncheckedCreateWithoutRoleInput>
      | ExposedRowPolicyCreateWithoutRoleInput[]
      | ExposedRowPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput[];
    createMany?: ExposedRowPolicyCreateManyRoleInputEnvelope;
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutRolesCreatedInput = {
    create?: XOR<UserCreateWithoutRolesCreatedInput, UserUncheckedCreateWithoutRolesCreatedInput>;
    connectOrCreate?: UserCreateOrConnectWithoutRolesCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutRolesInput = {
    create?: XOR<OrganizationCreateWithoutRolesInput, OrganizationUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRolesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutRolesInput = {
    create?: XOR<ServiceCreateWithoutRolesInput, ServiceUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutRolesInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutDefaultRoleInput,
          ApplicationUncheckedCreateWithoutDefaultRoleInput
        >
      | ApplicationCreateWithoutDefaultRoleInput[]
      | ApplicationUncheckedCreateWithoutDefaultRoleInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutDefaultRoleInput
      | ApplicationCreateOrConnectWithoutDefaultRoleInput[];
    createMany?: ApplicationCreateManyDefaultRoleInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutRoleInput,
          ExposedFieldPolicyUncheckedCreateWithoutRoleInput
        >
      | ExposedFieldPolicyCreateWithoutRoleInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput[];
    createMany?: ExposedFieldPolicyCreateManyRoleInputEnvelope;
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
  };

  export type ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<ExposedRowPolicyCreateWithoutRoleInput, ExposedRowPolicyUncheckedCreateWithoutRoleInput>
      | ExposedRowPolicyCreateWithoutRoleInput[]
      | ExposedRowPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput[];
    createMany?: ExposedRowPolicyCreateManyRoleInputEnvelope;
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
  };

  export type ApplicationUpdateManyWithoutDefaultRoleNestedInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutDefaultRoleInput,
          ApplicationUncheckedCreateWithoutDefaultRoleInput
        >
      | ApplicationCreateWithoutDefaultRoleInput[]
      | ApplicationUncheckedCreateWithoutDefaultRoleInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutDefaultRoleInput
      | ApplicationCreateOrConnectWithoutDefaultRoleInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutDefaultRoleInput
      | ApplicationUpsertWithWhereUniqueWithoutDefaultRoleInput[];
    createMany?: ApplicationCreateManyDefaultRoleInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutDefaultRoleInput
      | ApplicationUpdateWithWhereUniqueWithoutDefaultRoleInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutDefaultRoleInput
      | ApplicationUpdateManyWithWhereWithoutDefaultRoleInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type ExposedFieldPolicyUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutRoleInput,
          ExposedFieldPolicyUncheckedCreateWithoutRoleInput
        >
      | ExposedFieldPolicyCreateWithoutRoleInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput[];
    upsert?:
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutRoleInput
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: ExposedFieldPolicyCreateManyRoleInputEnvelope;
    set?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    disconnect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    delete?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    update?:
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutRoleInput
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | ExposedFieldPolicyUpdateManyWithWhereWithoutRoleInput
      | ExposedFieldPolicyUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
  };

  export type ExposedRowPolicyUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<ExposedRowPolicyCreateWithoutRoleInput, ExposedRowPolicyUncheckedCreateWithoutRoleInput>
      | ExposedRowPolicyCreateWithoutRoleInput[]
      | ExposedRowPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput[];
    upsert?:
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutRoleInput
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: ExposedRowPolicyCreateManyRoleInputEnvelope;
    set?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    disconnect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    delete?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    update?:
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutRoleInput
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | ExposedRowPolicyUpdateManyWithWhereWithoutRoleInput
      | ExposedRowPolicyUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutRolesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutRolesCreatedInput, UserUncheckedCreateWithoutRolesCreatedInput>;
    connectOrCreate?: UserCreateOrConnectWithoutRolesCreatedInput;
    upsert?: UserUpsertWithoutRolesCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutRolesCreatedInput, UserUpdateWithoutRolesCreatedInput>,
      UserUncheckedUpdateWithoutRolesCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<OrganizationCreateWithoutRolesInput, OrganizationUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRolesInput;
    upsert?: OrganizationUpsertWithoutRolesInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<OrganizationUpdateToOneWithWhereWithoutRolesInput, OrganizationUpdateWithoutRolesInput>,
      OrganizationUncheckedUpdateWithoutRolesInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<ServiceCreateWithoutRolesInput, ServiceUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutRolesInput;
    upsert?: ServiceUpsertWithoutRolesInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutRolesInput, ServiceUpdateWithoutRolesInput>,
      ServiceUncheckedUpdateWithoutRolesInput
    >;
  };

  export type ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput = {
    create?:
      | XOR<
          ApplicationCreateWithoutDefaultRoleInput,
          ApplicationUncheckedCreateWithoutDefaultRoleInput
        >
      | ApplicationCreateWithoutDefaultRoleInput[]
      | ApplicationUncheckedCreateWithoutDefaultRoleInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutDefaultRoleInput
      | ApplicationCreateOrConnectWithoutDefaultRoleInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutDefaultRoleInput
      | ApplicationUpsertWithWhereUniqueWithoutDefaultRoleInput[];
    createMany?: ApplicationCreateManyDefaultRoleInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutDefaultRoleInput
      | ApplicationUpdateWithWhereUniqueWithoutDefaultRoleInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutDefaultRoleInput
      | ApplicationUpdateManyWithWhereWithoutDefaultRoleInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutRoleInput,
          ExposedFieldPolicyUncheckedCreateWithoutRoleInput
        >
      | ExposedFieldPolicyCreateWithoutRoleInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput
      | ExposedFieldPolicyCreateOrConnectWithoutRoleInput[];
    upsert?:
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutRoleInput
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: ExposedFieldPolicyCreateManyRoleInputEnvelope;
    set?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    disconnect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    delete?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    update?:
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutRoleInput
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | ExposedFieldPolicyUpdateManyWithWhereWithoutRoleInput
      | ExposedFieldPolicyUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
  };

  export type ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<ExposedRowPolicyCreateWithoutRoleInput, ExposedRowPolicyUncheckedCreateWithoutRoleInput>
      | ExposedRowPolicyCreateWithoutRoleInput[]
      | ExposedRowPolicyUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput
      | ExposedRowPolicyCreateOrConnectWithoutRoleInput[];
    upsert?:
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutRoleInput
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: ExposedRowPolicyCreateManyRoleInputEnvelope;
    set?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    disconnect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    delete?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    update?:
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutRoleInput
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | ExposedRowPolicyUpdateManyWithWhereWithoutRoleInput
      | ExposedRowPolicyUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
  };

  export type OrganizationCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<
      OrganizationCreateWithoutNotificationsInput,
      OrganizationUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType;
  };

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority;
  };

  export type OrganizationUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutNotificationsInput,
      OrganizationUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationsInput;
    upsert?: OrganizationUpsertWithoutNotificationsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutNotificationsInput,
        OrganizationUpdateWithoutNotificationsInput
      >,
      OrganizationUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type EndpointCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<EndpointCreateWithoutUsageLogsInput, EndpointUncheckedCreateWithoutUsageLogsInput>;
    connectOrCreate?: EndpointCreateOrConnectWithoutUsageLogsInput;
    connect?: EndpointWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutApiActivityLogsInput = {
    create?: XOR<
      OrganizationCreateWithoutApiActivityLogsInput,
      OrganizationUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiActivityLogsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutApiActivityLogsInput = {
    create?: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiActivityLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EndpointUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<EndpointCreateWithoutUsageLogsInput, EndpointUncheckedCreateWithoutUsageLogsInput>;
    connectOrCreate?: EndpointCreateOrConnectWithoutUsageLogsInput;
    upsert?: EndpointUpsertWithoutUsageLogsInput;
    disconnect?: EndpointWhereInput | boolean;
    delete?: EndpointWhereInput | boolean;
    connect?: EndpointWhereUniqueInput;
    update?: XOR<
      XOR<EndpointUpdateToOneWithWhereWithoutUsageLogsInput, EndpointUpdateWithoutUsageLogsInput>,
      EndpointUncheckedUpdateWithoutUsageLogsInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutApiActivityLogsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutApiActivityLogsInput,
      OrganizationUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutApiActivityLogsInput;
    upsert?: OrganizationUpsertWithoutApiActivityLogsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutApiActivityLogsInput,
        OrganizationUpdateWithoutApiActivityLogsInput
      >,
      OrganizationUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type UserUpdateOneWithoutApiActivityLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiActivityLogsInput;
    upsert?: UserUpsertWithoutApiActivityLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutApiActivityLogsInput,
        UserUpdateWithoutApiActivityLogsInput
      >,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutDatabaseObjectsInput = {
    create?: XOR<
      OrganizationCreateWithoutDatabaseObjectsInput,
      OrganizationUncheckedCreateWithoutDatabaseObjectsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutDatabaseObjectsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutDatabaseObjectsInput = {
    create?: XOR<
      ServiceCreateWithoutDatabaseObjectsInput,
      ServiceUncheckedCreateWithoutDatabaseObjectsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutDatabaseObjectsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type OrganizationUpdateOneRequiredWithoutDatabaseObjectsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutDatabaseObjectsInput,
      OrganizationUncheckedCreateWithoutDatabaseObjectsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutDatabaseObjectsInput;
    upsert?: OrganizationUpsertWithoutDatabaseObjectsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutDatabaseObjectsInput,
        OrganizationUpdateWithoutDatabaseObjectsInput
      >,
      OrganizationUncheckedUpdateWithoutDatabaseObjectsInput
    >;
  };

  export type ServiceUpdateOneWithoutDatabaseObjectsNestedInput = {
    create?: XOR<
      ServiceCreateWithoutDatabaseObjectsInput,
      ServiceUncheckedCreateWithoutDatabaseObjectsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutDatabaseObjectsInput;
    upsert?: ServiceUpsertWithoutDatabaseObjectsInput;
    disconnect?: ServiceWhereInput | boolean;
    delete?: ServiceWhereInput | boolean;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutDatabaseObjectsInput,
        ServiceUpdateWithoutDatabaseObjectsInput
      >,
      ServiceUncheckedUpdateWithoutDatabaseObjectsInput
    >;
  };

  export type DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutExposedEntitiesInput;
    connect?: DatabaseConnectionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutExposedEntitiesCreatedInput = {
    create?: XOR<
      UserCreateWithoutExposedEntitiesCreatedInput,
      UserUncheckedCreateWithoutExposedEntitiesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutExposedEntitiesCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrganizationCreateNestedOneWithoutExposedEntitiesInput = {
    create?: XOR<
      OrganizationCreateWithoutExposedEntitiesInput,
      OrganizationUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutExposedEntitiesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutExposedEntitiesInput = {
    create?: XOR<
      ServiceCreateWithoutExposedEntitiesInput,
      ServiceUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutExposedEntitiesInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutExposedEntityInput,
          ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedFieldPolicyCreateWithoutExposedEntityInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput[];
    createMany?: ExposedFieldPolicyCreateManyExposedEntityInputEnvelope;
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
  };

  export type ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput = {
    create?:
      | XOR<
          ExposedRowPolicyCreateWithoutExposedEntityInput,
          ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedRowPolicyCreateWithoutExposedEntityInput[]
      | ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput[];
    createMany?: ExposedRowPolicyCreateManyExposedEntityInputEnvelope;
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
  };

  export type ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutExposedEntityInput,
          ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedFieldPolicyCreateWithoutExposedEntityInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput[];
    createMany?: ExposedFieldPolicyCreateManyExposedEntityInputEnvelope;
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
  };

  export type ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput = {
    create?:
      | XOR<
          ExposedRowPolicyCreateWithoutExposedEntityInput,
          ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedRowPolicyCreateWithoutExposedEntityInput[]
      | ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput[];
    createMany?: ExposedRowPolicyCreateManyExposedEntityInputEnvelope;
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
  };

  export type EnumExposedEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExposedEntityType;
  };

  export type DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput = {
    create?: XOR<
      DatabaseConnectionCreateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: DatabaseConnectionCreateOrConnectWithoutExposedEntitiesInput;
    upsert?: DatabaseConnectionUpsertWithoutExposedEntitiesInput;
    connect?: DatabaseConnectionWhereUniqueInput;
    update?: XOR<
      XOR<
        DatabaseConnectionUpdateToOneWithWhereWithoutExposedEntitiesInput,
        DatabaseConnectionUpdateWithoutExposedEntitiesInput
      >,
      DatabaseConnectionUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type UserUpdateOneWithoutExposedEntitiesCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutExposedEntitiesCreatedInput,
      UserUncheckedCreateWithoutExposedEntitiesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutExposedEntitiesCreatedInput;
    upsert?: UserUpsertWithoutExposedEntitiesCreatedInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutExposedEntitiesCreatedInput,
        UserUpdateWithoutExposedEntitiesCreatedInput
      >,
      UserUncheckedUpdateWithoutExposedEntitiesCreatedInput
    >;
  };

  export type OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutExposedEntitiesInput,
      OrganizationUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutExposedEntitiesInput;
    upsert?: OrganizationUpsertWithoutExposedEntitiesInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutExposedEntitiesInput,
        OrganizationUpdateWithoutExposedEntitiesInput
      >,
      OrganizationUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput = {
    create?: XOR<
      ServiceCreateWithoutExposedEntitiesInput,
      ServiceUncheckedCreateWithoutExposedEntitiesInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutExposedEntitiesInput;
    upsert?: ServiceUpsertWithoutExposedEntitiesInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutExposedEntitiesInput,
        ServiceUpdateWithoutExposedEntitiesInput
      >,
      ServiceUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutExposedEntityInput,
          ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedFieldPolicyCreateWithoutExposedEntityInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput[];
    upsert?:
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutExposedEntityInput
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutExposedEntityInput[];
    createMany?: ExposedFieldPolicyCreateManyExposedEntityInputEnvelope;
    set?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    disconnect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    delete?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    update?:
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutExposedEntityInput
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutExposedEntityInput[];
    updateMany?:
      | ExposedFieldPolicyUpdateManyWithWhereWithoutExposedEntityInput
      | ExposedFieldPolicyUpdateManyWithWhereWithoutExposedEntityInput[];
    deleteMany?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
  };

  export type ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput = {
    create?:
      | XOR<
          ExposedRowPolicyCreateWithoutExposedEntityInput,
          ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedRowPolicyCreateWithoutExposedEntityInput[]
      | ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput[];
    upsert?:
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutExposedEntityInput
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutExposedEntityInput[];
    createMany?: ExposedRowPolicyCreateManyExposedEntityInputEnvelope;
    set?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    disconnect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    delete?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    update?:
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutExposedEntityInput
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutExposedEntityInput[];
    updateMany?:
      | ExposedRowPolicyUpdateManyWithWhereWithoutExposedEntityInput
      | ExposedRowPolicyUpdateManyWithWhereWithoutExposedEntityInput[];
    deleteMany?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
  };

  export type ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput = {
    create?:
      | XOR<
          ExposedFieldPolicyCreateWithoutExposedEntityInput,
          ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedFieldPolicyCreateWithoutExposedEntityInput[]
      | ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput[];
    upsert?:
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutExposedEntityInput
      | ExposedFieldPolicyUpsertWithWhereUniqueWithoutExposedEntityInput[];
    createMany?: ExposedFieldPolicyCreateManyExposedEntityInputEnvelope;
    set?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    disconnect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    delete?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    connect?: ExposedFieldPolicyWhereUniqueInput | ExposedFieldPolicyWhereUniqueInput[];
    update?:
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutExposedEntityInput
      | ExposedFieldPolicyUpdateWithWhereUniqueWithoutExposedEntityInput[];
    updateMany?:
      | ExposedFieldPolicyUpdateManyWithWhereWithoutExposedEntityInput
      | ExposedFieldPolicyUpdateManyWithWhereWithoutExposedEntityInput[];
    deleteMany?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
  };

  export type ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput = {
    create?:
      | XOR<
          ExposedRowPolicyCreateWithoutExposedEntityInput,
          ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
        >
      | ExposedRowPolicyCreateWithoutExposedEntityInput[]
      | ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput[];
    connectOrCreate?:
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput
      | ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput[];
    upsert?:
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutExposedEntityInput
      | ExposedRowPolicyUpsertWithWhereUniqueWithoutExposedEntityInput[];
    createMany?: ExposedRowPolicyCreateManyExposedEntityInputEnvelope;
    set?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    disconnect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    delete?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    connect?: ExposedRowPolicyWhereUniqueInput | ExposedRowPolicyWhereUniqueInput[];
    update?:
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutExposedEntityInput
      | ExposedRowPolicyUpdateWithWhereUniqueWithoutExposedEntityInput[];
    updateMany?:
      | ExposedRowPolicyUpdateManyWithWhereWithoutExposedEntityInput
      | ExposedRowPolicyUpdateManyWithWhereWithoutExposedEntityInput[];
    deleteMany?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
  };

  export type ExposedFieldPolicyCreateincludeFieldsInput = {
    set: string[];
  };

  export type ExposedFieldPolicyCreateexcludeFieldsInput = {
    set: string[];
  };

  export type ExposedFieldPolicyCreatewriteProtectedInput = {
    set: string[];
  };

  export type ExposedFieldPolicyCreatemaskedFieldsInput = {
    set: string[];
  };

  export type ExposedEntityCreateNestedOneWithoutFieldPoliciesInput = {
    create?: XOR<
      ExposedEntityCreateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedCreateWithoutFieldPoliciesInput
    >;
    connectOrCreate?: ExposedEntityCreateOrConnectWithoutFieldPoliciesInput;
    connect?: ExposedEntityWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutExposedFieldPoliciesInput = {
    create?: XOR<
      RoleCreateWithoutExposedFieldPoliciesInput,
      RoleUncheckedCreateWithoutExposedFieldPoliciesInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutExposedFieldPoliciesInput;
    connect?: RoleWhereUniqueInput;
  };

  export type ExposedFieldPolicyUpdateincludeFieldsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ExposedFieldPolicyUpdateexcludeFieldsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ExposedFieldPolicyUpdatewriteProtectedInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ExposedFieldPolicyUpdatemaskedFieldsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ExposedEntityUpdateOneRequiredWithoutFieldPoliciesNestedInput = {
    create?: XOR<
      ExposedEntityCreateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedCreateWithoutFieldPoliciesInput
    >;
    connectOrCreate?: ExposedEntityCreateOrConnectWithoutFieldPoliciesInput;
    upsert?: ExposedEntityUpsertWithoutFieldPoliciesInput;
    connect?: ExposedEntityWhereUniqueInput;
    update?: XOR<
      XOR<
        ExposedEntityUpdateToOneWithWhereWithoutFieldPoliciesInput,
        ExposedEntityUpdateWithoutFieldPoliciesInput
      >,
      ExposedEntityUncheckedUpdateWithoutFieldPoliciesInput
    >;
  };

  export type RoleUpdateOneWithoutExposedFieldPoliciesNestedInput = {
    create?: XOR<
      RoleCreateWithoutExposedFieldPoliciesInput,
      RoleUncheckedCreateWithoutExposedFieldPoliciesInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutExposedFieldPoliciesInput;
    upsert?: RoleUpsertWithoutExposedFieldPoliciesInput;
    disconnect?: RoleWhereInput | boolean;
    delete?: RoleWhereInput | boolean;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<
        RoleUpdateToOneWithWhereWithoutExposedFieldPoliciesInput,
        RoleUpdateWithoutExposedFieldPoliciesInput
      >,
      RoleUncheckedUpdateWithoutExposedFieldPoliciesInput
    >;
  };

  export type ExposedEntityCreateNestedOneWithoutRowPoliciesInput = {
    create?: XOR<
      ExposedEntityCreateWithoutRowPoliciesInput,
      ExposedEntityUncheckedCreateWithoutRowPoliciesInput
    >;
    connectOrCreate?: ExposedEntityCreateOrConnectWithoutRowPoliciesInput;
    connect?: ExposedEntityWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutExposedRowPoliciesInput = {
    create?: XOR<
      RoleCreateWithoutExposedRowPoliciesInput,
      RoleUncheckedCreateWithoutExposedRowPoliciesInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutExposedRowPoliciesInput;
    connect?: RoleWhereUniqueInput;
  };

  export type ExposedEntityUpdateOneRequiredWithoutRowPoliciesNestedInput = {
    create?: XOR<
      ExposedEntityCreateWithoutRowPoliciesInput,
      ExposedEntityUncheckedCreateWithoutRowPoliciesInput
    >;
    connectOrCreate?: ExposedEntityCreateOrConnectWithoutRowPoliciesInput;
    upsert?: ExposedEntityUpsertWithoutRowPoliciesInput;
    connect?: ExposedEntityWhereUniqueInput;
    update?: XOR<
      XOR<
        ExposedEntityUpdateToOneWithWhereWithoutRowPoliciesInput,
        ExposedEntityUpdateWithoutRowPoliciesInput
      >,
      ExposedEntityUncheckedUpdateWithoutRowPoliciesInput
    >;
  };

  export type RoleUpdateOneWithoutExposedRowPoliciesNestedInput = {
    create?: XOR<
      RoleCreateWithoutExposedRowPoliciesInput,
      RoleUncheckedCreateWithoutExposedRowPoliciesInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutExposedRowPoliciesInput;
    upsert?: RoleUpsertWithoutExposedRowPoliciesInput;
    disconnect?: RoleWhereInput | boolean;
    delete?: RoleWhereInput | boolean;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<
        RoleUpdateToOneWithWhereWithoutExposedRowPoliciesInput,
        RoleUpdateWithoutExposedRowPoliciesInput
      >,
      RoleUncheckedUpdateWithoutExposedRowPoliciesInput
    >;
  };

  export type TermsAcceptanceCreateNestedManyWithoutTermsInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutTermsInput, TermsAcceptanceUncheckedCreateWithoutTermsInput>
      | TermsAcceptanceCreateWithoutTermsInput[]
      | TermsAcceptanceUncheckedCreateWithoutTermsInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutTermsInput
      | TermsAcceptanceCreateOrConnectWithoutTermsInput[];
    createMany?: TermsAcceptanceCreateManyTermsInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type TermsAcceptanceUncheckedCreateNestedManyWithoutTermsInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutTermsInput, TermsAcceptanceUncheckedCreateWithoutTermsInput>
      | TermsAcceptanceCreateWithoutTermsInput[]
      | TermsAcceptanceUncheckedCreateWithoutTermsInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutTermsInput
      | TermsAcceptanceCreateOrConnectWithoutTermsInput[];
    createMany?: TermsAcceptanceCreateManyTermsInputEnvelope;
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
  };

  export type TermsAcceptanceUpdateManyWithoutTermsNestedInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutTermsInput, TermsAcceptanceUncheckedCreateWithoutTermsInput>
      | TermsAcceptanceCreateWithoutTermsInput[]
      | TermsAcceptanceUncheckedCreateWithoutTermsInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutTermsInput
      | TermsAcceptanceCreateOrConnectWithoutTermsInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutTermsInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutTermsInput[];
    createMany?: TermsAcceptanceCreateManyTermsInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutTermsInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutTermsInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutTermsInput
      | TermsAcceptanceUpdateManyWithWhereWithoutTermsInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutTermsNestedInput = {
    create?:
      | XOR<TermsAcceptanceCreateWithoutTermsInput, TermsAcceptanceUncheckedCreateWithoutTermsInput>
      | TermsAcceptanceCreateWithoutTermsInput[]
      | TermsAcceptanceUncheckedCreateWithoutTermsInput[];
    connectOrCreate?:
      | TermsAcceptanceCreateOrConnectWithoutTermsInput
      | TermsAcceptanceCreateOrConnectWithoutTermsInput[];
    upsert?:
      | TermsAcceptanceUpsertWithWhereUniqueWithoutTermsInput
      | TermsAcceptanceUpsertWithWhereUniqueWithoutTermsInput[];
    createMany?: TermsAcceptanceCreateManyTermsInputEnvelope;
    set?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    disconnect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    delete?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    connect?: TermsAcceptanceWhereUniqueInput | TermsAcceptanceWhereUniqueInput[];
    update?:
      | TermsAcceptanceUpdateWithWhereUniqueWithoutTermsInput
      | TermsAcceptanceUpdateWithWhereUniqueWithoutTermsInput[];
    updateMany?:
      | TermsAcceptanceUpdateManyWithWhereWithoutTermsInput
      | TermsAcceptanceUpdateManyWithWhereWithoutTermsInput[];
    deleteMany?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
  };

  export type OrganizationCreateNestedOneWithoutTermsAcceptancesInput = {
    create?: XOR<
      OrganizationCreateWithoutTermsAcceptancesInput,
      OrganizationUncheckedCreateWithoutTermsAcceptancesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTermsAcceptancesInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type TermsAndConditionsCreateNestedOneWithoutAcceptancesInput = {
    create?: XOR<
      TermsAndConditionsCreateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedCreateWithoutAcceptancesInput
    >;
    connectOrCreate?: TermsAndConditionsCreateOrConnectWithoutAcceptancesInput;
    connect?: TermsAndConditionsWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTermsAcceptancesInput = {
    create?: XOR<
      UserCreateWithoutTermsAcceptancesInput,
      UserUncheckedCreateWithoutTermsAcceptancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTermsAcceptancesInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumAcceptanceMethodFieldUpdateOperationsInput = {
    set?: $Enums.AcceptanceMethod;
  };

  export type OrganizationUpdateOneRequiredWithoutTermsAcceptancesNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutTermsAcceptancesInput,
      OrganizationUncheckedCreateWithoutTermsAcceptancesInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutTermsAcceptancesInput;
    upsert?: OrganizationUpsertWithoutTermsAcceptancesInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutTermsAcceptancesInput,
        OrganizationUpdateWithoutTermsAcceptancesInput
      >,
      OrganizationUncheckedUpdateWithoutTermsAcceptancesInput
    >;
  };

  export type TermsAndConditionsUpdateOneRequiredWithoutAcceptancesNestedInput = {
    create?: XOR<
      TermsAndConditionsCreateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedCreateWithoutAcceptancesInput
    >;
    connectOrCreate?: TermsAndConditionsCreateOrConnectWithoutAcceptancesInput;
    upsert?: TermsAndConditionsUpsertWithoutAcceptancesInput;
    connect?: TermsAndConditionsWhereUniqueInput;
    update?: XOR<
      XOR<
        TermsAndConditionsUpdateToOneWithWhereWithoutAcceptancesInput,
        TermsAndConditionsUpdateWithoutAcceptancesInput
      >,
      TermsAndConditionsUncheckedUpdateWithoutAcceptancesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTermsAcceptancesNestedInput = {
    create?: XOR<
      UserCreateWithoutTermsAcceptancesInput,
      UserUncheckedCreateWithoutTermsAcceptancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTermsAcceptancesInput;
    upsert?: UserUpsertWithoutTermsAcceptancesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTermsAcceptancesInput,
        UserUpdateWithoutTermsAcceptancesInput
      >,
      UserUncheckedUpdateWithoutTermsAcceptancesInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutRateLimitConfigsInput = {
    create?: XOR<
      OrganizationCreateWithoutRateLimitConfigsInput,
      OrganizationUncheckedCreateWithoutRateLimitConfigsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRateLimitConfigsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutRateLimitCreatedInput = {
    create?: XOR<
      UserCreateWithoutRateLimitCreatedInput,
      UserUncheckedCreateWithoutRateLimitCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRateLimitCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutRateLimitUpdatedInput = {
    create?: XOR<
      UserCreateWithoutRateLimitUpdatedInput,
      UserUncheckedCreateWithoutRateLimitUpdatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRateLimitUpdatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumRateLimitTypeFieldUpdateOperationsInput = {
    set?: $Enums.RateLimitType;
  };

  export type EnumRateLimitKeyStrategyFieldUpdateOperationsInput = {
    set?: $Enums.RateLimitKeyStrategy;
  };

  export type OrganizationUpdateOneRequiredWithoutRateLimitConfigsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutRateLimitConfigsInput,
      OrganizationUncheckedCreateWithoutRateLimitConfigsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRateLimitConfigsInput;
    upsert?: OrganizationUpsertWithoutRateLimitConfigsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutRateLimitConfigsInput,
        OrganizationUpdateWithoutRateLimitConfigsInput
      >,
      OrganizationUncheckedUpdateWithoutRateLimitConfigsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutRateLimitCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutRateLimitCreatedInput,
      UserUncheckedCreateWithoutRateLimitCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRateLimitCreatedInput;
    upsert?: UserUpsertWithoutRateLimitCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRateLimitCreatedInput,
        UserUpdateWithoutRateLimitCreatedInput
      >,
      UserUncheckedUpdateWithoutRateLimitCreatedInput
    >;
  };

  export type UserUpdateOneWithoutRateLimitUpdatedNestedInput = {
    create?: XOR<
      UserCreateWithoutRateLimitUpdatedInput,
      UserUncheckedCreateWithoutRateLimitUpdatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRateLimitUpdatedInput;
    upsert?: UserUpsertWithoutRateLimitUpdatedInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRateLimitUpdatedInput,
        UserUpdateWithoutRateLimitUpdatedInput
      >,
      UserUncheckedUpdateWithoutRateLimitUpdatedInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutRateLimitUsageInput = {
    create?: XOR<
      OrganizationCreateWithoutRateLimitUsageInput,
      OrganizationUncheckedCreateWithoutRateLimitUsageInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRateLimitUsageInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type OrganizationUpdateOneRequiredWithoutRateLimitUsageNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutRateLimitUsageInput,
      OrganizationUncheckedCreateWithoutRateLimitUsageInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutRateLimitUsageInput;
    upsert?: OrganizationUpsertWithoutRateLimitUsageInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutRateLimitUsageInput,
        OrganizationUpdateWithoutRateLimitUsageInput
      >,
      OrganizationUncheckedUpdateWithoutRateLimitUsageInput
    >;
  };

  export type UserCreateNestedOneWithoutSocialAccountsInput = {
    create?: XOR<
      UserCreateWithoutSocialAccountsInput,
      UserUncheckedCreateWithoutSocialAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSocialAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutSocialAccountsInput,
      UserUncheckedCreateWithoutSocialAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput;
    upsert?: UserUpsertWithoutSocialAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSocialAccountsInput, UserUpdateWithoutSocialAccountsInput>,
      UserUncheckedUpdateWithoutSocialAccountsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole;
  };

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan;
  };

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus;
  };

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>;
  };

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SubscriptionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type NestedEnumDatabaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseType | EnumDatabaseTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDatabaseTypeFilter<$PrismaModel> | $Enums.DatabaseType;
  };

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
  };

  export type NestedEnumDatabaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseType | EnumDatabaseTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DatabaseType[] | ListEnumDatabaseTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDatabaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.DatabaseType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDatabaseTypeFilter<$PrismaModel>;
    _max?: NestedEnumDatabaseTypeFilter<$PrismaModel>;
  };

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumHttpMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumHttpMethodFilter<$PrismaModel> | $Enums.HttpMethod;
  };

  export type NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HttpMethod | EnumHttpMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HttpMethod[] | ListEnumHttpMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumHttpMethodWithAggregatesFilter<$PrismaModel> | $Enums.HttpMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHttpMethodFilter<$PrismaModel>;
    _max?: NestedEnumHttpMethodFilter<$PrismaModel>;
  };

  export type NestedEnumExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumExecutionStatusFilter<$PrismaModel> | $Enums.ExecutionStatus;
  };

  export type NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExecutionStatus | EnumExecutionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExecutionStatus[] | ListEnumExecutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExecutionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExecutionStatusFilter<$PrismaModel>;
    _max?: NestedEnumExecutionStatusFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType;
  };

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority;
  };

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
  };

  export type NestedEnumExposedEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExposedEntityType | EnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExposedEntityTypeFilter<$PrismaModel> | $Enums.ExposedEntityType;
  };

  export type NestedEnumExposedEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExposedEntityType | EnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExposedEntityType[] | ListEnumExposedEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExposedEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExposedEntityType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExposedEntityTypeFilter<$PrismaModel>;
    _max?: NestedEnumExposedEntityTypeFilter<$PrismaModel>;
  };

  export type NestedEnumAcceptanceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceMethod | EnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumAcceptanceMethodFilter<$PrismaModel> | $Enums.AcceptanceMethod;
  };

  export type NestedEnumAcceptanceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceMethod | EnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    in?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AcceptanceMethod[] | ListEnumAcceptanceMethodFieldRefInput<$PrismaModel>;
    not?: NestedEnumAcceptanceMethodWithAggregatesFilter<$PrismaModel> | $Enums.AcceptanceMethod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAcceptanceMethodFilter<$PrismaModel>;
    _max?: NestedEnumAcceptanceMethodFilter<$PrismaModel>;
  };

  export type NestedEnumRateLimitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitTypeFilter<$PrismaModel> | $Enums.RateLimitType;
  };

  export type NestedEnumRateLimitKeyStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitKeyStrategy | EnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel> | $Enums.RateLimitKeyStrategy;
  };

  export type NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitType | EnumRateLimitTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitType[] | ListEnumRateLimitTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumRateLimitTypeWithAggregatesFilter<$PrismaModel> | $Enums.RateLimitType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRateLimitTypeFilter<$PrismaModel>;
    _max?: NestedEnumRateLimitTypeFilter<$PrismaModel>;
  };

  export type NestedEnumRateLimitKeyStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateLimitKeyStrategy | EnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    in?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RateLimitKeyStrategy[] | ListEnumRateLimitKeyStrategyFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRateLimitKeyStrategyWithAggregatesFilter<$PrismaModel>
      | $Enums.RateLimitKeyStrategy;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel>;
    _max?: NestedEnumRateLimitKeyStrategyFilter<$PrismaModel>;
  };

  export type ApiActivityLogCreateWithoutOrganizationInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointCreateNestedOneWithoutUsageLogsInput;
    user?: UserCreateNestedOneWithoutApiActivityLogsInput;
  };

  export type ApiActivityLogUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    userId?: string | null;
    endpointId?: string | null;
  };

  export type ApiActivityLogCreateOrConnectWithoutOrganizationInput = {
    where: ApiActivityLogWhereUniqueInput;
    create: XOR<
      ApiActivityLogCreateWithoutOrganizationInput,
      ApiActivityLogUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApiActivityLogCreateManyOrganizationInputEnvelope = {
    data: ApiActivityLogCreateManyOrganizationInput | ApiActivityLogCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type ApiKeyCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApiKeysCreatedInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    createdById: string;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyCreateOrConnectWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput;
    create: XOR<
      ApiKeyCreateWithoutOrganizationInput,
      ApiKeyUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApiKeyCreateManyOrganizationInputEnvelope = {
    data: ApiKeyCreateManyOrganizationInput | ApiKeyCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type ApplicationCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator: UserCreateNestedOneWithoutApplicationsCreatedInput;
    defaultRole: RoleCreateNestedOneWithoutApplicationsInput;
  };

  export type ApplicationUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    defaultRoleId: string;
  };

  export type ApplicationCreateOrConnectWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutOrganizationInput,
      ApplicationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApplicationCreateManyOrganizationInputEnvelope = {
    data: ApplicationCreateManyOrganizationInput | ApplicationCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutOrganizationInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    user?: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    userId?: string | null;
  };

  export type AuditLogCreateOrConnectWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<
      AuditLogCreateWithoutOrganizationInput,
      AuditLogUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type AuditLogCreateManyOrganizationInputEnvelope = {
    data: AuditLogCreateManyOrganizationInput | AuditLogCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseConnectionCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput;
    endpoints?: EndpointCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutConnectionInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionCreateOrConnectWithoutOrganizationInput = {
    where: DatabaseConnectionWhereUniqueInput;
    create: XOR<
      DatabaseConnectionCreateWithoutOrganizationInput,
      DatabaseConnectionUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type DatabaseConnectionCreateManyOrganizationInputEnvelope = {
    data:
      | DatabaseConnectionCreateManyOrganizationInput
      | DatabaseConnectionCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseObjectCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service?: ServiceCreateNestedOneWithoutDatabaseObjectsInput;
  };

  export type DatabaseObjectUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serviceId?: string | null;
  };

  export type DatabaseObjectCreateOrConnectWithoutOrganizationInput = {
    where: DatabaseObjectWhereUniqueInput;
    create: XOR<
      DatabaseObjectCreateWithoutOrganizationInput,
      DatabaseObjectUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type DatabaseObjectCreateManyOrganizationInputEnvelope = {
    data: DatabaseObjectCreateManyOrganizationInput | DatabaseObjectCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type EndpointCreateWithoutOrganizationInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    usageLogs?: ApiActivityLogCreateNestedManyWithoutEndpointUsageInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutEndpointsInput;
    creator: UserCreateNestedOneWithoutEndpointsCreatedInput;
  };

  export type EndpointUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    connectionId?: string | null;
    usageLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutEndpointUsageInput;
  };

  export type EndpointCreateOrConnectWithoutOrganizationInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<
      EndpointCreateWithoutOrganizationInput,
      EndpointUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type EndpointCreateManyOrganizationInputEnvelope = {
    data: EndpointCreateManyOrganizationInput | EndpointCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedEntityCreateWithoutOrganizationInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutOrganizationInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutOrganizationInput,
      ExposedEntityUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ExposedEntityCreateManyOrganizationInputEnvelope = {
    data: ExposedEntityCreateManyOrganizationInput | ExposedEntityCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type InvitationCreateWithoutOrganizationInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    invitedBy: UserCreateNestedOneWithoutInvitationsSentInput;
  };

  export type InvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    invitedById: string;
  };

  export type InvitationCreateOrConnectWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput;
    create: XOR<
      InvitationCreateWithoutOrganizationInput,
      InvitationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type InvitationCreateManyOrganizationInputEnvelope = {
    data: InvitationCreateManyOrganizationInput | InvitationCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type MembershipCreateWithoutOrganizationInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    user: UserCreateNestedOneWithoutMembershipsInput;
  };

  export type MembershipUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    userId: string;
  };

  export type MembershipCreateOrConnectWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    create: XOR<
      MembershipCreateWithoutOrganizationInput,
      MembershipUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MembershipCreateManyOrganizationInputEnvelope = {
    data: MembershipCreateManyOrganizationInput | MembershipCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutOrganizationInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    userId: string;
  };

  export type NotificationCreateOrConnectWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutOrganizationInput,
      NotificationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type NotificationCreateManyOrganizationInputEnvelope = {
    data: NotificationCreateManyOrganizationInput | NotificationCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type RoleCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serviceId: string;
    createdBy: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutOrganizationInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>;
  };

  export type RoleCreateManyOrganizationInputEnvelope = {
    data: RoleCreateManyOrganizationInput | RoleCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
  };

  export type ServiceUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    connectionId?: string | null;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutOrganizationInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutOrganizationInput,
      ServiceUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ServiceCreateManyOrganizationInputEnvelope = {
    data: ServiceCreateManyOrganizationInput | ServiceCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type SubscriptionCreateWithoutOrganizationInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput;
    billingEvents?: BillingEventCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionCreateOrConnectWithoutOrganizationInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceCreateWithoutOrganizationInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    terms: TermsAndConditionsCreateNestedOneWithoutAcceptancesInput;
    user: UserCreateNestedOneWithoutTermsAcceptancesInput;
  };

  export type TermsAcceptanceUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    userId: string;
    termsId: string;
  };

  export type TermsAcceptanceCreateOrConnectWithoutOrganizationInput = {
    where: TermsAcceptanceWhereUniqueInput;
    create: XOR<
      TermsAcceptanceCreateWithoutOrganizationInput,
      TermsAcceptanceUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceCreateManyOrganizationInputEnvelope = {
    data: TermsAcceptanceCreateManyOrganizationInput | TermsAcceptanceCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type UsageMetricCreateWithoutOrganizationInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    apiKey?: ApiKeyCreateNestedOneWithoutUsageMetricsInput;
  };

  export type UsageMetricUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    apiKeyId?: string | null;
  };

  export type UsageMetricCreateOrConnectWithoutOrganizationInput = {
    where: UsageMetricWhereUniqueInput;
    create: XOR<
      UsageMetricCreateWithoutOrganizationInput,
      UsageMetricUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type UsageMetricCreateManyOrganizationInputEnvelope = {
    data: UsageMetricCreateManyOrganizationInput | UsageMetricCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type WebhookCreateWithoutOrganizationInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WebhookUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WebhookCreateOrConnectWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput;
    create: XOR<
      WebhookCreateWithoutOrganizationInput,
      WebhookUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type WebhookCreateManyOrganizationInputEnvelope = {
    data: WebhookCreateManyOrganizationInput | WebhookCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type WorkflowCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator?: UserCreateNestedOneWithoutWorkflowsCreatedInput;
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowCreateOrConnectWithoutOrganizationInput = {
    where: WorkflowWhereUniqueInput;
    create: XOR<
      WorkflowCreateWithoutOrganizationInput,
      WorkflowUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type WorkflowCreateManyOrganizationInputEnvelope = {
    data: WorkflowCreateManyOrganizationInput | WorkflowCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type RateLimitConfigCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    creator: UserCreateNestedOneWithoutRateLimitCreatedInput;
    updater?: UserCreateNestedOneWithoutRateLimitUpdatedInput;
  };

  export type RateLimitConfigUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    createdBy: string;
    updatedBy?: string | null;
  };

  export type RateLimitConfigCreateOrConnectWithoutOrganizationInput = {
    where: RateLimitConfigWhereUniqueInput;
    create: XOR<
      RateLimitConfigCreateWithoutOrganizationInput,
      RateLimitConfigUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type RateLimitConfigCreateManyOrganizationInputEnvelope = {
    data: RateLimitConfigCreateManyOrganizationInput | RateLimitConfigCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type RateLimitUsageCreateWithoutOrganizationInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RateLimitUsageUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RateLimitUsageCreateOrConnectWithoutOrganizationInput = {
    where: RateLimitUsageWhereUniqueInput;
    create: XOR<
      RateLimitUsageCreateWithoutOrganizationInput,
      RateLimitUsageUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type RateLimitUsageCreateManyOrganizationInputEnvelope = {
    data: RateLimitUsageCreateManyOrganizationInput | RateLimitUsageCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type BillingEventCreateWithoutOrganizationInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    subscription?: SubscriptionCreateNestedOneWithoutBillingEventsInput;
  };

  export type BillingEventUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    subscriptionId?: string | null;
  };

  export type BillingEventCreateOrConnectWithoutOrganizationInput = {
    where: BillingEventWhereUniqueInput;
    create: XOR<
      BillingEventCreateWithoutOrganizationInput,
      BillingEventUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type BillingEventCreateManyOrganizationInputEnvelope = {
    data: BillingEventCreateManyOrganizationInput | BillingEventCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type ApiActivityLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApiActivityLogWhereUniqueInput;
    update: XOR<
      ApiActivityLogUpdateWithoutOrganizationInput,
      ApiActivityLogUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      ApiActivityLogCreateWithoutOrganizationInput,
      ApiActivityLogUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApiActivityLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApiActivityLogWhereUniqueInput;
    data: XOR<
      ApiActivityLogUpdateWithoutOrganizationInput,
      ApiActivityLogUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type ApiActivityLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApiActivityLogScalarWhereInput;
    data: XOR<
      ApiActivityLogUpdateManyMutationInput,
      ApiActivityLogUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type ApiActivityLogScalarWhereInput = {
    AND?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
    OR?: ApiActivityLogScalarWhereInput[];
    NOT?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
    id?: StringFilter<'ApiActivityLog'> | string;
    requestId?: StringFilter<'ApiActivityLog'> | string;
    timestamp?: DateTimeFilter<'ApiActivityLog'> | Date | string;
    method?: EnumHttpMethodFilter<'ApiActivityLog'> | $Enums.HttpMethod;
    url?: StringFilter<'ApiActivityLog'> | string;
    endpoint?: StringNullableFilter<'ApiActivityLog'> | string | null;
    statusCode?: IntFilter<'ApiActivityLog'> | number;
    responseTime?: IntNullableFilter<'ApiActivityLog'> | number | null;
    userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
    category?: StringNullableFilter<'ApiActivityLog'> | string | null;
    endpointType?: StringNullableFilter<'ApiActivityLog'> | string | null;
    importance?: StringNullableFilter<'ApiActivityLog'> | string | null;
    error?: StringNullableFilter<'ApiActivityLog'> | string | null;
    metadata?: JsonNullableFilter<'ApiActivityLog'>;
    organizationId?: StringFilter<'ApiActivityLog'> | string;
    userId?: StringNullableFilter<'ApiActivityLog'> | string | null;
    endpointId?: StringNullableFilter<'ApiActivityLog'> | string | null;
  };

  export type ApiKeyUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput;
    update: XOR<
      ApiKeyUpdateWithoutOrganizationInput,
      ApiKeyUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      ApiKeyCreateWithoutOrganizationInput,
      ApiKeyUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApiKeyUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApiKeyWhereUniqueInput;
    data: XOR<ApiKeyUpdateWithoutOrganizationInput, ApiKeyUncheckedUpdateWithoutOrganizationInput>;
  };

  export type ApiKeyUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApiKeyScalarWhereInput;
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
    OR?: ApiKeyScalarWhereInput[];
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
    id?: StringFilter<'ApiKey'> | string;
    name?: StringFilter<'ApiKey'> | string;
    keyHash?: StringFilter<'ApiKey'> | string;
    keyPrefix?: StringFilter<'ApiKey'> | string;
    lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    isActive?: BoolFilter<'ApiKey'> | boolean;
    permissions?: StringNullableListFilter<'ApiKey'>;
    createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
    organizationId?: StringFilter<'ApiKey'> | string;
    createdById?: StringFilter<'ApiKey'> | string;
  };

  export type ApplicationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput;
    update: XOR<
      ApplicationUpdateWithoutOrganizationInput,
      ApplicationUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      ApplicationCreateWithoutOrganizationInput,
      ApplicationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ApplicationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ApplicationWhereUniqueInput;
    data: XOR<
      ApplicationUpdateWithoutOrganizationInput,
      ApplicationUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type ApplicationUpdateManyWithWhereWithoutOrganizationInput = {
    where: ApplicationScalarWhereInput;
    data: XOR<
      ApplicationUpdateManyMutationInput,
      ApplicationUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
    OR?: ApplicationScalarWhereInput[];
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
    id?: StringFilter<'Application'> | string;
    name?: StringFilter<'Application'> | string;
    description?: StringNullableFilter<'Application'> | string | null;
    apiKeyHash?: StringFilter<'Application'> | string;
    apiKeyEncrypted?: StringFilter<'Application'> | string;
    apiKeyPrefix?: StringFilter<'Application'> | string;
    apiKeyHint?: StringFilter<'Application'> | string;
    isActive?: BoolFilter<'Application'> | boolean;
    createdAt?: DateTimeFilter<'Application'> | Date | string;
    updatedAt?: DateTimeFilter<'Application'> | Date | string;
    organizationId?: StringFilter<'Application'> | string;
    createdBy?: StringFilter<'Application'> | string;
    defaultRoleId?: StringFilter<'Application'> | string;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<
      AuditLogUpdateWithoutOrganizationInput,
      AuditLogUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      AuditLogCreateWithoutOrganizationInput,
      AuditLogUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<
      AuditLogUpdateWithoutOrganizationInput,
      AuditLogUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type AuditLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringFilter<'AuditLog'> | string;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    timestamp?: DateTimeFilter<'AuditLog'> | Date | string;
    organizationId?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
  };

  export type DatabaseConnectionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DatabaseConnectionWhereUniqueInput;
    update: XOR<
      DatabaseConnectionUpdateWithoutOrganizationInput,
      DatabaseConnectionUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      DatabaseConnectionCreateWithoutOrganizationInput,
      DatabaseConnectionUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type DatabaseConnectionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DatabaseConnectionWhereUniqueInput;
    data: XOR<
      DatabaseConnectionUpdateWithoutOrganizationInput,
      DatabaseConnectionUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type DatabaseConnectionUpdateManyWithWhereWithoutOrganizationInput = {
    where: DatabaseConnectionScalarWhereInput;
    data: XOR<
      DatabaseConnectionUpdateManyMutationInput,
      DatabaseConnectionUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type DatabaseConnectionScalarWhereInput = {
    AND?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
    OR?: DatabaseConnectionScalarWhereInput[];
    NOT?: DatabaseConnectionScalarWhereInput | DatabaseConnectionScalarWhereInput[];
    id?: StringFilter<'DatabaseConnection'> | string;
    name?: StringFilter<'DatabaseConnection'> | string;
    type?: EnumDatabaseTypeFilter<'DatabaseConnection'> | $Enums.DatabaseType;
    host?: StringFilter<'DatabaseConnection'> | string;
    port?: IntFilter<'DatabaseConnection'> | number;
    database?: StringFilter<'DatabaseConnection'> | string;
    username?: StringFilter<'DatabaseConnection'> | string;
    passwordEncrypted?: StringFilter<'DatabaseConnection'> | string;
    sslEnabled?: BoolFilter<'DatabaseConnection'> | boolean;
    isActive?: BoolFilter<'DatabaseConnection'> | boolean;
    lastTestedAt?: DateTimeNullableFilter<'DatabaseConnection'> | Date | string | null;
    lastTestResult?: BoolNullableFilter<'DatabaseConnection'> | boolean | null;
    createdAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
    updatedAt?: DateTimeFilter<'DatabaseConnection'> | Date | string;
    organizationId?: StringFilter<'DatabaseConnection'> | string;
    createdBy?: StringNullableFilter<'DatabaseConnection'> | string | null;
    databases?: JsonNullableFilter<'DatabaseConnection'>;
  };

  export type DatabaseObjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DatabaseObjectWhereUniqueInput;
    update: XOR<
      DatabaseObjectUpdateWithoutOrganizationInput,
      DatabaseObjectUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      DatabaseObjectCreateWithoutOrganizationInput,
      DatabaseObjectUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type DatabaseObjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DatabaseObjectWhereUniqueInput;
    data: XOR<
      DatabaseObjectUpdateWithoutOrganizationInput,
      DatabaseObjectUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type DatabaseObjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: DatabaseObjectScalarWhereInput;
    data: XOR<
      DatabaseObjectUpdateManyMutationInput,
      DatabaseObjectUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type DatabaseObjectScalarWhereInput = {
    AND?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
    OR?: DatabaseObjectScalarWhereInput[];
    NOT?: DatabaseObjectScalarWhereInput | DatabaseObjectScalarWhereInput[];
    id?: StringFilter<'DatabaseObject'> | string;
    name?: StringFilter<'DatabaseObject'> | string;
    schema?: StringNullableFilter<'DatabaseObject'> | string | null;
    type?: StringFilter<'DatabaseObject'> | string;
    path?: StringNullableFilter<'DatabaseObject'> | string | null;
    metadata?: JsonNullableFilter<'DatabaseObject'>;
    createdAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    updatedAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    organizationId?: StringFilter<'DatabaseObject'> | string;
    serviceId?: StringNullableFilter<'DatabaseObject'> | string | null;
  };

  export type EndpointUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<
      EndpointUpdateWithoutOrganizationInput,
      EndpointUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      EndpointCreateWithoutOrganizationInput,
      EndpointUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type EndpointUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<
      EndpointUpdateWithoutOrganizationInput,
      EndpointUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type EndpointUpdateManyWithWhereWithoutOrganizationInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type EndpointScalarWhereInput = {
    AND?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
    OR?: EndpointScalarWhereInput[];
    NOT?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
    id?: StringFilter<'Endpoint'> | string;
    path?: StringFilter<'Endpoint'> | string;
    method?: EnumHttpMethodFilter<'Endpoint'> | $Enums.HttpMethod;
    name?: StringFilter<'Endpoint'> | string;
    description?: StringNullableFilter<'Endpoint'> | string | null;
    query?: StringFilter<'Endpoint'> | string;
    queryParams?: JsonNullableFilter<'Endpoint'>;
    bodySchema?: JsonNullableFilter<'Endpoint'>;
    responseSchema?: JsonNullableFilter<'Endpoint'>;
    apiKey?: StringFilter<'Endpoint'> | string;
    isActive?: BoolFilter<'Endpoint'> | boolean;
    rateLimitPerMinute?: IntFilter<'Endpoint'> | number;
    requiresAuth?: BoolFilter<'Endpoint'> | boolean;
    createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
    organizationId?: StringFilter<'Endpoint'> | string;
    createdBy?: StringFilter<'Endpoint'> | string;
    connectionId?: StringNullableFilter<'Endpoint'> | string | null;
  };

  export type ExposedEntityUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ExposedEntityWhereUniqueInput;
    update: XOR<
      ExposedEntityUpdateWithoutOrganizationInput,
      ExposedEntityUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutOrganizationInput,
      ExposedEntityUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ExposedEntityUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ExposedEntityWhereUniqueInput;
    data: XOR<
      ExposedEntityUpdateWithoutOrganizationInput,
      ExposedEntityUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type ExposedEntityUpdateManyWithWhereWithoutOrganizationInput = {
    where: ExposedEntityScalarWhereInput;
    data: XOR<
      ExposedEntityUpdateManyMutationInput,
      ExposedEntityUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type ExposedEntityScalarWhereInput = {
    AND?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
    OR?: ExposedEntityScalarWhereInput[];
    NOT?: ExposedEntityScalarWhereInput | ExposedEntityScalarWhereInput[];
    id?: StringFilter<'ExposedEntity'> | string;
    serviceId?: StringFilter<'ExposedEntity'> | string;
    connectionId?: StringFilter<'ExposedEntity'> | string;
    organizationId?: StringFilter<'ExposedEntity'> | string;
    database?: StringFilter<'ExposedEntity'> | string;
    schema?: StringNullableFilter<'ExposedEntity'> | string | null;
    name?: StringFilter<'ExposedEntity'> | string;
    type?: EnumExposedEntityTypeFilter<'ExposedEntity'> | $Enums.ExposedEntityType;
    primaryKey?: StringNullableFilter<'ExposedEntity'> | string | null;
    allowRead?: BoolFilter<'ExposedEntity'> | boolean;
    allowCreate?: BoolFilter<'ExposedEntity'> | boolean;
    allowUpdate?: BoolFilter<'ExposedEntity'> | boolean;
    allowDelete?: BoolFilter<'ExposedEntity'> | boolean;
    defaultSort?: StringNullableFilter<'ExposedEntity'> | string | null;
    softDeleteEnabled?: BoolFilter<'ExposedEntity'> | boolean;
    softDeleteColumn?: StringNullableFilter<'ExposedEntity'> | string | null;
    softDeleteValue?: StringNullableFilter<'ExposedEntity'> | string | null;
    pathSlug?: StringNullableFilter<'ExposedEntity'> | string | null;
    createdAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedEntity'> | Date | string;
    createdBy?: StringNullableFilter<'ExposedEntity'> | string | null;
  };

  export type InvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput;
    update: XOR<
      InvitationUpdateWithoutOrganizationInput,
      InvitationUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      InvitationCreateWithoutOrganizationInput,
      InvitationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type InvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput;
    data: XOR<
      InvitationUpdateWithoutOrganizationInput,
      InvitationUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type InvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvitationScalarWhereInput;
    data: XOR<
      InvitationUpdateManyMutationInput,
      InvitationUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
    OR?: InvitationScalarWhereInput[];
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[];
    id?: StringFilter<'Invitation'> | string;
    email?: StringFilter<'Invitation'> | string;
    role?: EnumMemberRoleFilter<'Invitation'> | $Enums.MemberRole;
    token?: StringFilter<'Invitation'> | string;
    expiresAt?: DateTimeFilter<'Invitation'> | Date | string;
    acceptedAt?: DateTimeNullableFilter<'Invitation'> | Date | string | null;
    createdAt?: DateTimeFilter<'Invitation'> | Date | string;
    organizationId?: StringFilter<'Invitation'> | string;
    invitedById?: StringFilter<'Invitation'> | string;
  };

  export type MembershipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    update: XOR<
      MembershipUpdateWithoutOrganizationInput,
      MembershipUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      MembershipCreateWithoutOrganizationInput,
      MembershipUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type MembershipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MembershipWhereUniqueInput;
    data: XOR<
      MembershipUpdateWithoutOrganizationInput,
      MembershipUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type MembershipUpdateManyWithWhereWithoutOrganizationInput = {
    where: MembershipScalarWhereInput;
    data: XOR<
      MembershipUpdateManyMutationInput,
      MembershipUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
    OR?: MembershipScalarWhereInput[];
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[];
    id?: StringFilter<'Membership'> | string;
    role?: EnumMemberRoleFilter<'Membership'> | $Enums.MemberRole;
    joinedAt?: DateTimeFilter<'Membership'> | Date | string;
    userId?: StringFilter<'Membership'> | string;
    organizationId?: StringFilter<'Membership'> | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<
      NotificationUpdateWithoutOrganizationInput,
      NotificationUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      NotificationCreateWithoutOrganizationInput,
      NotificationUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type NotificationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<
      NotificationUpdateWithoutOrganizationInput,
      NotificationUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type NotificationUpdateManyWithWhereWithoutOrganizationInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    isRead?: BoolFilter<'Notification'> | boolean;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    metadata?: JsonNullableFilter<'Notification'>;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    organizationId?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
  };

  export type RoleUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: RoleWhereUniqueInput;
    update: XOR<RoleUpdateWithoutOrganizationInput, RoleUncheckedUpdateWithoutOrganizationInput>;
    create: XOR<RoleCreateWithoutOrganizationInput, RoleUncheckedCreateWithoutOrganizationInput>;
  };

  export type RoleUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: RoleWhereUniqueInput;
    data: XOR<RoleUpdateWithoutOrganizationInput, RoleUncheckedUpdateWithoutOrganizationInput>;
  };

  export type RoleUpdateManyWithWhereWithoutOrganizationInput = {
    where: RoleScalarWhereInput;
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[];
    OR?: RoleScalarWhereInput[];
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    description?: StringNullableFilter<'Role'> | string | null;
    isActive?: BoolFilter<'Role'> | boolean;
    permissions?: JsonFilter<'Role'>;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
    organizationId?: StringFilter<'Role'> | string;
    serviceId?: StringFilter<'Role'> | string;
    createdBy?: StringFilter<'Role'> | string;
  };

  export type ServiceUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<
      ServiceUpdateWithoutOrganizationInput,
      ServiceUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      ServiceCreateWithoutOrganizationInput,
      ServiceUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type ServiceUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<
      ServiceUpdateWithoutOrganizationInput,
      ServiceUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type ServiceUpdateManyWithWhereWithoutOrganizationInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    OR?: ServiceScalarWhereInput[];
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    label?: StringNullableFilter<'Service'> | string | null;
    description?: StringNullableFilter<'Service'> | string | null;
    host?: StringNullableFilter<'Service'> | string | null;
    port?: IntNullableFilter<'Service'> | number | null;
    database?: StringFilter<'Service'> | string;
    username?: StringNullableFilter<'Service'> | string | null;
    passwordEncrypted?: StringNullableFilter<'Service'> | string | null;
    isActive?: BoolFilter<'Service'> | boolean;
    failoverHost?: StringNullableFilter<'Service'> | string | null;
    objects?: JsonNullableFilter<'Service'>;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    organizationId?: StringFilter<'Service'> | string;
    createdBy?: StringFilter<'Service'> | string;
    connectionId?: StringNullableFilter<'Service'> | string | null;
  };

  export type SubscriptionUpsertWithoutOrganizationInput = {
    update: XOR<
      SubscriptionUpdateWithoutOrganizationInput,
      SubscriptionUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      SubscriptionCreateWithoutOrganizationInput,
      SubscriptionUncheckedCreateWithoutOrganizationInput
    >;
    where?: SubscriptionWhereInput;
  };

  export type SubscriptionUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: SubscriptionWhereInput;
    data: XOR<
      SubscriptionUpdateWithoutOrganizationInput,
      SubscriptionUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type SubscriptionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type TermsAcceptanceUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TermsAcceptanceWhereUniqueInput;
    update: XOR<
      TermsAcceptanceUpdateWithoutOrganizationInput,
      TermsAcceptanceUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      TermsAcceptanceCreateWithoutOrganizationInput,
      TermsAcceptanceUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TermsAcceptanceWhereUniqueInput;
    data: XOR<
      TermsAcceptanceUpdateWithoutOrganizationInput,
      TermsAcceptanceUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceUpdateManyWithWhereWithoutOrganizationInput = {
    where: TermsAcceptanceScalarWhereInput;
    data: XOR<
      TermsAcceptanceUpdateManyMutationInput,
      TermsAcceptanceUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type TermsAcceptanceScalarWhereInput = {
    AND?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
    OR?: TermsAcceptanceScalarWhereInput[];
    NOT?: TermsAcceptanceScalarWhereInput | TermsAcceptanceScalarWhereInput[];
    id?: StringFilter<'TermsAcceptance'> | string;
    acceptedAt?: DateTimeFilter<'TermsAcceptance'> | Date | string;
    ipAddress?: StringFilter<'TermsAcceptance'> | string;
    userAgent?: StringNullableFilter<'TermsAcceptance'> | string | null;
    geolocation?: JsonNullableFilter<'TermsAcceptance'>;
    acceptanceMethod?: EnumAcceptanceMethodFilter<'TermsAcceptance'> | $Enums.AcceptanceMethod;
    organizationId?: StringFilter<'TermsAcceptance'> | string;
    userId?: StringFilter<'TermsAcceptance'> | string;
    termsId?: StringFilter<'TermsAcceptance'> | string;
  };

  export type UsageMetricUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UsageMetricWhereUniqueInput;
    update: XOR<
      UsageMetricUpdateWithoutOrganizationInput,
      UsageMetricUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      UsageMetricCreateWithoutOrganizationInput,
      UsageMetricUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type UsageMetricUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UsageMetricWhereUniqueInput;
    data: XOR<
      UsageMetricUpdateWithoutOrganizationInput,
      UsageMetricUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type UsageMetricUpdateManyWithWhereWithoutOrganizationInput = {
    where: UsageMetricScalarWhereInput;
    data: XOR<
      UsageMetricUpdateManyMutationInput,
      UsageMetricUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type UsageMetricScalarWhereInput = {
    AND?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
    OR?: UsageMetricScalarWhereInput[];
    NOT?: UsageMetricScalarWhereInput | UsageMetricScalarWhereInput[];
    id?: StringFilter<'UsageMetric'> | string;
    endpoint?: StringFilter<'UsageMetric'> | string;
    method?: StringFilter<'UsageMetric'> | string;
    statusCode?: IntFilter<'UsageMetric'> | number;
    responseTimeMs?: IntFilter<'UsageMetric'> | number;
    timestamp?: DateTimeFilter<'UsageMetric'> | Date | string;
    organizationId?: StringFilter<'UsageMetric'> | string;
    apiKeyId?: StringNullableFilter<'UsageMetric'> | string | null;
  };

  export type WebhookUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput;
    update: XOR<
      WebhookUpdateWithoutOrganizationInput,
      WebhookUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      WebhookCreateWithoutOrganizationInput,
      WebhookUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type WebhookUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: WebhookWhereUniqueInput;
    data: XOR<
      WebhookUpdateWithoutOrganizationInput,
      WebhookUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type WebhookUpdateManyWithWhereWithoutOrganizationInput = {
    where: WebhookScalarWhereInput;
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[];
    OR?: WebhookScalarWhereInput[];
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[];
    id?: StringFilter<'Webhook'> | string;
    url?: StringFilter<'Webhook'> | string;
    events?: StringNullableListFilter<'Webhook'>;
    secret?: StringFilter<'Webhook'> | string;
    isActive?: BoolFilter<'Webhook'> | boolean;
    lastTriggeredAt?: DateTimeNullableFilter<'Webhook'> | Date | string | null;
    failureCount?: IntFilter<'Webhook'> | number;
    createdAt?: DateTimeFilter<'Webhook'> | Date | string;
    updatedAt?: DateTimeFilter<'Webhook'> | Date | string;
    organizationId?: StringFilter<'Webhook'> | string;
  };

  export type WorkflowUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: WorkflowWhereUniqueInput;
    update: XOR<
      WorkflowUpdateWithoutOrganizationInput,
      WorkflowUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      WorkflowCreateWithoutOrganizationInput,
      WorkflowUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type WorkflowUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: WorkflowWhereUniqueInput;
    data: XOR<
      WorkflowUpdateWithoutOrganizationInput,
      WorkflowUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type WorkflowUpdateManyWithWhereWithoutOrganizationInput = {
    where: WorkflowScalarWhereInput;
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
    OR?: WorkflowScalarWhereInput[];
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
    id?: StringFilter<'Workflow'> | string;
    name?: StringFilter<'Workflow'> | string;
    description?: StringNullableFilter<'Workflow'> | string | null;
    definition?: JsonFilter<'Workflow'>;
    isActive?: BoolFilter<'Workflow'> | boolean;
    trigger?: JsonFilter<'Workflow'>;
    lastRunAt?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    runCount?: IntFilter<'Workflow'> | number;
    createdAt?: DateTimeFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
    organizationId?: StringFilter<'Workflow'> | string;
    createdBy?: StringNullableFilter<'Workflow'> | string | null;
  };

  export type RateLimitConfigUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: RateLimitConfigWhereUniqueInput;
    update: XOR<
      RateLimitConfigUpdateWithoutOrganizationInput,
      RateLimitConfigUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      RateLimitConfigCreateWithoutOrganizationInput,
      RateLimitConfigUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type RateLimitConfigUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: RateLimitConfigWhereUniqueInput;
    data: XOR<
      RateLimitConfigUpdateWithoutOrganizationInput,
      RateLimitConfigUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type RateLimitConfigUpdateManyWithWhereWithoutOrganizationInput = {
    where: RateLimitConfigScalarWhereInput;
    data: XOR<
      RateLimitConfigUpdateManyMutationInput,
      RateLimitConfigUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type RateLimitConfigScalarWhereInput = {
    AND?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
    OR?: RateLimitConfigScalarWhereInput[];
    NOT?: RateLimitConfigScalarWhereInput | RateLimitConfigScalarWhereInput[];
    id?: StringFilter<'RateLimitConfig'> | string;
    name?: StringFilter<'RateLimitConfig'> | string;
    displayName?: StringFilter<'RateLimitConfig'> | string;
    type?: EnumRateLimitTypeFilter<'RateLimitConfig'> | $Enums.RateLimitType;
    max?: IntFilter<'RateLimitConfig'> | number;
    windowMs?: IntFilter<'RateLimitConfig'> | number;
    keyStrategy?: EnumRateLimitKeyStrategyFilter<'RateLimitConfig'> | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFilter<'RateLimitConfig'> | boolean;
    description?: StringNullableFilter<'RateLimitConfig'> | string | null;
    createdAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    updatedAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    applicationLimits?: JsonNullableFilter<'RateLimitConfig'>;
    roleLimits?: JsonNullableFilter<'RateLimitConfig'>;
    componentLimits?: JsonNullableFilter<'RateLimitConfig'>;
    changeHistory?: JsonNullableFilter<'RateLimitConfig'>;
    changeReason?: StringNullableFilter<'RateLimitConfig'> | string | null;
    organizationId?: StringFilter<'RateLimitConfig'> | string;
    createdBy?: StringFilter<'RateLimitConfig'> | string;
    updatedBy?: StringNullableFilter<'RateLimitConfig'> | string | null;
  };

  export type RateLimitUsageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: RateLimitUsageWhereUniqueInput;
    update: XOR<
      RateLimitUsageUpdateWithoutOrganizationInput,
      RateLimitUsageUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      RateLimitUsageCreateWithoutOrganizationInput,
      RateLimitUsageUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type RateLimitUsageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: RateLimitUsageWhereUniqueInput;
    data: XOR<
      RateLimitUsageUpdateWithoutOrganizationInput,
      RateLimitUsageUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type RateLimitUsageUpdateManyWithWhereWithoutOrganizationInput = {
    where: RateLimitUsageScalarWhereInput;
    data: XOR<
      RateLimitUsageUpdateManyMutationInput,
      RateLimitUsageUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type RateLimitUsageScalarWhereInput = {
    AND?: RateLimitUsageScalarWhereInput | RateLimitUsageScalarWhereInput[];
    OR?: RateLimitUsageScalarWhereInput[];
    NOT?: RateLimitUsageScalarWhereInput | RateLimitUsageScalarWhereInput[];
    id?: StringFilter<'RateLimitUsage'> | string;
    configName?: StringFilter<'RateLimitUsage'> | string;
    limitKey?: StringFilter<'RateLimitUsage'> | string;
    currentCount?: IntFilter<'RateLimitUsage'> | number;
    resetAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    blocked?: BoolFilter<'RateLimitUsage'> | boolean;
    createdAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    updatedAt?: DateTimeFilter<'RateLimitUsage'> | Date | string;
    organizationId?: StringFilter<'RateLimitUsage'> | string;
  };

  export type BillingEventUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: BillingEventWhereUniqueInput;
    update: XOR<
      BillingEventUpdateWithoutOrganizationInput,
      BillingEventUncheckedUpdateWithoutOrganizationInput
    >;
    create: XOR<
      BillingEventCreateWithoutOrganizationInput,
      BillingEventUncheckedCreateWithoutOrganizationInput
    >;
  };

  export type BillingEventUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: BillingEventWhereUniqueInput;
    data: XOR<
      BillingEventUpdateWithoutOrganizationInput,
      BillingEventUncheckedUpdateWithoutOrganizationInput
    >;
  };

  export type BillingEventUpdateManyWithWhereWithoutOrganizationInput = {
    where: BillingEventScalarWhereInput;
    data: XOR<
      BillingEventUpdateManyMutationInput,
      BillingEventUncheckedUpdateManyWithoutOrganizationInput
    >;
  };

  export type BillingEventScalarWhereInput = {
    AND?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
    OR?: BillingEventScalarWhereInput[];
    NOT?: BillingEventScalarWhereInput | BillingEventScalarWhereInput[];
    id?: StringFilter<'BillingEvent'> | string;
    eventType?: StringFilter<'BillingEvent'> | string;
    stripeEventId?: StringFilter<'BillingEvent'> | string;
    metadata?: JsonFilter<'BillingEvent'>;
    createdAt?: DateTimeFilter<'BillingEvent'> | Date | string;
    organizationId?: StringNullableFilter<'BillingEvent'> | string | null;
    subscriptionId?: StringNullableFilter<'BillingEvent'> | string | null;
  };

  export type ApiActivityLogCreateWithoutUserInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointCreateNestedOneWithoutUsageLogsInput;
    organization: OrganizationCreateNestedOneWithoutApiActivityLogsInput;
  };

  export type ApiActivityLogUncheckedCreateWithoutUserInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    endpointId?: string | null;
  };

  export type ApiActivityLogCreateOrConnectWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    create: XOR<
      ApiActivityLogCreateWithoutUserInput,
      ApiActivityLogUncheckedCreateWithoutUserInput
    >;
  };

  export type ApiActivityLogCreateManyUserInputEnvelope = {
    data: ApiActivityLogCreateManyUserInput | ApiActivityLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ApiKeyCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutApiKeysInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organizationId: string;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutApiKeyInput;
  };

  export type ApiKeyCreateOrConnectWithoutCreatedByInput = {
    where: ApiKeyWhereUniqueInput;
    create: XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>;
  };

  export type ApiKeyCreateManyCreatedByInputEnvelope = {
    data: ApiKeyCreateManyCreatedByInput | ApiKeyCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ApplicationCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    defaultRole: RoleCreateNestedOneWithoutApplicationsInput;
    organization: OrganizationCreateNestedOneWithoutApplicationsInput;
  };

  export type ApplicationUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    defaultRoleId: string;
  };

  export type ApplicationCreateOrConnectWithoutCreatorInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutCreatorInput,
      ApplicationUncheckedCreateWithoutCreatorInput
    >;
  };

  export type ApplicationCreateManyCreatorInputEnvelope = {
    data: ApplicationCreateManyCreatorInput | ApplicationCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organization: OrganizationCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organizationId: string;
  };

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseConnectionCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    organization: OrganizationCreateNestedOneWithoutDatabaseConnectionsInput;
    endpoints?: EndpointCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutConnectionInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionCreateOrConnectWithoutCreatorInput = {
    where: DatabaseConnectionWhereUniqueInput;
    create: XOR<
      DatabaseConnectionCreateWithoutCreatorInput,
      DatabaseConnectionUncheckedCreateWithoutCreatorInput
    >;
  };

  export type DatabaseConnectionCreateManyCreatorInputEnvelope = {
    data: DatabaseConnectionCreateManyCreatorInput | DatabaseConnectionCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type EndpointCreateWithoutCreatorInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    usageLogs?: ApiActivityLogCreateNestedManyWithoutEndpointUsageInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutEndpointsInput;
    organization: OrganizationCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutCreatorInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    connectionId?: string | null;
    usageLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutEndpointUsageInput;
  };

  export type EndpointCreateOrConnectWithoutCreatorInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>;
  };

  export type EndpointCreateManyCreatorInputEnvelope = {
    data: EndpointCreateManyCreatorInput | EndpointCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedEntityCreateWithoutCreatorInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutCreatorInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutCreatorInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutCreatorInput,
      ExposedEntityUncheckedCreateWithoutCreatorInput
    >;
  };

  export type ExposedEntityCreateManyCreatorInputEnvelope = {
    data: ExposedEntityCreateManyCreatorInput | ExposedEntityCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type InvitationCreateWithoutInvitedByInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutInvitationsInput;
  };

  export type InvitationUncheckedCreateWithoutInvitedByInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    organizationId: string;
  };

  export type InvitationCreateOrConnectWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput;
    create: XOR<
      InvitationCreateWithoutInvitedByInput,
      InvitationUncheckedCreateWithoutInvitedByInput
    >;
  };

  export type InvitationCreateManyInvitedByInputEnvelope = {
    data: InvitationCreateManyInvitedByInput | InvitationCreateManyInvitedByInput[];
    skipDuplicates?: boolean;
  };

  export type MembershipCreateWithoutUserInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutMembershipsInput;
  };

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    organizationId: string;
  };

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>;
  };

  export type MembershipCreateManyUserInputEnvelope = {
    data: MembershipCreateManyUserInput | MembershipCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId: string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type RoleCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutCreatorInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>;
  };

  export type RoleCreateManyCreatorInputEnvelope = {
    data: RoleCreateManyCreatorInput | RoleCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    connectionId?: string | null;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutCreatorInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>;
  };

  export type ServiceCreateManyCreatorInputEnvelope = {
    data: ServiceCreateManyCreatorInput | ServiceCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type TermsAcceptanceCreateWithoutUserInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organization: OrganizationCreateNestedOneWithoutTermsAcceptancesInput;
    terms: TermsAndConditionsCreateNestedOneWithoutAcceptancesInput;
  };

  export type TermsAcceptanceUncheckedCreateWithoutUserInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    termsId: string;
  };

  export type TermsAcceptanceCreateOrConnectWithoutUserInput = {
    where: TermsAcceptanceWhereUniqueInput;
    create: XOR<
      TermsAcceptanceCreateWithoutUserInput,
      TermsAcceptanceUncheckedCreateWithoutUserInput
    >;
  };

  export type TermsAcceptanceCreateManyUserInputEnvelope = {
    data: TermsAcceptanceCreateManyUserInput | TermsAcceptanceCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type WorkflowCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput;
    executions?: WorkflowExecutionCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    executions?: WorkflowExecutionUncheckedCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowCreateOrConnectWithoutCreatorInput = {
    where: WorkflowWhereUniqueInput;
    create: XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>;
  };

  export type WorkflowCreateManyCreatorInputEnvelope = {
    data: WorkflowCreateManyCreatorInput | WorkflowCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type RateLimitConfigCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organization: OrganizationCreateNestedOneWithoutRateLimitConfigsInput;
    updater?: UserCreateNestedOneWithoutRateLimitUpdatedInput;
  };

  export type RateLimitConfigUncheckedCreateWithoutCreatorInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    updatedBy?: string | null;
  };

  export type RateLimitConfigCreateOrConnectWithoutCreatorInput = {
    where: RateLimitConfigWhereUniqueInput;
    create: XOR<
      RateLimitConfigCreateWithoutCreatorInput,
      RateLimitConfigUncheckedCreateWithoutCreatorInput
    >;
  };

  export type RateLimitConfigCreateManyCreatorInputEnvelope = {
    data: RateLimitConfigCreateManyCreatorInput | RateLimitConfigCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type RateLimitConfigCreateWithoutUpdaterInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organization: OrganizationCreateNestedOneWithoutRateLimitConfigsInput;
    creator: UserCreateNestedOneWithoutRateLimitCreatedInput;
  };

  export type RateLimitConfigUncheckedCreateWithoutUpdaterInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    createdBy: string;
  };

  export type RateLimitConfigCreateOrConnectWithoutUpdaterInput = {
    where: RateLimitConfigWhereUniqueInput;
    create: XOR<
      RateLimitConfigCreateWithoutUpdaterInput,
      RateLimitConfigUncheckedCreateWithoutUpdaterInput
    >;
  };

  export type RateLimitConfigCreateManyUpdaterInputEnvelope = {
    data: RateLimitConfigCreateManyUpdaterInput | RateLimitConfigCreateManyUpdaterInput[];
    skipDuplicates?: boolean;
  };

  export type SocialAccountCreateWithoutUserInput = {
    id?: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SocialAccountUncheckedCreateWithoutUserInput = {
    id?: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SocialAccountCreateOrConnectWithoutUserInput = {
    where: SocialAccountWhereUniqueInput;
    create: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>;
  };

  export type SocialAccountCreateManyUserInputEnvelope = {
    data: SocialAccountCreateManyUserInput | SocialAccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ApiActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    update: XOR<
      ApiActivityLogUpdateWithoutUserInput,
      ApiActivityLogUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ApiActivityLogCreateWithoutUserInput,
      ApiActivityLogUncheckedCreateWithoutUserInput
    >;
  };

  export type ApiActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    data: XOR<ApiActivityLogUpdateWithoutUserInput, ApiActivityLogUncheckedUpdateWithoutUserInput>;
  };

  export type ApiActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ApiActivityLogScalarWhereInput;
    data: XOR<
      ApiActivityLogUpdateManyMutationInput,
      ApiActivityLogUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ApiKeyUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ApiKeyWhereUniqueInput;
    update: XOR<ApiKeyUpdateWithoutCreatedByInput, ApiKeyUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<ApiKeyCreateWithoutCreatedByInput, ApiKeyUncheckedCreateWithoutCreatedByInput>;
  };

  export type ApiKeyUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ApiKeyWhereUniqueInput;
    data: XOR<ApiKeyUpdateWithoutCreatedByInput, ApiKeyUncheckedUpdateWithoutCreatedByInput>;
  };

  export type ApiKeyUpdateManyWithWhereWithoutCreatedByInput = {
    where: ApiKeyScalarWhereInput;
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type ApplicationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ApplicationWhereUniqueInput;
    update: XOR<
      ApplicationUpdateWithoutCreatorInput,
      ApplicationUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      ApplicationCreateWithoutCreatorInput,
      ApplicationUncheckedCreateWithoutCreatorInput
    >;
  };

  export type ApplicationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ApplicationWhereUniqueInput;
    data: XOR<ApplicationUpdateWithoutCreatorInput, ApplicationUncheckedUpdateWithoutCreatorInput>;
  };

  export type ApplicationUpdateManyWithWhereWithoutCreatorInput = {
    where: ApplicationScalarWhereInput;
    data: XOR<
      ApplicationUpdateManyMutationInput,
      ApplicationUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
  };

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>;
  };

  export type DatabaseConnectionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DatabaseConnectionWhereUniqueInput;
    update: XOR<
      DatabaseConnectionUpdateWithoutCreatorInput,
      DatabaseConnectionUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      DatabaseConnectionCreateWithoutCreatorInput,
      DatabaseConnectionUncheckedCreateWithoutCreatorInput
    >;
  };

  export type DatabaseConnectionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DatabaseConnectionWhereUniqueInput;
    data: XOR<
      DatabaseConnectionUpdateWithoutCreatorInput,
      DatabaseConnectionUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type DatabaseConnectionUpdateManyWithWhereWithoutCreatorInput = {
    where: DatabaseConnectionScalarWhereInput;
    data: XOR<
      DatabaseConnectionUpdateManyMutationInput,
      DatabaseConnectionUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type EndpointUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<EndpointUpdateWithoutCreatorInput, EndpointUncheckedUpdateWithoutCreatorInput>;
    create: XOR<EndpointCreateWithoutCreatorInput, EndpointUncheckedCreateWithoutCreatorInput>;
  };

  export type EndpointUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<EndpointUpdateWithoutCreatorInput, EndpointUncheckedUpdateWithoutCreatorInput>;
  };

  export type EndpointUpdateManyWithWhereWithoutCreatorInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutCreatorInput>;
  };

  export type ExposedEntityUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExposedEntityWhereUniqueInput;
    update: XOR<
      ExposedEntityUpdateWithoutCreatorInput,
      ExposedEntityUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutCreatorInput,
      ExposedEntityUncheckedCreateWithoutCreatorInput
    >;
  };

  export type ExposedEntityUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExposedEntityWhereUniqueInput;
    data: XOR<
      ExposedEntityUpdateWithoutCreatorInput,
      ExposedEntityUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type ExposedEntityUpdateManyWithWhereWithoutCreatorInput = {
    where: ExposedEntityScalarWhereInput;
    data: XOR<
      ExposedEntityUpdateManyMutationInput,
      ExposedEntityUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type InvitationUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput;
    update: XOR<
      InvitationUpdateWithoutInvitedByInput,
      InvitationUncheckedUpdateWithoutInvitedByInput
    >;
    create: XOR<
      InvitationCreateWithoutInvitedByInput,
      InvitationUncheckedCreateWithoutInvitedByInput
    >;
  };

  export type InvitationUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: InvitationWhereUniqueInput;
    data: XOR<
      InvitationUpdateWithoutInvitedByInput,
      InvitationUncheckedUpdateWithoutInvitedByInput
    >;
  };

  export type InvitationUpdateManyWithWhereWithoutInvitedByInput = {
    where: InvitationScalarWhereInput;
    data: XOR<
      InvitationUpdateManyMutationInput,
      InvitationUncheckedUpdateManyWithoutInvitedByInput
    >;
  };

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>;
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>;
  };

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput;
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>;
  };

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput;
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutUserInput>;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>;
  };

  export type RoleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RoleWhereUniqueInput;
    update: XOR<RoleUpdateWithoutCreatorInput, RoleUncheckedUpdateWithoutCreatorInput>;
    create: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>;
  };

  export type RoleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RoleWhereUniqueInput;
    data: XOR<RoleUpdateWithoutCreatorInput, RoleUncheckedUpdateWithoutCreatorInput>;
  };

  export type RoleUpdateManyWithWhereWithoutCreatorInput = {
    where: RoleScalarWhereInput;
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutCreatorInput>;
  };

  export type ServiceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutCreatorInput, ServiceUncheckedUpdateWithoutCreatorInput>;
    create: XOR<ServiceCreateWithoutCreatorInput, ServiceUncheckedCreateWithoutCreatorInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutCreatorInput, ServiceUncheckedUpdateWithoutCreatorInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutCreatorInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCreatorInput>;
  };

  export type TermsAcceptanceUpsertWithWhereUniqueWithoutUserInput = {
    where: TermsAcceptanceWhereUniqueInput;
    update: XOR<
      TermsAcceptanceUpdateWithoutUserInput,
      TermsAcceptanceUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TermsAcceptanceCreateWithoutUserInput,
      TermsAcceptanceUncheckedCreateWithoutUserInput
    >;
  };

  export type TermsAcceptanceUpdateWithWhereUniqueWithoutUserInput = {
    where: TermsAcceptanceWhereUniqueInput;
    data: XOR<
      TermsAcceptanceUpdateWithoutUserInput,
      TermsAcceptanceUncheckedUpdateWithoutUserInput
    >;
  };

  export type TermsAcceptanceUpdateManyWithWhereWithoutUserInput = {
    where: TermsAcceptanceScalarWhereInput;
    data: XOR<
      TermsAcceptanceUpdateManyMutationInput,
      TermsAcceptanceUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type WorkflowUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WorkflowWhereUniqueInput;
    update: XOR<WorkflowUpdateWithoutCreatorInput, WorkflowUncheckedUpdateWithoutCreatorInput>;
    create: XOR<WorkflowCreateWithoutCreatorInput, WorkflowUncheckedCreateWithoutCreatorInput>;
  };

  export type WorkflowUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WorkflowWhereUniqueInput;
    data: XOR<WorkflowUpdateWithoutCreatorInput, WorkflowUncheckedUpdateWithoutCreatorInput>;
  };

  export type WorkflowUpdateManyWithWhereWithoutCreatorInput = {
    where: WorkflowScalarWhereInput;
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutCreatorInput>;
  };

  export type RateLimitConfigUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RateLimitConfigWhereUniqueInput;
    update: XOR<
      RateLimitConfigUpdateWithoutCreatorInput,
      RateLimitConfigUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      RateLimitConfigCreateWithoutCreatorInput,
      RateLimitConfigUncheckedCreateWithoutCreatorInput
    >;
  };

  export type RateLimitConfigUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RateLimitConfigWhereUniqueInput;
    data: XOR<
      RateLimitConfigUpdateWithoutCreatorInput,
      RateLimitConfigUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type RateLimitConfigUpdateManyWithWhereWithoutCreatorInput = {
    where: RateLimitConfigScalarWhereInput;
    data: XOR<
      RateLimitConfigUpdateManyMutationInput,
      RateLimitConfigUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type RateLimitConfigUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: RateLimitConfigWhereUniqueInput;
    update: XOR<
      RateLimitConfigUpdateWithoutUpdaterInput,
      RateLimitConfigUncheckedUpdateWithoutUpdaterInput
    >;
    create: XOR<
      RateLimitConfigCreateWithoutUpdaterInput,
      RateLimitConfigUncheckedCreateWithoutUpdaterInput
    >;
  };

  export type RateLimitConfigUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: RateLimitConfigWhereUniqueInput;
    data: XOR<
      RateLimitConfigUpdateWithoutUpdaterInput,
      RateLimitConfigUncheckedUpdateWithoutUpdaterInput
    >;
  };

  export type RateLimitConfigUpdateManyWithWhereWithoutUpdaterInput = {
    where: RateLimitConfigScalarWhereInput;
    data: XOR<
      RateLimitConfigUpdateManyMutationInput,
      RateLimitConfigUncheckedUpdateManyWithoutUpdaterInput
    >;
  };

  export type SocialAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialAccountWhereUniqueInput;
    update: XOR<SocialAccountUpdateWithoutUserInput, SocialAccountUncheckedUpdateWithoutUserInput>;
    create: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>;
  };

  export type SocialAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialAccountWhereUniqueInput;
    data: XOR<SocialAccountUpdateWithoutUserInput, SocialAccountUncheckedUpdateWithoutUserInput>;
  };

  export type SocialAccountUpdateManyWithWhereWithoutUserInput = {
    where: SocialAccountScalarWhereInput;
    data: XOR<
      SocialAccountUpdateManyMutationInput,
      SocialAccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SocialAccountScalarWhereInput = {
    AND?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[];
    OR?: SocialAccountScalarWhereInput[];
    NOT?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[];
    id?: StringFilter<'SocialAccount'> | string;
    userId?: StringFilter<'SocialAccount'> | string;
    provider?: StringFilter<'SocialAccount'> | string;
    providerId?: StringFilter<'SocialAccount'> | string;
    email?: StringNullableFilter<'SocialAccount'> | string | null;
    name?: StringNullableFilter<'SocialAccount'> | string | null;
    profileUrl?: StringNullableFilter<'SocialAccount'> | string | null;
    avatarUrl?: StringNullableFilter<'SocialAccount'> | string | null;
    accessToken?: StringNullableFilter<'SocialAccount'> | string | null;
    refreshToken?: StringNullableFilter<'SocialAccount'> | string | null;
    profileData?: StringNullableFilter<'SocialAccount'> | string | null;
    createdAt?: DateTimeFilter<'SocialAccount'> | Date | string;
    updatedAt?: DateTimeFilter<'SocialAccount'> | Date | string;
  };

  export type OrganizationCreateWithoutMembershipsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutMembershipsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutMembershipsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
  };

  export type UserCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>;
  };

  export type OrganizationUpsertWithoutMembershipsInput = {
    update: XOR<
      OrganizationUpdateWithoutMembershipsInput,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
    create: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutMembershipsInput,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type OrganizationUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>;
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>;
  };

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutInvitationsSentInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutInvitationsSentInput,
      UserUncheckedCreateWithoutInvitationsSentInput
    >;
  };

  export type OrganizationCreateWithoutInvitationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutInvitationsInput,
      OrganizationUncheckedCreateWithoutInvitationsInput
    >;
  };

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<
      UserUpdateWithoutInvitationsSentInput,
      UserUncheckedUpdateWithoutInvitationsSentInput
    >;
    create: XOR<
      UserCreateWithoutInvitationsSentInput,
      UserUncheckedCreateWithoutInvitationsSentInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutInvitationsSentInput,
      UserUncheckedUpdateWithoutInvitationsSentInput
    >;
  };

  export type UserUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<
      OrganizationUpdateWithoutInvitationsInput,
      OrganizationUncheckedUpdateWithoutInvitationsInput
    >;
    create: XOR<
      OrganizationCreateWithoutInvitationsInput,
      OrganizationUncheckedCreateWithoutInvitationsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutInvitationsInput,
      OrganizationUncheckedUpdateWithoutInvitationsInput
    >;
  };

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateWithoutBillingEventsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutBillingEventsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutBillingEventsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutBillingEventsInput,
      OrganizationUncheckedCreateWithoutBillingEventsInput
    >;
  };

  export type SubscriptionCreateWithoutBillingEventsInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput;
    organization: OrganizationCreateNestedOneWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutBillingEventsInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    organizationId: string;
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionCreateOrConnectWithoutBillingEventsInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutBillingEventsInput,
      SubscriptionUncheckedCreateWithoutBillingEventsInput
    >;
  };

  export type OrganizationUpsertWithoutBillingEventsInput = {
    update: XOR<
      OrganizationUpdateWithoutBillingEventsInput,
      OrganizationUncheckedUpdateWithoutBillingEventsInput
    >;
    create: XOR<
      OrganizationCreateWithoutBillingEventsInput,
      OrganizationUncheckedCreateWithoutBillingEventsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutBillingEventsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutBillingEventsInput,
      OrganizationUncheckedUpdateWithoutBillingEventsInput
    >;
  };

  export type OrganizationUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type SubscriptionUpsertWithoutBillingEventsInput = {
    update: XOR<
      SubscriptionUpdateWithoutBillingEventsInput,
      SubscriptionUncheckedUpdateWithoutBillingEventsInput
    >;
    create: XOR<
      SubscriptionCreateWithoutBillingEventsInput,
      SubscriptionUncheckedCreateWithoutBillingEventsInput
    >;
    where?: SubscriptionWhereInput;
  };

  export type SubscriptionUpdateToOneWithWhereWithoutBillingEventsInput = {
    where?: SubscriptionWhereInput;
    data: XOR<
      SubscriptionUpdateWithoutBillingEventsInput,
      SubscriptionUncheckedUpdateWithoutBillingEventsInput
    >;
  };

  export type SubscriptionUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutBillingEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
  };

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
  };

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput;
    create: XOR<
      InvoiceCreateWithoutSubscriptionInput,
      InvoiceUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[];
    skipDuplicates?: boolean;
  };

  export type BillingEventCreateWithoutSubscriptionInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organization?: OrganizationCreateNestedOneWithoutBillingEventsInput;
  };

  export type BillingEventUncheckedCreateWithoutSubscriptionInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId?: string | null;
  };

  export type BillingEventCreateOrConnectWithoutSubscriptionInput = {
    where: BillingEventWhereUniqueInput;
    create: XOR<
      BillingEventCreateWithoutSubscriptionInput,
      BillingEventUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type BillingEventCreateManySubscriptionInputEnvelope = {
    data: BillingEventCreateManySubscriptionInput | BillingEventCreateManySubscriptionInput[];
    skipDuplicates?: boolean;
  };

  export type OrganizationCreateWithoutSubscriptionInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutSubscriptionInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutSubscriptionInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutSubscriptionInput,
      OrganizationUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput;
    update: XOR<
      InvoiceUpdateWithoutSubscriptionInput,
      InvoiceUncheckedUpdateWithoutSubscriptionInput
    >;
    create: XOR<
      InvoiceCreateWithoutSubscriptionInput,
      InvoiceUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput;
    data: XOR<
      InvoiceUpdateWithoutSubscriptionInput,
      InvoiceUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput;
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>;
  };

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
    OR?: InvoiceScalarWhereInput[];
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[];
    id?: StringFilter<'Invoice'> | string;
    invoiceNumber?: StringFilter<'Invoice'> | string;
    amount?: FloatFilter<'Invoice'> | number;
    currency?: StringFilter<'Invoice'> | string;
    status?: EnumInvoiceStatusFilter<'Invoice'> | $Enums.InvoiceStatus;
    dueDate?: DateTimeFilter<'Invoice'> | Date | string;
    paidAt?: DateTimeNullableFilter<'Invoice'> | Date | string | null;
    stripeInvoiceId?: StringNullableFilter<'Invoice'> | string | null;
    stripePaymentIntentId?: StringNullableFilter<'Invoice'> | string | null;
    hostedInvoiceUrl?: StringNullableFilter<'Invoice'> | string | null;
    createdAt?: DateTimeFilter<'Invoice'> | Date | string;
    subscriptionId?: StringFilter<'Invoice'> | string;
  };

  export type BillingEventUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingEventWhereUniqueInput;
    update: XOR<
      BillingEventUpdateWithoutSubscriptionInput,
      BillingEventUncheckedUpdateWithoutSubscriptionInput
    >;
    create: XOR<
      BillingEventCreateWithoutSubscriptionInput,
      BillingEventUncheckedCreateWithoutSubscriptionInput
    >;
  };

  export type BillingEventUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: BillingEventWhereUniqueInput;
    data: XOR<
      BillingEventUpdateWithoutSubscriptionInput,
      BillingEventUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type BillingEventUpdateManyWithWhereWithoutSubscriptionInput = {
    where: BillingEventScalarWhereInput;
    data: XOR<
      BillingEventUpdateManyMutationInput,
      BillingEventUncheckedUpdateManyWithoutSubscriptionInput
    >;
  };

  export type OrganizationUpsertWithoutSubscriptionInput = {
    update: XOR<
      OrganizationUpdateWithoutSubscriptionInput,
      OrganizationUncheckedUpdateWithoutSubscriptionInput
    >;
    create: XOR<
      OrganizationCreateWithoutSubscriptionInput,
      OrganizationUncheckedCreateWithoutSubscriptionInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutSubscriptionInput,
      OrganizationUncheckedUpdateWithoutSubscriptionInput
    >;
  };

  export type OrganizationUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    billingEvents?: BillingEventCreateNestedManyWithoutSubscriptionInput;
    organization: OrganizationCreateNestedOneWithoutSubscriptionInput;
  };

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string;
    plan?: $Enums.SubscriptionPlan;
    status?: $Enums.SubscriptionStatus;
    trialEndsAt?: Date | string | null;
    currentPeriodStart: Date | string;
    currentPeriodEnd: Date | string;
    canceledAt?: Date | string | null;
    stripeCustomerId?: string | null;
    stripeSubscriptionId?: string | null;
    stripePriceId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maxDatabaseConnections?: number;
    maxApiCallsPerMonth?: number;
    maxUsersPerOrg?: number;
    maxWorkflows?: number;
    organizationId: string;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutSubscriptionInput;
  };

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput;
    create: XOR<
      SubscriptionCreateWithoutInvoicesInput,
      SubscriptionUncheckedCreateWithoutInvoicesInput
    >;
  };

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<
      SubscriptionUpdateWithoutInvoicesInput,
      SubscriptionUncheckedUpdateWithoutInvoicesInput
    >;
    create: XOR<
      SubscriptionCreateWithoutInvoicesInput,
      SubscriptionUncheckedCreateWithoutInvoicesInput
    >;
    where?: SubscriptionWhereInput;
  };

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput;
    data: XOR<
      SubscriptionUpdateWithoutInvoicesInput,
      SubscriptionUncheckedUpdateWithoutInvoicesInput
    >;
  };

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    billingEvents?: BillingEventUpdateManyWithoutSubscriptionNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutSubscriptionNestedInput;
  };

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan;
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus;
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maxDatabaseConnections?: IntFieldUpdateOperationsInput | number;
    maxApiCallsPerMonth?: IntFieldUpdateOperationsInput | number;
    maxUsersPerOrg?: IntFieldUpdateOperationsInput | number;
    maxWorkflows?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutSubscriptionNestedInput;
  };

  export type UserCreateWithoutDatabaseConnectionsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutDatabaseConnectionsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutDatabaseConnectionsCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedCreateWithoutDatabaseConnectionsCreatedInput
    >;
  };

  export type OrganizationCreateWithoutDatabaseConnectionsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutDatabaseConnectionsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutDatabaseConnectionsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedCreateWithoutDatabaseConnectionsInput
    >;
  };

  export type EndpointCreateWithoutConnectionInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    usageLogs?: ApiActivityLogCreateNestedManyWithoutEndpointUsageInput;
    creator: UserCreateNestedOneWithoutEndpointsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutConnectionInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    usageLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutEndpointUsageInput;
  };

  export type EndpointCreateOrConnectWithoutConnectionInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<
      EndpointCreateWithoutConnectionInput,
      EndpointUncheckedCreateWithoutConnectionInput
    >;
  };

  export type EndpointCreateManyConnectionInputEnvelope = {
    data: EndpointCreateManyConnectionInput | EndpointCreateManyConnectionInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedEntityCreateWithoutConnectionInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutConnectionInput = {
    id?: string;
    serviceId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutConnectionInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutConnectionInput,
      ExposedEntityUncheckedCreateWithoutConnectionInput
    >;
  };

  export type ExposedEntityCreateManyConnectionInputEnvelope = {
    data: ExposedEntityCreateManyConnectionInput | ExposedEntityCreateManyConnectionInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>;
  };

  export type ServiceCreateManyConnectionInputEnvelope = {
    data: ServiceCreateManyConnectionInput | ServiceCreateManyConnectionInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutDatabaseConnectionsCreatedInput = {
    update: XOR<
      UserUpdateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedUpdateWithoutDatabaseConnectionsCreatedInput
    >;
    create: XOR<
      UserCreateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedCreateWithoutDatabaseConnectionsCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutDatabaseConnectionsCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutDatabaseConnectionsCreatedInput,
      UserUncheckedUpdateWithoutDatabaseConnectionsCreatedInput
    >;
  };

  export type UserUpdateWithoutDatabaseConnectionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutDatabaseConnectionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutDatabaseConnectionsInput = {
    update: XOR<
      OrganizationUpdateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedUpdateWithoutDatabaseConnectionsInput
    >;
    create: XOR<
      OrganizationCreateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedCreateWithoutDatabaseConnectionsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutDatabaseConnectionsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutDatabaseConnectionsInput,
      OrganizationUncheckedUpdateWithoutDatabaseConnectionsInput
    >;
  };

  export type OrganizationUpdateWithoutDatabaseConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutDatabaseConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type EndpointUpsertWithWhereUniqueWithoutConnectionInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<
      EndpointUpdateWithoutConnectionInput,
      EndpointUncheckedUpdateWithoutConnectionInput
    >;
    create: XOR<
      EndpointCreateWithoutConnectionInput,
      EndpointUncheckedCreateWithoutConnectionInput
    >;
  };

  export type EndpointUpdateWithWhereUniqueWithoutConnectionInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<EndpointUpdateWithoutConnectionInput, EndpointUncheckedUpdateWithoutConnectionInput>;
  };

  export type EndpointUpdateManyWithWhereWithoutConnectionInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutConnectionInput>;
  };

  export type ExposedEntityUpsertWithWhereUniqueWithoutConnectionInput = {
    where: ExposedEntityWhereUniqueInput;
    update: XOR<
      ExposedEntityUpdateWithoutConnectionInput,
      ExposedEntityUncheckedUpdateWithoutConnectionInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutConnectionInput,
      ExposedEntityUncheckedCreateWithoutConnectionInput
    >;
  };

  export type ExposedEntityUpdateWithWhereUniqueWithoutConnectionInput = {
    where: ExposedEntityWhereUniqueInput;
    data: XOR<
      ExposedEntityUpdateWithoutConnectionInput,
      ExposedEntityUncheckedUpdateWithoutConnectionInput
    >;
  };

  export type ExposedEntityUpdateManyWithWhereWithoutConnectionInput = {
    where: ExposedEntityScalarWhereInput;
    data: XOR<
      ExposedEntityUpdateManyMutationInput,
      ExposedEntityUncheckedUpdateManyWithoutConnectionInput
    >;
  };

  export type ServiceUpsertWithWhereUniqueWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutConnectionInput, ServiceUncheckedUpdateWithoutConnectionInput>;
    create: XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutConnectionInput, ServiceUncheckedUpdateWithoutConnectionInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutConnectionInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutConnectionInput>;
  };

  export type ApiActivityLogCreateWithoutEndpointUsageInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organization: OrganizationCreateNestedOneWithoutApiActivityLogsInput;
    user?: UserCreateNestedOneWithoutApiActivityLogsInput;
  };

  export type ApiActivityLogUncheckedCreateWithoutEndpointUsageInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    userId?: string | null;
  };

  export type ApiActivityLogCreateOrConnectWithoutEndpointUsageInput = {
    where: ApiActivityLogWhereUniqueInput;
    create: XOR<
      ApiActivityLogCreateWithoutEndpointUsageInput,
      ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
    >;
  };

  export type ApiActivityLogCreateManyEndpointUsageInputEnvelope = {
    data: ApiActivityLogCreateManyEndpointUsageInput | ApiActivityLogCreateManyEndpointUsageInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseConnectionCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutDatabaseConnectionsInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutConnectionInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionCreateOrConnectWithoutEndpointsInput = {
    where: DatabaseConnectionWhereUniqueInput;
    create: XOR<
      DatabaseConnectionCreateWithoutEndpointsInput,
      DatabaseConnectionUncheckedCreateWithoutEndpointsInput
    >;
  };

  export type UserCreateWithoutEndpointsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutEndpointsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutEndpointsCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutEndpointsCreatedInput,
      UserUncheckedCreateWithoutEndpointsCreatedInput
    >;
  };

  export type OrganizationCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutEndpointsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutEndpointsInput,
      OrganizationUncheckedCreateWithoutEndpointsInput
    >;
  };

  export type ApiActivityLogUpsertWithWhereUniqueWithoutEndpointUsageInput = {
    where: ApiActivityLogWhereUniqueInput;
    update: XOR<
      ApiActivityLogUpdateWithoutEndpointUsageInput,
      ApiActivityLogUncheckedUpdateWithoutEndpointUsageInput
    >;
    create: XOR<
      ApiActivityLogCreateWithoutEndpointUsageInput,
      ApiActivityLogUncheckedCreateWithoutEndpointUsageInput
    >;
  };

  export type ApiActivityLogUpdateWithWhereUniqueWithoutEndpointUsageInput = {
    where: ApiActivityLogWhereUniqueInput;
    data: XOR<
      ApiActivityLogUpdateWithoutEndpointUsageInput,
      ApiActivityLogUncheckedUpdateWithoutEndpointUsageInput
    >;
  };

  export type ApiActivityLogUpdateManyWithWhereWithoutEndpointUsageInput = {
    where: ApiActivityLogScalarWhereInput;
    data: XOR<
      ApiActivityLogUpdateManyMutationInput,
      ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageInput
    >;
  };

  export type DatabaseConnectionUpsertWithoutEndpointsInput = {
    update: XOR<
      DatabaseConnectionUpdateWithoutEndpointsInput,
      DatabaseConnectionUncheckedUpdateWithoutEndpointsInput
    >;
    create: XOR<
      DatabaseConnectionCreateWithoutEndpointsInput,
      DatabaseConnectionUncheckedCreateWithoutEndpointsInput
    >;
    where?: DatabaseConnectionWhereInput;
  };

  export type DatabaseConnectionUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: DatabaseConnectionWhereInput;
    data: XOR<
      DatabaseConnectionUpdateWithoutEndpointsInput,
      DatabaseConnectionUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type DatabaseConnectionUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type UserUpsertWithoutEndpointsCreatedInput = {
    update: XOR<
      UserUpdateWithoutEndpointsCreatedInput,
      UserUncheckedUpdateWithoutEndpointsCreatedInput
    >;
    create: XOR<
      UserCreateWithoutEndpointsCreatedInput,
      UserUncheckedCreateWithoutEndpointsCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEndpointsCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutEndpointsCreatedInput,
      UserUncheckedUpdateWithoutEndpointsCreatedInput
    >;
  };

  export type UserUpdateWithoutEndpointsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutEndpointsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutEndpointsInput = {
    update: XOR<
      OrganizationUpdateWithoutEndpointsInput,
      OrganizationUncheckedUpdateWithoutEndpointsInput
    >;
    create: XOR<
      OrganizationCreateWithoutEndpointsInput,
      OrganizationUncheckedCreateWithoutEndpointsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutEndpointsInput,
      OrganizationUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type OrganizationUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserCreateWithoutApiKeysCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutApiKeysCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutApiKeysCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApiKeysCreatedInput,
      UserUncheckedCreateWithoutApiKeysCreatedInput
    >;
  };

  export type OrganizationCreateWithoutApiKeysInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutApiKeysInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutApiKeysInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutApiKeysInput,
      OrganizationUncheckedCreateWithoutApiKeysInput
    >;
  };

  export type UsageMetricCreateWithoutApiKeyInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    organization: OrganizationCreateNestedOneWithoutUsageMetricsInput;
  };

  export type UsageMetricUncheckedCreateWithoutApiKeyInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    organizationId: string;
  };

  export type UsageMetricCreateOrConnectWithoutApiKeyInput = {
    where: UsageMetricWhereUniqueInput;
    create: XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>;
  };

  export type UsageMetricCreateManyApiKeyInputEnvelope = {
    data: UsageMetricCreateManyApiKeyInput | UsageMetricCreateManyApiKeyInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutApiKeysCreatedInput = {
    update: XOR<
      UserUpdateWithoutApiKeysCreatedInput,
      UserUncheckedUpdateWithoutApiKeysCreatedInput
    >;
    create: XOR<
      UserCreateWithoutApiKeysCreatedInput,
      UserUncheckedCreateWithoutApiKeysCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApiKeysCreatedInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutApiKeysCreatedInput, UserUncheckedUpdateWithoutApiKeysCreatedInput>;
  };

  export type UserUpdateWithoutApiKeysCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutApiKeysCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutApiKeysInput = {
    update: XOR<
      OrganizationUpdateWithoutApiKeysInput,
      OrganizationUncheckedUpdateWithoutApiKeysInput
    >;
    create: XOR<
      OrganizationCreateWithoutApiKeysInput,
      OrganizationUncheckedCreateWithoutApiKeysInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutApiKeysInput,
      OrganizationUncheckedUpdateWithoutApiKeysInput
    >;
  };

  export type OrganizationUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UsageMetricUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: UsageMetricWhereUniqueInput;
    update: XOR<UsageMetricUpdateWithoutApiKeyInput, UsageMetricUncheckedUpdateWithoutApiKeyInput>;
    create: XOR<UsageMetricCreateWithoutApiKeyInput, UsageMetricUncheckedCreateWithoutApiKeyInput>;
  };

  export type UsageMetricUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: UsageMetricWhereUniqueInput;
    data: XOR<UsageMetricUpdateWithoutApiKeyInput, UsageMetricUncheckedUpdateWithoutApiKeyInput>;
  };

  export type UsageMetricUpdateManyWithWhereWithoutApiKeyInput = {
    where: UsageMetricScalarWhereInput;
    data: XOR<UsageMetricUpdateManyMutationInput, UsageMetricUncheckedUpdateManyWithoutApiKeyInput>;
  };

  export type ApiKeyCreateWithoutUsageMetricsInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApiKeysCreatedInput;
    organization: OrganizationCreateNestedOneWithoutApiKeysInput;
  };

  export type ApiKeyUncheckedCreateWithoutUsageMetricsInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organizationId: string;
    createdById: string;
  };

  export type ApiKeyCreateOrConnectWithoutUsageMetricsInput = {
    where: ApiKeyWhereUniqueInput;
    create: XOR<
      ApiKeyCreateWithoutUsageMetricsInput,
      ApiKeyUncheckedCreateWithoutUsageMetricsInput
    >;
  };

  export type OrganizationCreateWithoutUsageMetricsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutUsageMetricsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutUsageMetricsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutUsageMetricsInput,
      OrganizationUncheckedCreateWithoutUsageMetricsInput
    >;
  };

  export type ApiKeyUpsertWithoutUsageMetricsInput = {
    update: XOR<
      ApiKeyUpdateWithoutUsageMetricsInput,
      ApiKeyUncheckedUpdateWithoutUsageMetricsInput
    >;
    create: XOR<
      ApiKeyCreateWithoutUsageMetricsInput,
      ApiKeyUncheckedCreateWithoutUsageMetricsInput
    >;
    where?: ApiKeyWhereInput;
  };

  export type ApiKeyUpdateToOneWithWhereWithoutUsageMetricsInput = {
    where?: ApiKeyWhereInput;
    data: XOR<ApiKeyUpdateWithoutUsageMetricsInput, ApiKeyUncheckedUpdateWithoutUsageMetricsInput>;
  };

  export type ApiKeyUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApiKeysCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApiKeysNestedInput;
  };

  export type ApiKeyUncheckedUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdById?: StringFieldUpdateOperationsInput | string;
  };

  export type OrganizationUpsertWithoutUsageMetricsInput = {
    update: XOR<
      OrganizationUpdateWithoutUsageMetricsInput,
      OrganizationUncheckedUpdateWithoutUsageMetricsInput
    >;
    create: XOR<
      OrganizationCreateWithoutUsageMetricsInput,
      OrganizationUncheckedCreateWithoutUsageMetricsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutUsageMetricsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutUsageMetricsInput,
      OrganizationUncheckedUpdateWithoutUsageMetricsInput
    >;
  };

  export type OrganizationUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserCreateWithoutWorkflowsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutWorkflowsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutWorkflowsCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutWorkflowsCreatedInput,
      UserUncheckedCreateWithoutWorkflowsCreatedInput
    >;
  };

  export type OrganizationCreateWithoutWorkflowsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutWorkflowsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutWorkflowsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutWorkflowsInput,
      OrganizationUncheckedCreateWithoutWorkflowsInput
    >;
  };

  export type WorkflowExecutionCreateWithoutWorkflowInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionUncheckedCreateWithoutWorkflowInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput;
    create: XOR<
      WorkflowExecutionCreateWithoutWorkflowInput,
      WorkflowExecutionUncheckedCreateWithoutWorkflowInput
    >;
  };

  export type WorkflowExecutionCreateManyWorkflowInputEnvelope = {
    data: WorkflowExecutionCreateManyWorkflowInput | WorkflowExecutionCreateManyWorkflowInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutWorkflowsCreatedInput = {
    update: XOR<
      UserUpdateWithoutWorkflowsCreatedInput,
      UserUncheckedUpdateWithoutWorkflowsCreatedInput
    >;
    create: XOR<
      UserCreateWithoutWorkflowsCreatedInput,
      UserUncheckedCreateWithoutWorkflowsCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWorkflowsCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutWorkflowsCreatedInput,
      UserUncheckedUpdateWithoutWorkflowsCreatedInput
    >;
  };

  export type UserUpdateWithoutWorkflowsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutWorkflowsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutWorkflowsInput = {
    update: XOR<
      OrganizationUpdateWithoutWorkflowsInput,
      OrganizationUncheckedUpdateWithoutWorkflowsInput
    >;
    create: XOR<
      OrganizationCreateWithoutWorkflowsInput,
      OrganizationUncheckedCreateWithoutWorkflowsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutWorkflowsInput,
      OrganizationUncheckedUpdateWithoutWorkflowsInput
    >;
  };

  export type OrganizationUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type WorkflowExecutionUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput;
    update: XOR<
      WorkflowExecutionUpdateWithoutWorkflowInput,
      WorkflowExecutionUncheckedUpdateWithoutWorkflowInput
    >;
    create: XOR<
      WorkflowExecutionCreateWithoutWorkflowInput,
      WorkflowExecutionUncheckedCreateWithoutWorkflowInput
    >;
  };

  export type WorkflowExecutionUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionWhereUniqueInput;
    data: XOR<
      WorkflowExecutionUpdateWithoutWorkflowInput,
      WorkflowExecutionUncheckedUpdateWithoutWorkflowInput
    >;
  };

  export type WorkflowExecutionUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowExecutionScalarWhereInput;
    data: XOR<
      WorkflowExecutionUpdateManyMutationInput,
      WorkflowExecutionUncheckedUpdateManyWithoutWorkflowInput
    >;
  };

  export type WorkflowExecutionScalarWhereInput = {
    AND?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[];
    OR?: WorkflowExecutionScalarWhereInput[];
    NOT?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[];
    id?: StringFilter<'WorkflowExecution'> | string;
    status?: EnumExecutionStatusFilter<'WorkflowExecution'> | $Enums.ExecutionStatus;
    startedAt?: DateTimeFilter<'WorkflowExecution'> | Date | string;
    completedAt?: DateTimeNullableFilter<'WorkflowExecution'> | Date | string | null;
    error?: StringNullableFilter<'WorkflowExecution'> | string | null;
    logs?: JsonNullableFilter<'WorkflowExecution'>;
    workflowId?: StringFilter<'WorkflowExecution'> | string;
  };

  export type WorkflowCreateWithoutExecutionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator?: UserCreateNestedOneWithoutWorkflowsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput;
  };

  export type WorkflowUncheckedCreateWithoutExecutionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
  };

  export type WorkflowCreateOrConnectWithoutExecutionsInput = {
    where: WorkflowWhereUniqueInput;
    create: XOR<
      WorkflowCreateWithoutExecutionsInput,
      WorkflowUncheckedCreateWithoutExecutionsInput
    >;
  };

  export type WorkflowUpsertWithoutExecutionsInput = {
    update: XOR<
      WorkflowUpdateWithoutExecutionsInput,
      WorkflowUncheckedUpdateWithoutExecutionsInput
    >;
    create: XOR<
      WorkflowCreateWithoutExecutionsInput,
      WorkflowUncheckedCreateWithoutExecutionsInput
    >;
    where?: WorkflowWhereInput;
  };

  export type WorkflowUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WorkflowWhereInput;
    data: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>;
  };

  export type WorkflowUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneWithoutWorkflowsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput;
  };

  export type WorkflowUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrganizationCreateWithoutWebhooksInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutWebhooksInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutWebhooksInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutWebhooksInput,
      OrganizationUncheckedCreateWithoutWebhooksInput
    >;
  };

  export type OrganizationUpsertWithoutWebhooksInput = {
    update: XOR<
      OrganizationUpdateWithoutWebhooksInput,
      OrganizationUncheckedUpdateWithoutWebhooksInput
    >;
    create: XOR<
      OrganizationCreateWithoutWebhooksInput,
      OrganizationUncheckedCreateWithoutWebhooksInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutWebhooksInput,
      OrganizationUncheckedUpdateWithoutWebhooksInput
    >;
  };

  export type OrganizationUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateWithoutAuditLogsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutAuditLogsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutAuditLogsInput,
      OrganizationUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type UserCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
  };

  export type OrganizationUpsertWithoutAuditLogsInput = {
    update: XOR<
      OrganizationUpdateWithoutAuditLogsInput,
      OrganizationUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      OrganizationCreateWithoutAuditLogsInput,
      OrganizationUncheckedCreateWithoutAuditLogsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutAuditLogsInput,
      OrganizationUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type OrganizationUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
  };

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type DatabaseObjectCreateWithoutServiceInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organization: OrganizationCreateNestedOneWithoutDatabaseObjectsInput;
  };

  export type DatabaseObjectUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type DatabaseObjectCreateOrConnectWithoutServiceInput = {
    where: DatabaseObjectWhereUniqueInput;
    create: XOR<
      DatabaseObjectCreateWithoutServiceInput,
      DatabaseObjectUncheckedCreateWithoutServiceInput
    >;
  };

  export type DatabaseObjectCreateManyServiceInputEnvelope = {
    data: DatabaseObjectCreateManyServiceInput | DatabaseObjectCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedEntityCreateWithoutServiceInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutServiceInput = {
    id?: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutServiceInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutServiceInput,
      ExposedEntityUncheckedCreateWithoutServiceInput
    >;
  };

  export type ExposedEntityCreateManyServiceInputEnvelope = {
    data: ExposedEntityCreateManyServiceInput | ExposedEntityCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type RoleCreateWithoutServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutServiceInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>;
  };

  export type RoleCreateManyServiceInputEnvelope = {
    data: RoleCreateManyServiceInput | RoleCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseConnectionCreateWithoutServicesInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutDatabaseConnectionsInput;
    endpoints?: EndpointCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateWithoutServicesInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutConnectionInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionCreateOrConnectWithoutServicesInput = {
    where: DatabaseConnectionWhereUniqueInput;
    create: XOR<
      DatabaseConnectionCreateWithoutServicesInput,
      DatabaseConnectionUncheckedCreateWithoutServicesInput
    >;
  };

  export type UserCreateWithoutServicesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutServicesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutServicesCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutServicesCreatedInput,
      UserUncheckedCreateWithoutServicesCreatedInput
    >;
  };

  export type OrganizationCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutServicesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutServicesInput,
      OrganizationUncheckedCreateWithoutServicesInput
    >;
  };

  export type DatabaseObjectUpsertWithWhereUniqueWithoutServiceInput = {
    where: DatabaseObjectWhereUniqueInput;
    update: XOR<
      DatabaseObjectUpdateWithoutServiceInput,
      DatabaseObjectUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      DatabaseObjectCreateWithoutServiceInput,
      DatabaseObjectUncheckedCreateWithoutServiceInput
    >;
  };

  export type DatabaseObjectUpdateWithWhereUniqueWithoutServiceInput = {
    where: DatabaseObjectWhereUniqueInput;
    data: XOR<
      DatabaseObjectUpdateWithoutServiceInput,
      DatabaseObjectUncheckedUpdateWithoutServiceInput
    >;
  };

  export type DatabaseObjectUpdateManyWithWhereWithoutServiceInput = {
    where: DatabaseObjectScalarWhereInput;
    data: XOR<
      DatabaseObjectUpdateManyMutationInput,
      DatabaseObjectUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ExposedEntityUpsertWithWhereUniqueWithoutServiceInput = {
    where: ExposedEntityWhereUniqueInput;
    update: XOR<
      ExposedEntityUpdateWithoutServiceInput,
      ExposedEntityUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutServiceInput,
      ExposedEntityUncheckedCreateWithoutServiceInput
    >;
  };

  export type ExposedEntityUpdateWithWhereUniqueWithoutServiceInput = {
    where: ExposedEntityWhereUniqueInput;
    data: XOR<
      ExposedEntityUpdateWithoutServiceInput,
      ExposedEntityUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ExposedEntityUpdateManyWithWhereWithoutServiceInput = {
    where: ExposedEntityScalarWhereInput;
    data: XOR<
      ExposedEntityUpdateManyMutationInput,
      ExposedEntityUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type RoleUpsertWithWhereUniqueWithoutServiceInput = {
    where: RoleWhereUniqueInput;
    update: XOR<RoleUpdateWithoutServiceInput, RoleUncheckedUpdateWithoutServiceInput>;
    create: XOR<RoleCreateWithoutServiceInput, RoleUncheckedCreateWithoutServiceInput>;
  };

  export type RoleUpdateWithWhereUniqueWithoutServiceInput = {
    where: RoleWhereUniqueInput;
    data: XOR<RoleUpdateWithoutServiceInput, RoleUncheckedUpdateWithoutServiceInput>;
  };

  export type RoleUpdateManyWithWhereWithoutServiceInput = {
    where: RoleScalarWhereInput;
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutServiceInput>;
  };

  export type DatabaseConnectionUpsertWithoutServicesInput = {
    update: XOR<
      DatabaseConnectionUpdateWithoutServicesInput,
      DatabaseConnectionUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      DatabaseConnectionCreateWithoutServicesInput,
      DatabaseConnectionUncheckedCreateWithoutServicesInput
    >;
    where?: DatabaseConnectionWhereInput;
  };

  export type DatabaseConnectionUpdateToOneWithWhereWithoutServicesInput = {
    where?: DatabaseConnectionWhereInput;
    data: XOR<
      DatabaseConnectionUpdateWithoutServicesInput,
      DatabaseConnectionUncheckedUpdateWithoutServicesInput
    >;
  };

  export type DatabaseConnectionUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput;
    endpoints?: EndpointUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type UserUpsertWithoutServicesCreatedInput = {
    update: XOR<
      UserUpdateWithoutServicesCreatedInput,
      UserUncheckedUpdateWithoutServicesCreatedInput
    >;
    create: XOR<
      UserCreateWithoutServicesCreatedInput,
      UserUncheckedCreateWithoutServicesCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutServicesCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutServicesCreatedInput,
      UserUncheckedUpdateWithoutServicesCreatedInput
    >;
  };

  export type UserUpdateWithoutServicesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutServicesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutServicesInput = {
    update: XOR<
      OrganizationUpdateWithoutServicesInput,
      OrganizationUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      OrganizationCreateWithoutServicesInput,
      OrganizationUncheckedCreateWithoutServicesInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutServicesInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutServicesInput,
      OrganizationUncheckedUpdateWithoutServicesInput
    >;
  };

  export type OrganizationUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserCreateWithoutApplicationsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutApplicationsCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutApplicationsCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApplicationsCreatedInput,
      UserUncheckedCreateWithoutApplicationsCreatedInput
    >;
  };

  export type RoleCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    createdBy: string;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutApplicationsInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutApplicationsInput, RoleUncheckedCreateWithoutApplicationsInput>;
  };

  export type OrganizationCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutApplicationsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutApplicationsInput,
      OrganizationUncheckedCreateWithoutApplicationsInput
    >;
  };

  export type UserUpsertWithoutApplicationsCreatedInput = {
    update: XOR<
      UserUpdateWithoutApplicationsCreatedInput,
      UserUncheckedUpdateWithoutApplicationsCreatedInput
    >;
    create: XOR<
      UserCreateWithoutApplicationsCreatedInput,
      UserUncheckedCreateWithoutApplicationsCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApplicationsCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutApplicationsCreatedInput,
      UserUncheckedUpdateWithoutApplicationsCreatedInput
    >;
  };

  export type UserUpdateWithoutApplicationsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutApplicationsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type RoleUpsertWithoutApplicationsInput = {
    update: XOR<RoleUpdateWithoutApplicationsInput, RoleUncheckedUpdateWithoutApplicationsInput>;
    create: XOR<RoleCreateWithoutApplicationsInput, RoleUncheckedCreateWithoutApplicationsInput>;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: RoleWhereInput;
    data: XOR<RoleUpdateWithoutApplicationsInput, RoleUncheckedUpdateWithoutApplicationsInput>;
  };

  export type RoleUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type OrganizationUpsertWithoutApplicationsInput = {
    update: XOR<
      OrganizationUpdateWithoutApplicationsInput,
      OrganizationUncheckedUpdateWithoutApplicationsInput
    >;
    create: XOR<
      OrganizationCreateWithoutApplicationsInput,
      OrganizationUncheckedCreateWithoutApplicationsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutApplicationsInput,
      OrganizationUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type OrganizationUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type ApplicationCreateWithoutDefaultRoleInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator: UserCreateNestedOneWithoutApplicationsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutApplicationsInput;
  };

  export type ApplicationUncheckedCreateWithoutDefaultRoleInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
  };

  export type ApplicationCreateOrConnectWithoutDefaultRoleInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutDefaultRoleInput,
      ApplicationUncheckedCreateWithoutDefaultRoleInput
    >;
  };

  export type ApplicationCreateManyDefaultRoleInputEnvelope = {
    data: ApplicationCreateManyDefaultRoleInput | ApplicationCreateManyDefaultRoleInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedFieldPolicyCreateWithoutRoleInput = {
    id?: string;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedEntity: ExposedEntityCreateNestedOneWithoutFieldPoliciesInput;
  };

  export type ExposedFieldPolicyUncheckedCreateWithoutRoleInput = {
    id?: string;
    exposedEntityId: string;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedFieldPolicyCreateOrConnectWithoutRoleInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    create: XOR<
      ExposedFieldPolicyCreateWithoutRoleInput,
      ExposedFieldPolicyUncheckedCreateWithoutRoleInput
    >;
  };

  export type ExposedFieldPolicyCreateManyRoleInputEnvelope = {
    data: ExposedFieldPolicyCreateManyRoleInput | ExposedFieldPolicyCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedRowPolicyCreateWithoutRoleInput = {
    id?: string;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedEntity: ExposedEntityCreateNestedOneWithoutRowPoliciesInput;
  };

  export type ExposedRowPolicyUncheckedCreateWithoutRoleInput = {
    id?: string;
    exposedEntityId: string;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyCreateOrConnectWithoutRoleInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    create: XOR<
      ExposedRowPolicyCreateWithoutRoleInput,
      ExposedRowPolicyUncheckedCreateWithoutRoleInput
    >;
  };

  export type ExposedRowPolicyCreateManyRoleInputEnvelope = {
    data: ExposedRowPolicyCreateManyRoleInput | ExposedRowPolicyCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutRolesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutRolesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutRolesCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutRolesCreatedInput, UserUncheckedCreateWithoutRolesCreatedInput>;
  };

  export type OrganizationCreateWithoutRolesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutRolesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutRolesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<OrganizationCreateWithoutRolesInput, OrganizationUncheckedCreateWithoutRolesInput>;
  };

  export type ServiceCreateWithoutRolesInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutRolesInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutRolesInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutRolesInput, ServiceUncheckedCreateWithoutRolesInput>;
  };

  export type ApplicationUpsertWithWhereUniqueWithoutDefaultRoleInput = {
    where: ApplicationWhereUniqueInput;
    update: XOR<
      ApplicationUpdateWithoutDefaultRoleInput,
      ApplicationUncheckedUpdateWithoutDefaultRoleInput
    >;
    create: XOR<
      ApplicationCreateWithoutDefaultRoleInput,
      ApplicationUncheckedCreateWithoutDefaultRoleInput
    >;
  };

  export type ApplicationUpdateWithWhereUniqueWithoutDefaultRoleInput = {
    where: ApplicationWhereUniqueInput;
    data: XOR<
      ApplicationUpdateWithoutDefaultRoleInput,
      ApplicationUncheckedUpdateWithoutDefaultRoleInput
    >;
  };

  export type ApplicationUpdateManyWithWhereWithoutDefaultRoleInput = {
    where: ApplicationScalarWhereInput;
    data: XOR<
      ApplicationUpdateManyMutationInput,
      ApplicationUncheckedUpdateManyWithoutDefaultRoleInput
    >;
  };

  export type ExposedFieldPolicyUpsertWithWhereUniqueWithoutRoleInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    update: XOR<
      ExposedFieldPolicyUpdateWithoutRoleInput,
      ExposedFieldPolicyUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      ExposedFieldPolicyCreateWithoutRoleInput,
      ExposedFieldPolicyUncheckedCreateWithoutRoleInput
    >;
  };

  export type ExposedFieldPolicyUpdateWithWhereUniqueWithoutRoleInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    data: XOR<
      ExposedFieldPolicyUpdateWithoutRoleInput,
      ExposedFieldPolicyUncheckedUpdateWithoutRoleInput
    >;
  };

  export type ExposedFieldPolicyUpdateManyWithWhereWithoutRoleInput = {
    where: ExposedFieldPolicyScalarWhereInput;
    data: XOR<
      ExposedFieldPolicyUpdateManyMutationInput,
      ExposedFieldPolicyUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type ExposedFieldPolicyScalarWhereInput = {
    AND?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
    OR?: ExposedFieldPolicyScalarWhereInput[];
    NOT?: ExposedFieldPolicyScalarWhereInput | ExposedFieldPolicyScalarWhereInput[];
    id?: StringFilter<'ExposedFieldPolicy'> | string;
    exposedEntityId?: StringFilter<'ExposedFieldPolicy'> | string;
    roleId?: StringNullableFilter<'ExposedFieldPolicy'> | string | null;
    includeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    excludeFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    writeProtected?: StringNullableListFilter<'ExposedFieldPolicy'>;
    maskedFields?: StringNullableListFilter<'ExposedFieldPolicy'>;
    createdAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedFieldPolicy'> | Date | string;
  };

  export type ExposedRowPolicyUpsertWithWhereUniqueWithoutRoleInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    update: XOR<
      ExposedRowPolicyUpdateWithoutRoleInput,
      ExposedRowPolicyUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      ExposedRowPolicyCreateWithoutRoleInput,
      ExposedRowPolicyUncheckedCreateWithoutRoleInput
    >;
  };

  export type ExposedRowPolicyUpdateWithWhereUniqueWithoutRoleInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    data: XOR<
      ExposedRowPolicyUpdateWithoutRoleInput,
      ExposedRowPolicyUncheckedUpdateWithoutRoleInput
    >;
  };

  export type ExposedRowPolicyUpdateManyWithWhereWithoutRoleInput = {
    where: ExposedRowPolicyScalarWhereInput;
    data: XOR<
      ExposedRowPolicyUpdateManyMutationInput,
      ExposedRowPolicyUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type ExposedRowPolicyScalarWhereInput = {
    AND?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
    OR?: ExposedRowPolicyScalarWhereInput[];
    NOT?: ExposedRowPolicyScalarWhereInput | ExposedRowPolicyScalarWhereInput[];
    id?: StringFilter<'ExposedRowPolicy'> | string;
    exposedEntityId?: StringFilter<'ExposedRowPolicy'> | string;
    roleId?: StringNullableFilter<'ExposedRowPolicy'> | string | null;
    filterTemplate?: JsonFilter<'ExposedRowPolicy'>;
    createdAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
    updatedAt?: DateTimeFilter<'ExposedRowPolicy'> | Date | string;
  };

  export type UserUpsertWithoutRolesCreatedInput = {
    update: XOR<UserUpdateWithoutRolesCreatedInput, UserUncheckedUpdateWithoutRolesCreatedInput>;
    create: XOR<UserCreateWithoutRolesCreatedInput, UserUncheckedCreateWithoutRolesCreatedInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRolesCreatedInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutRolesCreatedInput, UserUncheckedUpdateWithoutRolesCreatedInput>;
  };

  export type UserUpdateWithoutRolesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutRolesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutRolesInput = {
    update: XOR<OrganizationUpdateWithoutRolesInput, OrganizationUncheckedUpdateWithoutRolesInput>;
    create: XOR<OrganizationCreateWithoutRolesInput, OrganizationUncheckedCreateWithoutRolesInput>;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutRolesInput = {
    where?: OrganizationWhereInput;
    data: XOR<OrganizationUpdateWithoutRolesInput, OrganizationUncheckedUpdateWithoutRolesInput>;
  };

  export type OrganizationUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type ServiceUpsertWithoutRolesInput = {
    update: XOR<ServiceUpdateWithoutRolesInput, ServiceUncheckedUpdateWithoutRolesInput>;
    create: XOR<ServiceCreateWithoutRolesInput, ServiceUncheckedCreateWithoutRolesInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutRolesInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutRolesInput, ServiceUncheckedUpdateWithoutRolesInput>;
  };

  export type ServiceUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type OrganizationCreateWithoutNotificationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutNotificationsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutNotificationsInput,
      OrganizationUncheckedCreateWithoutNotificationsInput
    >;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
  };

  export type OrganizationUpsertWithoutNotificationsInput = {
    update: XOR<
      OrganizationUpdateWithoutNotificationsInput,
      OrganizationUncheckedUpdateWithoutNotificationsInput
    >;
    create: XOR<
      OrganizationCreateWithoutNotificationsInput,
      OrganizationUncheckedCreateWithoutNotificationsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutNotificationsInput,
      OrganizationUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type OrganizationUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EndpointCreateWithoutUsageLogsInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection?: DatabaseConnectionCreateNestedOneWithoutEndpointsInput;
    creator: UserCreateNestedOneWithoutEndpointsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutUsageLogsInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
  };

  export type EndpointCreateOrConnectWithoutUsageLogsInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<EndpointCreateWithoutUsageLogsInput, EndpointUncheckedCreateWithoutUsageLogsInput>;
  };

  export type OrganizationCreateWithoutApiActivityLogsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutApiActivityLogsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutApiActivityLogsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutApiActivityLogsInput,
      OrganizationUncheckedCreateWithoutApiActivityLogsInput
    >;
  };

  export type UserCreateWithoutApiActivityLogsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutApiActivityLogsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutApiActivityLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
  };

  export type EndpointUpsertWithoutUsageLogsInput = {
    update: XOR<EndpointUpdateWithoutUsageLogsInput, EndpointUncheckedUpdateWithoutUsageLogsInput>;
    create: XOR<EndpointCreateWithoutUsageLogsInput, EndpointUncheckedCreateWithoutUsageLogsInput>;
    where?: EndpointWhereInput;
  };

  export type EndpointUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: EndpointWhereInput;
    data: XOR<EndpointUpdateWithoutUsageLogsInput, EndpointUncheckedUpdateWithoutUsageLogsInput>;
  };

  export type EndpointUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneWithoutEndpointsNestedInput;
    creator?: UserUpdateOneRequiredWithoutEndpointsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrganizationUpsertWithoutApiActivityLogsInput = {
    update: XOR<
      OrganizationUpdateWithoutApiActivityLogsInput,
      OrganizationUncheckedUpdateWithoutApiActivityLogsInput
    >;
    create: XOR<
      OrganizationCreateWithoutApiActivityLogsInput,
      OrganizationUncheckedCreateWithoutApiActivityLogsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutApiActivityLogsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutApiActivityLogsInput,
      OrganizationUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type OrganizationUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutApiActivityLogsInput = {
    update: XOR<
      UserUpdateWithoutApiActivityLogsInput,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
    create: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApiActivityLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutApiActivityLogsInput,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type UserUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutDatabaseObjectsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutDatabaseObjectsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutDatabaseObjectsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutDatabaseObjectsInput,
      OrganizationUncheckedCreateWithoutDatabaseObjectsInput
    >;
  };

  export type ServiceCreateWithoutDatabaseObjectsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutDatabaseObjectsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutDatabaseObjectsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutDatabaseObjectsInput,
      ServiceUncheckedCreateWithoutDatabaseObjectsInput
    >;
  };

  export type OrganizationUpsertWithoutDatabaseObjectsInput = {
    update: XOR<
      OrganizationUpdateWithoutDatabaseObjectsInput,
      OrganizationUncheckedUpdateWithoutDatabaseObjectsInput
    >;
    create: XOR<
      OrganizationCreateWithoutDatabaseObjectsInput,
      OrganizationUncheckedCreateWithoutDatabaseObjectsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutDatabaseObjectsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutDatabaseObjectsInput,
      OrganizationUncheckedUpdateWithoutDatabaseObjectsInput
    >;
  };

  export type OrganizationUpdateWithoutDatabaseObjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutDatabaseObjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type ServiceUpsertWithoutDatabaseObjectsInput = {
    update: XOR<
      ServiceUpdateWithoutDatabaseObjectsInput,
      ServiceUncheckedUpdateWithoutDatabaseObjectsInput
    >;
    create: XOR<
      ServiceCreateWithoutDatabaseObjectsInput,
      ServiceUncheckedCreateWithoutDatabaseObjectsInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutDatabaseObjectsInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutDatabaseObjectsInput,
      ServiceUncheckedUpdateWithoutDatabaseObjectsInput
    >;
  };

  export type ServiceUpdateWithoutDatabaseObjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutDatabaseObjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type DatabaseConnectionCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserCreateNestedOneWithoutDatabaseConnectionsCreatedInput;
    organization: OrganizationCreateNestedOneWithoutDatabaseConnectionsInput;
    endpoints?: EndpointCreateNestedManyWithoutConnectionInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionUncheckedCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutConnectionInput;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type DatabaseConnectionCreateOrConnectWithoutExposedEntitiesInput = {
    where: DatabaseConnectionWhereUniqueInput;
    create: XOR<
      DatabaseConnectionCreateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedCreateWithoutExposedEntitiesInput
    >;
  };

  export type UserCreateWithoutExposedEntitiesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutExposedEntitiesCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutExposedEntitiesCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutExposedEntitiesCreatedInput,
      UserUncheckedCreateWithoutExposedEntitiesCreatedInput
    >;
  };

  export type OrganizationCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutExposedEntitiesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutExposedEntitiesInput,
      OrganizationUncheckedCreateWithoutExposedEntitiesInput
    >;
  };

  export type ServiceCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutServiceInput;
    roles?: RoleCreateNestedManyWithoutServiceInput;
    connection?: DatabaseConnectionCreateNestedOneWithoutServicesInput;
    creator: UserCreateNestedOneWithoutServicesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutExposedEntitiesInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
    connectionId?: string | null;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutServiceInput;
    roles?: RoleUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutExposedEntitiesInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutExposedEntitiesInput,
      ServiceUncheckedCreateWithoutExposedEntitiesInput
    >;
  };

  export type ExposedFieldPolicyCreateWithoutExposedEntityInput = {
    id?: string;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: RoleCreateNestedOneWithoutExposedFieldPoliciesInput;
  };

  export type ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput = {
    id?: string;
    roleId?: string | null;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedFieldPolicyCreateOrConnectWithoutExposedEntityInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    create: XOR<
      ExposedFieldPolicyCreateWithoutExposedEntityInput,
      ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
    >;
  };

  export type ExposedFieldPolicyCreateManyExposedEntityInputEnvelope = {
    data:
      | ExposedFieldPolicyCreateManyExposedEntityInput
      | ExposedFieldPolicyCreateManyExposedEntityInput[];
    skipDuplicates?: boolean;
  };

  export type ExposedRowPolicyCreateWithoutExposedEntityInput = {
    id?: string;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    role?: RoleCreateNestedOneWithoutExposedRowPoliciesInput;
  };

  export type ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput = {
    id?: string;
    roleId?: string | null;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyCreateOrConnectWithoutExposedEntityInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    create: XOR<
      ExposedRowPolicyCreateWithoutExposedEntityInput,
      ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
    >;
  };

  export type ExposedRowPolicyCreateManyExposedEntityInputEnvelope = {
    data:
      | ExposedRowPolicyCreateManyExposedEntityInput
      | ExposedRowPolicyCreateManyExposedEntityInput[];
    skipDuplicates?: boolean;
  };

  export type DatabaseConnectionUpsertWithoutExposedEntitiesInput = {
    update: XOR<
      DatabaseConnectionUpdateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedUpdateWithoutExposedEntitiesInput
    >;
    create: XOR<
      DatabaseConnectionCreateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedCreateWithoutExposedEntitiesInput
    >;
    where?: DatabaseConnectionWhereInput;
  };

  export type DatabaseConnectionUpdateToOneWithWhereWithoutExposedEntitiesInput = {
    where?: DatabaseConnectionWhereInput;
    data: XOR<
      DatabaseConnectionUpdateWithoutExposedEntitiesInput,
      DatabaseConnectionUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type DatabaseConnectionUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput;
    endpoints?: EndpointUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type UserUpsertWithoutExposedEntitiesCreatedInput = {
    update: XOR<
      UserUpdateWithoutExposedEntitiesCreatedInput,
      UserUncheckedUpdateWithoutExposedEntitiesCreatedInput
    >;
    create: XOR<
      UserCreateWithoutExposedEntitiesCreatedInput,
      UserUncheckedCreateWithoutExposedEntitiesCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutExposedEntitiesCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutExposedEntitiesCreatedInput,
      UserUncheckedUpdateWithoutExposedEntitiesCreatedInput
    >;
  };

  export type UserUpdateWithoutExposedEntitiesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutExposedEntitiesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationUpsertWithoutExposedEntitiesInput = {
    update: XOR<
      OrganizationUpdateWithoutExposedEntitiesInput,
      OrganizationUncheckedUpdateWithoutExposedEntitiesInput
    >;
    create: XOR<
      OrganizationCreateWithoutExposedEntitiesInput,
      OrganizationUncheckedCreateWithoutExposedEntitiesInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutExposedEntitiesInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutExposedEntitiesInput,
      OrganizationUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type OrganizationUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type ServiceUpsertWithoutExposedEntitiesInput = {
    update: XOR<
      ServiceUpdateWithoutExposedEntitiesInput,
      ServiceUncheckedUpdateWithoutExposedEntitiesInput
    >;
    create: XOR<
      ServiceCreateWithoutExposedEntitiesInput,
      ServiceUncheckedCreateWithoutExposedEntitiesInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutExposedEntitiesInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutExposedEntitiesInput,
      ServiceUncheckedUpdateWithoutExposedEntitiesInput
    >;
  };

  export type ServiceUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutExposedEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ExposedFieldPolicyUpsertWithWhereUniqueWithoutExposedEntityInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    update: XOR<
      ExposedFieldPolicyUpdateWithoutExposedEntityInput,
      ExposedFieldPolicyUncheckedUpdateWithoutExposedEntityInput
    >;
    create: XOR<
      ExposedFieldPolicyCreateWithoutExposedEntityInput,
      ExposedFieldPolicyUncheckedCreateWithoutExposedEntityInput
    >;
  };

  export type ExposedFieldPolicyUpdateWithWhereUniqueWithoutExposedEntityInput = {
    where: ExposedFieldPolicyWhereUniqueInput;
    data: XOR<
      ExposedFieldPolicyUpdateWithoutExposedEntityInput,
      ExposedFieldPolicyUncheckedUpdateWithoutExposedEntityInput
    >;
  };

  export type ExposedFieldPolicyUpdateManyWithWhereWithoutExposedEntityInput = {
    where: ExposedFieldPolicyScalarWhereInput;
    data: XOR<
      ExposedFieldPolicyUpdateManyMutationInput,
      ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityInput
    >;
  };

  export type ExposedRowPolicyUpsertWithWhereUniqueWithoutExposedEntityInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    update: XOR<
      ExposedRowPolicyUpdateWithoutExposedEntityInput,
      ExposedRowPolicyUncheckedUpdateWithoutExposedEntityInput
    >;
    create: XOR<
      ExposedRowPolicyCreateWithoutExposedEntityInput,
      ExposedRowPolicyUncheckedCreateWithoutExposedEntityInput
    >;
  };

  export type ExposedRowPolicyUpdateWithWhereUniqueWithoutExposedEntityInput = {
    where: ExposedRowPolicyWhereUniqueInput;
    data: XOR<
      ExposedRowPolicyUpdateWithoutExposedEntityInput,
      ExposedRowPolicyUncheckedUpdateWithoutExposedEntityInput
    >;
  };

  export type ExposedRowPolicyUpdateManyWithWhereWithoutExposedEntityInput = {
    where: ExposedRowPolicyScalarWhereInput;
    data: XOR<
      ExposedRowPolicyUpdateManyMutationInput,
      ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityInput
    >;
  };

  export type ExposedEntityCreateWithoutFieldPoliciesInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    rowPolicies?: ExposedRowPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutFieldPoliciesInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    rowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutFieldPoliciesInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedCreateWithoutFieldPoliciesInput
    >;
  };

  export type RoleCreateWithoutExposedFieldPoliciesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedRowPolicies?: ExposedRowPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutExposedFieldPoliciesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    createdBy: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutExposedFieldPoliciesInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutExposedFieldPoliciesInput,
      RoleUncheckedCreateWithoutExposedFieldPoliciesInput
    >;
  };

  export type ExposedEntityUpsertWithoutFieldPoliciesInput = {
    update: XOR<
      ExposedEntityUpdateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedUpdateWithoutFieldPoliciesInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedCreateWithoutFieldPoliciesInput
    >;
    where?: ExposedEntityWhereInput;
  };

  export type ExposedEntityUpdateToOneWithWhereWithoutFieldPoliciesInput = {
    where?: ExposedEntityWhereInput;
    data: XOR<
      ExposedEntityUpdateWithoutFieldPoliciesInput,
      ExposedEntityUncheckedUpdateWithoutFieldPoliciesInput
    >;
  };

  export type ExposedEntityUpdateWithoutFieldPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutFieldPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type RoleUpsertWithoutExposedFieldPoliciesInput = {
    update: XOR<
      RoleUpdateWithoutExposedFieldPoliciesInput,
      RoleUncheckedUpdateWithoutExposedFieldPoliciesInput
    >;
    create: XOR<
      RoleCreateWithoutExposedFieldPoliciesInput,
      RoleUncheckedCreateWithoutExposedFieldPoliciesInput
    >;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutExposedFieldPoliciesInput = {
    where?: RoleWhereInput;
    data: XOR<
      RoleUpdateWithoutExposedFieldPoliciesInput,
      RoleUncheckedUpdateWithoutExposedFieldPoliciesInput
    >;
  };

  export type RoleUpdateWithoutExposedFieldPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutExposedFieldPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type ExposedEntityCreateWithoutRowPoliciesInput = {
    id?: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    connection: DatabaseConnectionCreateNestedOneWithoutExposedEntitiesInput;
    creator?: UserCreateNestedOneWithoutExposedEntitiesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutExposedEntitiesInput;
    service: ServiceCreateNestedOneWithoutExposedEntitiesInput;
    fieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityUncheckedCreateWithoutRowPoliciesInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutExposedEntityInput;
  };

  export type ExposedEntityCreateOrConnectWithoutRowPoliciesInput = {
    where: ExposedEntityWhereUniqueInput;
    create: XOR<
      ExposedEntityCreateWithoutRowPoliciesInput,
      ExposedEntityUncheckedCreateWithoutRowPoliciesInput
    >;
  };

  export type RoleCreateWithoutExposedRowPoliciesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyCreateNestedManyWithoutRoleInput;
    creator: UserCreateNestedOneWithoutRolesCreatedInput;
    organization: OrganizationCreateNestedOneWithoutRolesInput;
    service: ServiceCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutExposedRowPoliciesInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
    createdBy: string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutDefaultRoleInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutExposedRowPoliciesInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutExposedRowPoliciesInput,
      RoleUncheckedCreateWithoutExposedRowPoliciesInput
    >;
  };

  export type ExposedEntityUpsertWithoutRowPoliciesInput = {
    update: XOR<
      ExposedEntityUpdateWithoutRowPoliciesInput,
      ExposedEntityUncheckedUpdateWithoutRowPoliciesInput
    >;
    create: XOR<
      ExposedEntityCreateWithoutRowPoliciesInput,
      ExposedEntityUncheckedCreateWithoutRowPoliciesInput
    >;
    where?: ExposedEntityWhereInput;
  };

  export type ExposedEntityUpdateToOneWithWhereWithoutRowPoliciesInput = {
    where?: ExposedEntityWhereInput;
    data: XOR<
      ExposedEntityUpdateWithoutRowPoliciesInput,
      ExposedEntityUncheckedUpdateWithoutRowPoliciesInput
    >;
  };

  export type ExposedEntityUpdateWithoutRowPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutRowPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type RoleUpsertWithoutExposedRowPoliciesInput = {
    update: XOR<
      RoleUpdateWithoutExposedRowPoliciesInput,
      RoleUncheckedUpdateWithoutExposedRowPoliciesInput
    >;
    create: XOR<
      RoleCreateWithoutExposedRowPoliciesInput,
      RoleUncheckedCreateWithoutExposedRowPoliciesInput
    >;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutExposedRowPoliciesInput = {
    where?: RoleWhereInput;
    data: XOR<
      RoleUpdateWithoutExposedRowPoliciesInput,
      RoleUncheckedUpdateWithoutExposedRowPoliciesInput
    >;
  };

  export type RoleUpdateWithoutExposedRowPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutExposedRowPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type TermsAcceptanceCreateWithoutTermsInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organization: OrganizationCreateNestedOneWithoutTermsAcceptancesInput;
    user: UserCreateNestedOneWithoutTermsAcceptancesInput;
  };

  export type TermsAcceptanceUncheckedCreateWithoutTermsInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    userId: string;
  };

  export type TermsAcceptanceCreateOrConnectWithoutTermsInput = {
    where: TermsAcceptanceWhereUniqueInput;
    create: XOR<
      TermsAcceptanceCreateWithoutTermsInput,
      TermsAcceptanceUncheckedCreateWithoutTermsInput
    >;
  };

  export type TermsAcceptanceCreateManyTermsInputEnvelope = {
    data: TermsAcceptanceCreateManyTermsInput | TermsAcceptanceCreateManyTermsInput[];
    skipDuplicates?: boolean;
  };

  export type TermsAcceptanceUpsertWithWhereUniqueWithoutTermsInput = {
    where: TermsAcceptanceWhereUniqueInput;
    update: XOR<
      TermsAcceptanceUpdateWithoutTermsInput,
      TermsAcceptanceUncheckedUpdateWithoutTermsInput
    >;
    create: XOR<
      TermsAcceptanceCreateWithoutTermsInput,
      TermsAcceptanceUncheckedCreateWithoutTermsInput
    >;
  };

  export type TermsAcceptanceUpdateWithWhereUniqueWithoutTermsInput = {
    where: TermsAcceptanceWhereUniqueInput;
    data: XOR<
      TermsAcceptanceUpdateWithoutTermsInput,
      TermsAcceptanceUncheckedUpdateWithoutTermsInput
    >;
  };

  export type TermsAcceptanceUpdateManyWithWhereWithoutTermsInput = {
    where: TermsAcceptanceScalarWhereInput;
    data: XOR<
      TermsAcceptanceUpdateManyMutationInput,
      TermsAcceptanceUncheckedUpdateManyWithoutTermsInput
    >;
  };

  export type OrganizationCreateWithoutTermsAcceptancesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutTermsAcceptancesInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutTermsAcceptancesInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutTermsAcceptancesInput,
      OrganizationUncheckedCreateWithoutTermsAcceptancesInput
    >;
  };

  export type TermsAndConditionsCreateWithoutAcceptancesInput = {
    id?: string;
    version: string;
    content: string;
    summary?: string | null;
    effectiveDate: Date | string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TermsAndConditionsUncheckedCreateWithoutAcceptancesInput = {
    id?: string;
    version: string;
    content: string;
    summary?: string | null;
    effectiveDate: Date | string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TermsAndConditionsCreateOrConnectWithoutAcceptancesInput = {
    where: TermsAndConditionsWhereUniqueInput;
    create: XOR<
      TermsAndConditionsCreateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedCreateWithoutAcceptancesInput
    >;
  };

  export type UserCreateWithoutTermsAcceptancesInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTermsAcceptancesInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTermsAcceptancesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTermsAcceptancesInput,
      UserUncheckedCreateWithoutTermsAcceptancesInput
    >;
  };

  export type OrganizationUpsertWithoutTermsAcceptancesInput = {
    update: XOR<
      OrganizationUpdateWithoutTermsAcceptancesInput,
      OrganizationUncheckedUpdateWithoutTermsAcceptancesInput
    >;
    create: XOR<
      OrganizationCreateWithoutTermsAcceptancesInput,
      OrganizationUncheckedCreateWithoutTermsAcceptancesInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutTermsAcceptancesInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutTermsAcceptancesInput,
      OrganizationUncheckedUpdateWithoutTermsAcceptancesInput
    >;
  };

  export type OrganizationUpdateWithoutTermsAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutTermsAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type TermsAndConditionsUpsertWithoutAcceptancesInput = {
    update: XOR<
      TermsAndConditionsUpdateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedUpdateWithoutAcceptancesInput
    >;
    create: XOR<
      TermsAndConditionsCreateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedCreateWithoutAcceptancesInput
    >;
    where?: TermsAndConditionsWhereInput;
  };

  export type TermsAndConditionsUpdateToOneWithWhereWithoutAcceptancesInput = {
    where?: TermsAndConditionsWhereInput;
    data: XOR<
      TermsAndConditionsUpdateWithoutAcceptancesInput,
      TermsAndConditionsUncheckedUpdateWithoutAcceptancesInput
    >;
  };

  export type TermsAndConditionsUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TermsAndConditionsUncheckedUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    version?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    summary?: NullableStringFieldUpdateOperationsInput | string | null;
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutTermsAcceptancesInput = {
    update: XOR<
      UserUpdateWithoutTermsAcceptancesInput,
      UserUncheckedUpdateWithoutTermsAcceptancesInput
    >;
    create: XOR<
      UserCreateWithoutTermsAcceptancesInput,
      UserUncheckedCreateWithoutTermsAcceptancesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTermsAcceptancesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTermsAcceptancesInput,
      UserUncheckedUpdateWithoutTermsAcceptancesInput
    >;
  };

  export type UserUpdateWithoutTermsAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTermsAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutRateLimitConfigsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutRateLimitConfigsInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitUsage?: RateLimitUsageUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutRateLimitConfigsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutRateLimitConfigsInput,
      OrganizationUncheckedCreateWithoutRateLimitConfigsInput
    >;
  };

  export type UserCreateWithoutRateLimitCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutRateLimitCreatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutRateLimitCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRateLimitCreatedInput,
      UserUncheckedCreateWithoutRateLimitCreatedInput
    >;
  };

  export type UserCreateWithoutRateLimitUpdatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutRateLimitUpdatedInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutRateLimitUpdatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRateLimitUpdatedInput,
      UserUncheckedCreateWithoutRateLimitUpdatedInput
    >;
  };

  export type OrganizationUpsertWithoutRateLimitConfigsInput = {
    update: XOR<
      OrganizationUpdateWithoutRateLimitConfigsInput,
      OrganizationUncheckedUpdateWithoutRateLimitConfigsInput
    >;
    create: XOR<
      OrganizationCreateWithoutRateLimitConfigsInput,
      OrganizationUncheckedCreateWithoutRateLimitConfigsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutRateLimitConfigsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutRateLimitConfigsInput,
      OrganizationUncheckedUpdateWithoutRateLimitConfigsInput
    >;
  };

  export type OrganizationUpdateWithoutRateLimitConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutRateLimitConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitUsage?: RateLimitUsageUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserUpsertWithoutRateLimitCreatedInput = {
    update: XOR<
      UserUpdateWithoutRateLimitCreatedInput,
      UserUncheckedUpdateWithoutRateLimitCreatedInput
    >;
    create: XOR<
      UserCreateWithoutRateLimitCreatedInput,
      UserUncheckedCreateWithoutRateLimitCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRateLimitCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRateLimitCreatedInput,
      UserUncheckedUpdateWithoutRateLimitCreatedInput
    >;
  };

  export type UserUpdateWithoutRateLimitCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutRateLimitCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUpsertWithoutRateLimitUpdatedInput = {
    update: XOR<
      UserUpdateWithoutRateLimitUpdatedInput,
      UserUncheckedUpdateWithoutRateLimitUpdatedInput
    >;
    create: XOR<
      UserCreateWithoutRateLimitUpdatedInput,
      UserUncheckedCreateWithoutRateLimitUpdatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRateLimitUpdatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRateLimitUpdatedInput,
      UserUncheckedUpdateWithoutRateLimitUpdatedInput
    >;
  };

  export type UserUpdateWithoutRateLimitUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutRateLimitUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutRateLimitUsageInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationCreateNestedManyWithoutOrganizationInput;
    roles?: RoleCreateNestedManyWithoutOrganizationInput;
    services?: ServiceCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateWithoutRateLimitUsageInput = {
    id?: string;
    name: string;
    slug: string;
    domain?: string | null;
    logo?: string | null;
    website?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastTermsPromptedAt?: Date | string | null;
    requiresTermsAcceptance?: boolean;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutOrganizationInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutOrganizationInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutOrganizationInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseConnections?: DatabaseConnectionUncheckedCreateNestedManyWithoutOrganizationInput;
    databaseObjects?: DatabaseObjectUncheckedCreateNestedManyWithoutOrganizationInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutOrganizationInput;
    exposedEntities?: ExposedEntityUncheckedCreateNestedManyWithoutOrganizationInput;
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutOrganizationInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput;
    roles?: RoleUncheckedCreateNestedManyWithoutOrganizationInput;
    services?: ServiceUncheckedCreateNestedManyWithoutOrganizationInput;
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOrganizationInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutOrganizationInput;
    usageMetrics?: UsageMetricUncheckedCreateNestedManyWithoutOrganizationInput;
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOrganizationInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutOrganizationInput;
    rateLimitConfigs?: RateLimitConfigUncheckedCreateNestedManyWithoutOrganizationInput;
    billingEvents?: BillingEventUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationCreateOrConnectWithoutRateLimitUsageInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutRateLimitUsageInput,
      OrganizationUncheckedCreateWithoutRateLimitUsageInput
    >;
  };

  export type OrganizationUpsertWithoutRateLimitUsageInput = {
    update: XOR<
      OrganizationUpdateWithoutRateLimitUsageInput,
      OrganizationUncheckedUpdateWithoutRateLimitUsageInput
    >;
    create: XOR<
      OrganizationCreateWithoutRateLimitUsageInput,
      OrganizationUncheckedCreateWithoutRateLimitUsageInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutRateLimitUsageInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutRateLimitUsageInput,
      OrganizationUncheckedUpdateWithoutRateLimitUsageInput
    >;
  };

  export type OrganizationUpdateWithoutRateLimitUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutRateLimitUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    domain?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastTermsPromptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    requiresTermsAcceptance?: BoolFieldUpdateOperationsInput | boolean;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutOrganizationNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutOrganizationNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseConnections?: DatabaseConnectionUncheckedUpdateManyWithoutOrganizationNestedInput;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutOrganizationNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutOrganizationNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutOrganizationNestedInput;
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutOrganizationNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutOrganizationNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutOrganizationNestedInput;
    subscription?: SubscriptionUncheckedUpdateOneWithoutOrganizationNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutOrganizationNestedInput;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutOrganizationNestedInput;
    webhooks?: WebhookUncheckedUpdateManyWithoutOrganizationNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutOrganizationNestedInput;
    rateLimitConfigs?: RateLimitConfigUncheckedUpdateManyWithoutOrganizationNestedInput;
    billingEvents?: BillingEventUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type UserCreateWithoutSocialAccountsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigCreateNestedManyWithoutUpdaterInput;
  };

  export type UserUncheckedCreateWithoutSocialAccountsInput = {
    id?: string;
    email: string;
    passwordHash?: string | null;
    firstName: string;
    lastName: string;
    avatarUrl?: string | null;
    isActive?: boolean;
    emailVerified?: boolean;
    emailVerifiedAt?: Date | string | null;
    lastLoginAt?: Date | string | null;
    twoFactorEnabled?: boolean;
    twoFactorSecret?: string | null;
    phoneNumber?: string | null;
    phoneCarrier?: string | null;
    isSuperAdmin?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiKeysCreated?: ApiKeyUncheckedCreateNestedManyWithoutCreatedByInput;
    applicationsCreated?: ApplicationUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedCreateNestedManyWithoutCreatorInput;
    endpointsCreated?: EndpointUncheckedCreateNestedManyWithoutCreatorInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedCreateNestedManyWithoutCreatorInput;
    invitationsSent?: InvitationUncheckedCreateNestedManyWithoutInvitedByInput;
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    rolesCreated?: RoleUncheckedCreateNestedManyWithoutCreatorInput;
    servicesCreated?: ServiceUncheckedCreateNestedManyWithoutCreatorInput;
    termsAcceptances?: TermsAcceptanceUncheckedCreateNestedManyWithoutUserInput;
    workflowsCreated?: WorkflowUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitCreated?: RateLimitConfigUncheckedCreateNestedManyWithoutCreatorInput;
    rateLimitUpdated?: RateLimitConfigUncheckedCreateNestedManyWithoutUpdaterInput;
  };

  export type UserCreateOrConnectWithoutSocialAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSocialAccountsInput,
      UserUncheckedCreateWithoutSocialAccountsInput
    >;
  };

  export type UserUpsertWithoutSocialAccountsInput = {
    update: XOR<
      UserUpdateWithoutSocialAccountsInput,
      UserUncheckedUpdateWithoutSocialAccountsInput
    >;
    create: XOR<
      UserCreateWithoutSocialAccountsInput,
      UserUncheckedCreateWithoutSocialAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSocialAccountsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSocialAccountsInput, UserUncheckedUpdateWithoutSocialAccountsInput>;
  };

  export type UserUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUpdateManyWithoutUpdaterNestedInput;
  };

  export type UserUncheckedUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiKeysCreated?: ApiKeyUncheckedUpdateManyWithoutCreatedByNestedInput;
    applicationsCreated?: ApplicationUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    databaseConnectionsCreated?: DatabaseConnectionUncheckedUpdateManyWithoutCreatorNestedInput;
    endpointsCreated?: EndpointUncheckedUpdateManyWithoutCreatorNestedInput;
    exposedEntitiesCreated?: ExposedEntityUncheckedUpdateManyWithoutCreatorNestedInput;
    invitationsSent?: InvitationUncheckedUpdateManyWithoutInvitedByNestedInput;
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    rolesCreated?: RoleUncheckedUpdateManyWithoutCreatorNestedInput;
    servicesCreated?: ServiceUncheckedUpdateManyWithoutCreatorNestedInput;
    termsAcceptances?: TermsAcceptanceUncheckedUpdateManyWithoutUserNestedInput;
    workflowsCreated?: WorkflowUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitCreated?: RateLimitConfigUncheckedUpdateManyWithoutCreatorNestedInput;
    rateLimitUpdated?: RateLimitConfigUncheckedUpdateManyWithoutUpdaterNestedInput;
  };

  export type ApiActivityLogCreateManyOrganizationInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    userId?: string | null;
    endpointId?: string | null;
  };

  export type ApiKeyCreateManyOrganizationInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    createdById: string;
  };

  export type ApplicationCreateManyOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    defaultRoleId: string;
  };

  export type AuditLogCreateManyOrganizationInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    userId?: string | null;
  };

  export type DatabaseConnectionCreateManyOrganizationInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type DatabaseObjectCreateManyOrganizationInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serviceId?: string | null;
  };

  export type EndpointCreateManyOrganizationInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    connectionId?: string | null;
  };

  export type ExposedEntityCreateManyOrganizationInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type InvitationCreateManyOrganizationInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    invitedById: string;
  };

  export type MembershipCreateManyOrganizationInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    userId: string;
  };

  export type NotificationCreateManyOrganizationInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    userId: string;
  };

  export type RoleCreateManyOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serviceId: string;
    createdBy: string;
  };

  export type ServiceCreateManyOrganizationInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: string;
    connectionId?: string | null;
  };

  export type TermsAcceptanceCreateManyOrganizationInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    userId: string;
    termsId: string;
  };

  export type UsageMetricCreateManyOrganizationInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    apiKeyId?: string | null;
  };

  export type WebhookCreateManyOrganizationInput = {
    id?: string;
    url: string;
    events?: WebhookCreateeventsInput | string[];
    secret: string;
    isActive?: boolean;
    lastTriggeredAt?: Date | string | null;
    failureCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowCreateManyOrganizationInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type RateLimitConfigCreateManyOrganizationInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    createdBy: string;
    updatedBy?: string | null;
  };

  export type RateLimitUsageCreateManyOrganizationInput = {
    id?: string;
    configName: string;
    limitKey: string;
    currentCount?: number;
    resetAt: Date | string;
    blocked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BillingEventCreateManyOrganizationInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    subscriptionId?: string | null;
  };

  export type ApiActivityLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointUpdateOneWithoutUsageLogsNestedInput;
    user?: UserUpdateOneWithoutApiActivityLogsNestedInput;
  };

  export type ApiActivityLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiKeyUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApiKeysCreatedNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneRequiredWithoutApplicationsCreatedNestedInput;
    defaultRole?: RoleUpdateOneRequiredWithoutApplicationsNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type AuditLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AuditLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DatabaseConnectionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneWithoutDatabaseConnectionsCreatedNestedInput;
    endpoints?: EndpointUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type DatabaseObjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneWithoutDatabaseObjectsNestedInput;
  };

  export type DatabaseObjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DatabaseObjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EndpointUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageLogs?: ApiActivityLogUpdateManyWithoutEndpointUsageNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutEndpointsNestedInput;
    creator?: UserUpdateOneRequiredWithoutEndpointsCreatedNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    usageLogs?: ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageNestedInput;
  };

  export type EndpointUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExposedEntityUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    invitedBy?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput;
  };

  export type InvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    invitedById?: StringFieldUpdateOperationsInput | string;
  };

  export type InvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    invitedById?: StringFieldUpdateOperationsInput | string;
  };

  export type MembershipUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type MembershipUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type MembershipUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type RoleUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ServiceUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TermsAcceptanceUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    terms?: TermsAndConditionsUpdateOneRequiredWithoutAcceptancesNestedInput;
    user?: UserUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
  };

  export type TermsAcceptanceUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    userId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    userId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type UsageMetricUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKey?: ApiKeyUpdateOneWithoutUsageMetricsNestedInput;
  };

  export type UsageMetricUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UsageMetricUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WebhookUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebhookUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebhookUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    events?: WebhookUpdateeventsInput | string[];
    secret?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failureCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneWithoutWorkflowsCreatedNestedInput;
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    creator?: UserUpdateOneRequiredWithoutRateLimitCreatedNestedInput;
    updater?: UserUpdateOneWithoutRateLimitUpdatedNestedInput;
  };

  export type RateLimitConfigUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitUsageUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitUsageUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitUsageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    configName?: StringFieldUpdateOperationsInput | string;
    limitKey?: StringFieldUpdateOperationsInput | string;
    currentCount?: IntFieldUpdateOperationsInput | number;
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    blocked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BillingEventUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscription?: SubscriptionUpdateOneWithoutBillingEventsNestedInput;
  };

  export type BillingEventUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BillingEventUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiActivityLogCreateManyUserInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    endpointId?: string | null;
  };

  export type ApiKeyCreateManyCreatedByInput = {
    id?: string;
    name: string;
    keyHash: string;
    keyPrefix: string;
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    isActive?: boolean;
    permissions?: ApiKeyCreatepermissionsInput | string[];
    createdAt?: Date | string;
    organizationId: string;
  };

  export type ApplicationCreateManyCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    defaultRoleId: string;
  };

  export type AuditLogCreateManyUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    organizationId: string;
  };

  export type DatabaseConnectionCreateManyCreatorInput = {
    id?: string;
    name: string;
    type: $Enums.DatabaseType;
    host: string;
    port: number;
    database: string;
    username: string;
    passwordEncrypted: string;
    sslEnabled?: boolean;
    isActive?: boolean;
    lastTestedAt?: Date | string | null;
    lastTestResult?: boolean | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type EndpointCreateManyCreatorInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    connectionId?: string | null;
  };

  export type ExposedEntityCreateManyCreatorInput = {
    id?: string;
    serviceId: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InvitationCreateManyInvitedByInput = {
    id?: string;
    email: string;
    role?: $Enums.MemberRole;
    token: string;
    expiresAt: Date | string;
    acceptedAt?: Date | string | null;
    createdAt?: Date | string;
    organizationId: string;
  };

  export type MembershipCreateManyUserInput = {
    id?: string;
    role?: $Enums.MemberRole;
    joinedAt?: Date | string;
    organizationId: string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    isRead?: boolean;
    readAt?: Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId: string;
  };

  export type RoleCreateManyCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    serviceId: string;
  };

  export type ServiceCreateManyCreatorInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    connectionId?: string | null;
  };

  export type TermsAcceptanceCreateManyUserInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    termsId: string;
  };

  export type WorkflowCreateManyCreatorInput = {
    id?: string;
    name: string;
    description?: string | null;
    definition: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    trigger: JsonNullValueInput | InputJsonValue;
    lastRunAt?: Date | string | null;
    runCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type RateLimitConfigCreateManyCreatorInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    updatedBy?: string | null;
  };

  export type RateLimitConfigCreateManyUpdaterInput = {
    id?: string;
    name: string;
    displayName: string;
    type: $Enums.RateLimitType;
    max: number;
    windowMs: number;
    keyStrategy?: $Enums.RateLimitKeyStrategy;
    enabled?: boolean;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: string | null;
    organizationId: string;
    createdBy: string;
  };

  export type SocialAccountCreateManyUserInput = {
    id?: string;
    provider: string;
    providerId: string;
    email?: string | null;
    name?: string | null;
    profileUrl?: string | null;
    avatarUrl?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    profileData?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    endpointUsage?: EndpointUpdateOneWithoutUsageLogsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApiActivityLogsNestedInput;
  };

  export type ApiActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiKeyUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutApiKeysNestedInput;
    usageMetrics?: UsageMetricUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    usageMetrics?: UsageMetricUncheckedUpdateManyWithoutApiKeyNestedInput;
  };

  export type ApiKeyUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    keyHash?: StringFieldUpdateOperationsInput | string;
    keyPrefix?: StringFieldUpdateOperationsInput | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: ApiKeyUpdatepermissionsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    defaultRole?: RoleUpdateOneRequiredWithoutApplicationsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApplicationsNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    defaultRoleId?: StringFieldUpdateOperationsInput | string;
  };

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type DatabaseConnectionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseConnectionsNestedInput;
    endpoints?: EndpointUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
    endpoints?: EndpointUncheckedUpdateManyWithoutConnectionNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutConnectionNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type DatabaseConnectionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumDatabaseTypeFieldUpdateOperationsInput | $Enums.DatabaseType;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    database?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordEncrypted?: StringFieldUpdateOperationsInput | string;
    sslEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastTestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastTestResult?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    databases?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type EndpointUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageLogs?: ApiActivityLogUpdateManyWithoutEndpointUsageNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutEndpointsNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    usageLogs?: ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageNestedInput;
  };

  export type EndpointUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExposedEntityUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvitationUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput;
  };

  export type InvitationUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type InvitationUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type MembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type RoleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
  };

  export type ServiceUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    connection?: DatabaseConnectionUpdateOneWithoutServicesNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TermsAcceptanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organization?: OrganizationUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
    terms?: TermsAndConditionsUpdateOneRequiredWithoutAcceptancesNestedInput;
  };

  export type TermsAcceptanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    termsId?: StringFieldUpdateOperationsInput | string;
  };

  export type WorkflowUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput;
    executions?: WorkflowExecutionUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    executions?: WorkflowExecutionUncheckedUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    trigger?: JsonNullValueInput | InputJsonValue;
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    runCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type RateLimitConfigUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: OrganizationUpdateOneRequiredWithoutRateLimitConfigsNestedInput;
    updater?: UserUpdateOneWithoutRateLimitUpdatedNestedInput;
  };

  export type RateLimitConfigUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RateLimitConfigUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: OrganizationUpdateOneRequiredWithoutRateLimitConfigsNestedInput;
    creator?: UserUpdateOneRequiredWithoutRateLimitCreatedNestedInput;
  };

  export type RateLimitConfigUncheckedUpdateWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type RateLimitConfigUncheckedUpdateManyWithoutUpdaterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    displayName?: StringFieldUpdateOperationsInput | string;
    type?: EnumRateLimitTypeFieldUpdateOperationsInput | $Enums.RateLimitType;
    max?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    keyStrategy?: EnumRateLimitKeyStrategyFieldUpdateOperationsInput | $Enums.RateLimitKeyStrategy;
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applicationLimits?: NullableJsonNullValueInput | InputJsonValue;
    roleLimits?: NullableJsonNullValueInput | InputJsonValue;
    componentLimits?: NullableJsonNullValueInput | InputJsonValue;
    changeHistory?: NullableJsonNullValueInput | InputJsonValue;
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type SocialAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SocialAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SocialAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    profileData?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvoiceCreateManySubscriptionInput = {
    id?: string;
    invoiceNumber: string;
    amount: number;
    currency?: string;
    status?: $Enums.InvoiceStatus;
    dueDate: Date | string;
    paidAt?: Date | string | null;
    stripeInvoiceId?: string | null;
    stripePaymentIntentId?: string | null;
    hostedInvoiceUrl?: string | null;
    createdAt?: Date | string;
  };

  export type BillingEventCreateManySubscriptionInput = {
    id?: string;
    eventType: string;
    stripeEventId: string;
    metadata: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    organizationId?: string | null;
  };

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoiceNumber?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null;
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null;
    hostedInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BillingEventUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneWithoutBillingEventsNestedInput;
  };

  export type BillingEventUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BillingEventUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    stripeEventId?: StringFieldUpdateOperationsInput | string;
    metadata?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EndpointCreateManyConnectionInput = {
    id?: string;
    path: string;
    method: $Enums.HttpMethod;
    name: string;
    description?: string | null;
    query: string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey: string;
    isActive?: boolean;
    rateLimitPerMinute?: number;
    requiresAuth?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
  };

  export type ExposedEntityCreateManyConnectionInput = {
    id?: string;
    serviceId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type ServiceCreateManyConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    passwordEncrypted?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
  };

  export type EndpointUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageLogs?: ApiActivityLogUpdateManyWithoutEndpointUsageNestedInput;
    creator?: UserUpdateOneRequiredWithoutEndpointsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    usageLogs?: ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageNestedInput;
  };

  export type EndpointUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    query?: StringFieldUpdateOperationsInput | string;
    queryParams?: NullableJsonNullValueInput | InputJsonValue;
    bodySchema?: NullableJsonNullValueInput | InputJsonValue;
    responseSchema?: NullableJsonNullValueInput | InputJsonValue;
    apiKey?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    rateLimitPerMinute?: IntFieldUpdateOperationsInput | number;
    requiresAuth?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ExposedEntityUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ServiceUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    databaseObjects?: DatabaseObjectUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUpdateManyWithoutServiceNestedInput;
    roles?: RoleUpdateManyWithoutServiceNestedInput;
    creator?: UserUpdateOneRequiredWithoutServicesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    databaseObjects?: DatabaseObjectUncheckedUpdateManyWithoutServiceNestedInput;
    exposedEntities?: ExposedEntityUncheckedUpdateManyWithoutServiceNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordEncrypted?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ApiActivityLogCreateManyEndpointUsageInput = {
    id?: string;
    requestId: string;
    timestamp?: Date | string;
    method: $Enums.HttpMethod;
    url: string;
    endpoint?: string | null;
    statusCode: number;
    responseTime?: number | null;
    userAgent?: string | null;
    ipAddress?: string | null;
    category?: string | null;
    endpointType?: string | null;
    importance?: string | null;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    userId?: string | null;
  };

  export type ApiActivityLogUpdateWithoutEndpointUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organization?: OrganizationUpdateOneRequiredWithoutApiActivityLogsNestedInput;
    user?: UserUpdateOneWithoutApiActivityLogsNestedInput;
  };

  export type ApiActivityLogUncheckedUpdateWithoutEndpointUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutEndpointUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    requestId?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    method?: EnumHttpMethodFieldUpdateOperationsInput | $Enums.HttpMethod;
    url?: StringFieldUpdateOperationsInput | string;
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: NullableStringFieldUpdateOperationsInput | string | null;
    endpointType?: NullableStringFieldUpdateOperationsInput | string | null;
    importance?: NullableStringFieldUpdateOperationsInput | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UsageMetricCreateManyApiKeyInput = {
    id?: string;
    endpoint: string;
    method: string;
    statusCode: number;
    responseTimeMs: number;
    timestamp?: Date | string;
    organizationId: string;
  };

  export type UsageMetricUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutUsageMetricsNestedInput;
  };

  export type UsageMetricUncheckedUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type UsageMetricUncheckedUpdateManyWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTimeMs?: IntFieldUpdateOperationsInput | number;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type WorkflowExecutionCreateManyWorkflowInput = {
    id?: string;
    status: $Enums.ExecutionStatus;
    startedAt?: Date | string;
    completedAt?: Date | string | null;
    error?: string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type WorkflowExecutionUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: EnumExecutionStatusFieldUpdateOperationsInput | $Enums.ExecutionStatus;
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    logs?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type DatabaseObjectCreateManyServiceInput = {
    id?: string;
    name: string;
    schema?: string | null;
    type: string;
    path?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
  };

  export type ExposedEntityCreateManyServiceInput = {
    id?: string;
    connectionId: string;
    organizationId: string;
    database: string;
    schema?: string | null;
    name: string;
    type: $Enums.ExposedEntityType;
    primaryKey?: string | null;
    allowRead?: boolean;
    allowCreate?: boolean;
    allowUpdate?: boolean;
    allowDelete?: boolean;
    defaultSort?: string | null;
    softDeleteEnabled?: boolean;
    softDeleteColumn?: string | null;
    softDeleteValue?: string | null;
    pathSlug?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type RoleCreateManyServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    permissions: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
  };

  export type DatabaseObjectUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organization?: OrganizationUpdateOneRequiredWithoutDatabaseObjectsNestedInput;
  };

  export type DatabaseObjectUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type DatabaseObjectUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: StringFieldUpdateOperationsInput | string;
    path?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExposedEntityUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    connection?: DatabaseConnectionUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    creator?: UserUpdateOneWithoutExposedEntitiesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutExposedEntitiesNestedInput;
    fieldPolicies?: ExposedFieldPolicyUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    fieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
    rowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityNestedInput;
  };

  export type ExposedEntityUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    connectionId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    database?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumExposedEntityTypeFieldUpdateOperationsInput | $Enums.ExposedEntityType;
    primaryKey?: NullableStringFieldUpdateOperationsInput | string | null;
    allowRead?: BoolFieldUpdateOperationsInput | boolean;
    allowCreate?: BoolFieldUpdateOperationsInput | boolean;
    allowUpdate?: BoolFieldUpdateOperationsInput | boolean;
    allowDelete?: BoolFieldUpdateOperationsInput | boolean;
    defaultSort?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteEnabled?: BoolFieldUpdateOperationsInput | boolean;
    softDeleteColumn?: NullableStringFieldUpdateOperationsInput | string | null;
    softDeleteValue?: NullableStringFieldUpdateOperationsInput | string | null;
    pathSlug?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RoleUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUpdateManyWithoutRoleNestedInput;
    creator?: UserUpdateOneRequiredWithoutRolesCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    applications?: ApplicationUncheckedUpdateManyWithoutDefaultRoleNestedInput;
    exposedFieldPolicies?: ExposedFieldPolicyUncheckedUpdateManyWithoutRoleNestedInput;
    exposedRowPolicies?: ExposedRowPolicyUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    permissions?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationCreateManyDefaultRoleInput = {
    id?: string;
    name: string;
    description?: string | null;
    apiKeyHash: string;
    apiKeyEncrypted: string;
    apiKeyPrefix: string;
    apiKeyHint: string;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    organizationId: string;
    createdBy: string;
  };

  export type ExposedFieldPolicyCreateManyRoleInput = {
    id?: string;
    exposedEntityId: string;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyCreateManyRoleInput = {
    id?: string;
    exposedEntityId: string;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApplicationUpdateWithoutDefaultRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneRequiredWithoutApplicationsCreatedNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutApplicationsNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutDefaultRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ApplicationUncheckedUpdateManyWithoutDefaultRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    apiKeyHash?: StringFieldUpdateOperationsInput | string;
    apiKeyEncrypted?: StringFieldUpdateOperationsInput | string;
    apiKeyPrefix?: StringFieldUpdateOperationsInput | string;
    apiKeyHint?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
  };

  export type ExposedFieldPolicyUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedEntity?: ExposedEntityUpdateOneRequiredWithoutFieldPoliciesNestedInput;
  };

  export type ExposedFieldPolicyUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedFieldPolicyUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exposedEntity?: ExposedEntityUpdateOneRequiredWithoutRowPoliciesNestedInput;
  };

  export type ExposedRowPolicyUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    exposedEntityId?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedFieldPolicyCreateManyExposedEntityInput = {
    id?: string;
    roleId?: string | null;
    includeFields?: ExposedFieldPolicyCreateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyCreateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyCreatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyCreatemaskedFieldsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedRowPolicyCreateManyExposedEntityInput = {
    id?: string;
    roleId?: string | null;
    filterTemplate: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExposedFieldPolicyUpdateWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: RoleUpdateOneWithoutExposedFieldPoliciesNestedInput;
  };

  export type ExposedFieldPolicyUncheckedUpdateWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedFieldPolicyUncheckedUpdateManyWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    includeFields?: ExposedFieldPolicyUpdateincludeFieldsInput | string[];
    excludeFields?: ExposedFieldPolicyUpdateexcludeFieldsInput | string[];
    writeProtected?: ExposedFieldPolicyUpdatewriteProtectedInput | string[];
    maskedFields?: ExposedFieldPolicyUpdatemaskedFieldsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyUpdateWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: RoleUpdateOneWithoutExposedRowPoliciesNestedInput;
  };

  export type ExposedRowPolicyUncheckedUpdateWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExposedRowPolicyUncheckedUpdateManyWithoutExposedEntityInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: NullableStringFieldUpdateOperationsInput | string | null;
    filterTemplate?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TermsAcceptanceCreateManyTermsInput = {
    id?: string;
    acceptedAt?: Date | string;
    ipAddress: string;
    userAgent?: string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: $Enums.AcceptanceMethod;
    organizationId: string;
    userId: string;
  };

  export type TermsAcceptanceUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organization?: OrganizationUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
    user?: UserUpdateOneRequiredWithoutTermsAcceptancesNestedInput;
  };

  export type TermsAcceptanceUncheckedUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type TermsAcceptanceUncheckedUpdateManyWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    geolocation?: NullableJsonNullValueInput | InputJsonValue;
    acceptanceMethod?: EnumAcceptanceMethodFieldUpdateOperationsInput | $Enums.AcceptanceMethod;
    organizationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
