/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Organization
 *
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Connection
 *
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>;
/**
 * Model Service
 *
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>;
/**
 * Model Application
 *
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>;
/**
 * Model Workflow
 *
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>;
/**
 * Model WorkflowRun
 *
 */
export type WorkflowRun = $Result.DefaultSelection<Prisma.$WorkflowRunPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model Endpoint
 *
 */
export type Endpoint = $Result.DefaultSelection<Prisma.$EndpointPayload>;
/**
 * Model ApiActivityLog
 *
 */
export type ApiActivityLog = $Result.DefaultSelection<Prisma.$ApiActivityLogPayload>;
/**
 * Model ApiUsage
 *
 */
export type ApiUsage = $Result.DefaultSelection<Prisma.$ApiUsagePayload>;
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model UserLog
 *
 */
export type UserLog = $Result.DefaultSelection<Prisma.$UserLogPayload>;
/**
 * Model DatabaseObject
 *
 */
export type DatabaseObject = $Result.DefaultSelection<Prisma.$DatabaseObjectPayload>;
/**
 * Model SchemaIntelligence
 *
 */
export type SchemaIntelligence = $Result.DefaultSelection<Prisma.$SchemaIntelligencePayload>;
/**
 * Model GeneratedArtifact
 *
 */
export type GeneratedArtifact = $Result.DefaultSelection<Prisma.$GeneratedArtifactPayload>;
/**
 * Model RateLimitConfig
 *
 */
export type RateLimitConfig = $Result.DefaultSelection<Prisma.$RateLimitConfigPayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Connections
   * const connections = await prisma.connection.findMany()
   * ```
   */
  get connection(): Prisma.ConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Applications
   * const applications = await prisma.application.findMany()
   * ```
   */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Workflows
   * const workflows = await prisma.workflow.findMany()
   * ```
   */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowRun`: Exposes CRUD operations for the **WorkflowRun** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WorkflowRuns
   * const workflowRuns = await prisma.workflowRun.findMany()
   * ```
   */
  get workflowRun(): Prisma.WorkflowRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endpoint`: Exposes CRUD operations for the **Endpoint** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Endpoints
   * const endpoints = await prisma.endpoint.findMany()
   * ```
   */
  get endpoint(): Prisma.EndpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiActivityLog`: Exposes CRUD operations for the **ApiActivityLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApiActivityLogs
   * const apiActivityLogs = await prisma.apiActivityLog.findMany()
   * ```
   */
  get apiActivityLog(): Prisma.ApiActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiUsage`: Exposes CRUD operations for the **ApiUsage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApiUsages
   * const apiUsages = await prisma.apiUsage.findMany()
   * ```
   */
  get apiUsage(): Prisma.ApiUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLog`: Exposes CRUD operations for the **UserLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserLogs
   * const userLogs = await prisma.userLog.findMany()
   * ```
   */
  get userLog(): Prisma.UserLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseObject`: Exposes CRUD operations for the **DatabaseObject** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DatabaseObjects
   * const databaseObjects = await prisma.databaseObject.findMany()
   * ```
   */
  get databaseObject(): Prisma.DatabaseObjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schemaIntelligence`: Exposes CRUD operations for the **SchemaIntelligence** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SchemaIntelligences
   * const schemaIntelligences = await prisma.schemaIntelligence.findMany()
   * ```
   */
  get schemaIntelligence(): Prisma.SchemaIntelligenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedArtifact`: Exposes CRUD operations for the **GeneratedArtifact** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more GeneratedArtifacts
   * const generatedArtifacts = await prisma.generatedArtifact.findMany()
   * ```
   */
  get generatedArtifact(): Prisma.GeneratedArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rateLimitConfig`: Exposes CRUD operations for the **RateLimitConfig** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RateLimitConfigs
   * const rateLimitConfigs = await prisma.rateLimitConfig.findMany()
   * ```
   */
  get rateLimitConfig(): Prisma.RateLimitConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Organization: 'Organization';
    User: 'User';
    Connection: 'Connection';
    Service: 'Service';
    Application: 'Application';
    Workflow: 'Workflow';
    WorkflowRun: 'WorkflowRun';
    Role: 'Role';
    Endpoint: 'Endpoint';
    ApiActivityLog: 'ApiActivityLog';
    ApiUsage: 'ApiUsage';
    Notification: 'Notification';
    UserLog: 'UserLog';
    DatabaseObject: 'DatabaseObject';
    SchemaIntelligence: 'SchemaIntelligence';
    GeneratedArtifact: 'GeneratedArtifact';
    RateLimitConfig: 'RateLimitConfig';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'organization'
        | 'user'
        | 'connection'
        | 'service'
        | 'application'
        | 'workflow'
        | 'workflowRun'
        | 'role'
        | 'endpoint'
        | 'apiActivityLog'
        | 'apiUsage'
        | 'notification'
        | 'userLog'
        | 'databaseObject'
        | 'schemaIntelligence'
        | 'generatedArtifact'
        | 'rateLimitConfig';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>;
        fields: Prisma.OrganizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrganization>;
          };
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>;
        fields: Prisma.ConnectionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[];
          };
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ConnectionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[];
          };
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ConnectionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[];
          };
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>;
          };
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateConnection>;
          };
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ConnectionGroupByOutputType>[];
          };
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>;
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number;
          };
        };
      };
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>;
        fields: Prisma.ServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateService>;
          };
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number;
          };
        };
      };
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>;
        fields: Prisma.ApplicationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApplicationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[];
          };
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>;
          };
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApplication>;
          };
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApplicationGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>;
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number;
          };
        };
      };
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>;
        fields: Prisma.WorkflowFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[];
          };
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>;
          };
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWorkflow>;
          };
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowGroupByOutputType>[];
          };
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number;
          };
        };
      };
      WorkflowRun: {
        payload: Prisma.$WorkflowRunPayload<ExtArgs>;
        fields: Prisma.WorkflowRunFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WorkflowRunFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WorkflowRunFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          findFirst: {
            args: Prisma.WorkflowRunFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WorkflowRunFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          findMany: {
            args: Prisma.WorkflowRunFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>[];
          };
          create: {
            args: Prisma.WorkflowRunCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          createMany: {
            args: Prisma.WorkflowRunCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WorkflowRunCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>[];
          };
          delete: {
            args: Prisma.WorkflowRunDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          update: {
            args: Prisma.WorkflowRunUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          deleteMany: {
            args: Prisma.WorkflowRunDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WorkflowRunUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WorkflowRunUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>[];
          };
          upsert: {
            args: Prisma.WorkflowRunUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WorkflowRunPayload>;
          };
          aggregate: {
            args: Prisma.WorkflowRunAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWorkflowRun>;
          };
          groupBy: {
            args: Prisma.WorkflowRunGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowRunGroupByOutputType>[];
          };
          count: {
            args: Prisma.WorkflowRunCountArgs<ExtArgs>;
            result: $Utils.Optional<WorkflowRunCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      Endpoint: {
        payload: Prisma.$EndpointPayload<ExtArgs>;
        fields: Prisma.EndpointFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EndpointFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EndpointFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          findFirst: {
            args: Prisma.EndpointFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EndpointFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          findMany: {
            args: Prisma.EndpointFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          create: {
            args: Prisma.EndpointCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          createMany: {
            args: Prisma.EndpointCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EndpointCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          delete: {
            args: Prisma.EndpointDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          update: {
            args: Prisma.EndpointUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          deleteMany: {
            args: Prisma.EndpointDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EndpointUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.EndpointUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>[];
          };
          upsert: {
            args: Prisma.EndpointUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EndpointPayload>;
          };
          aggregate: {
            args: Prisma.EndpointAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEndpoint>;
          };
          groupBy: {
            args: Prisma.EndpointGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EndpointGroupByOutputType>[];
          };
          count: {
            args: Prisma.EndpointCountArgs<ExtArgs>;
            result: $Utils.Optional<EndpointCountAggregateOutputType> | number;
          };
        };
      };
      ApiActivityLog: {
        payload: Prisma.$ApiActivityLogPayload<ExtArgs>;
        fields: Prisma.ApiActivityLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApiActivityLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApiActivityLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          findFirst: {
            args: Prisma.ApiActivityLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApiActivityLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          findMany: {
            args: Prisma.ApiActivityLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          create: {
            args: Prisma.ApiActivityLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          createMany: {
            args: Prisma.ApiActivityLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApiActivityLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          delete: {
            args: Prisma.ApiActivityLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          update: {
            args: Prisma.ApiActivityLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          deleteMany: {
            args: Prisma.ApiActivityLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApiActivityLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApiActivityLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>[];
          };
          upsert: {
            args: Prisma.ApiActivityLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiActivityLogPayload>;
          };
          aggregate: {
            args: Prisma.ApiActivityLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApiActivityLog>;
          };
          groupBy: {
            args: Prisma.ApiActivityLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApiActivityLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApiActivityLogCountArgs<ExtArgs>;
            result: $Utils.Optional<ApiActivityLogCountAggregateOutputType> | number;
          };
        };
      };
      ApiUsage: {
        payload: Prisma.$ApiUsagePayload<ExtArgs>;
        fields: Prisma.ApiUsageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApiUsageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApiUsageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          findFirst: {
            args: Prisma.ApiUsageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApiUsageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          findMany: {
            args: Prisma.ApiUsageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>[];
          };
          create: {
            args: Prisma.ApiUsageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          createMany: {
            args: Prisma.ApiUsageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApiUsageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>[];
          };
          delete: {
            args: Prisma.ApiUsageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          update: {
            args: Prisma.ApiUsageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          deleteMany: {
            args: Prisma.ApiUsageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApiUsageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ApiUsageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>[];
          };
          upsert: {
            args: Prisma.ApiUsageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiUsagePayload>;
          };
          aggregate: {
            args: Prisma.ApiUsageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApiUsage>;
          };
          groupBy: {
            args: Prisma.ApiUsageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApiUsageGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApiUsageCountArgs<ExtArgs>;
            result: $Utils.Optional<ApiUsageCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number;
          };
        };
      };
      UserLog: {
        payload: Prisma.$UserLogPayload<ExtArgs>;
        fields: Prisma.UserLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          findFirst: {
            args: Prisma.UserLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          findMany: {
            args: Prisma.UserLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>[];
          };
          create: {
            args: Prisma.UserLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          createMany: {
            args: Prisma.UserLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>[];
          };
          delete: {
            args: Prisma.UserLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          update: {
            args: Prisma.UserLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          deleteMany: {
            args: Prisma.UserLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>[];
          };
          upsert: {
            args: Prisma.UserLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserLogPayload>;
          };
          aggregate: {
            args: Prisma.UserLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserLog>;
          };
          groupBy: {
            args: Prisma.UserLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserLogCountArgs<ExtArgs>;
            result: $Utils.Optional<UserLogCountAggregateOutputType> | number;
          };
        };
      };
      DatabaseObject: {
        payload: Prisma.$DatabaseObjectPayload<ExtArgs>;
        fields: Prisma.DatabaseObjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DatabaseObjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DatabaseObjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          findFirst: {
            args: Prisma.DatabaseObjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DatabaseObjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          findMany: {
            args: Prisma.DatabaseObjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          create: {
            args: Prisma.DatabaseObjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          createMany: {
            args: Prisma.DatabaseObjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DatabaseObjectCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          delete: {
            args: Prisma.DatabaseObjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          update: {
            args: Prisma.DatabaseObjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          deleteMany: {
            args: Prisma.DatabaseObjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DatabaseObjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DatabaseObjectUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>[];
          };
          upsert: {
            args: Prisma.DatabaseObjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DatabaseObjectPayload>;
          };
          aggregate: {
            args: Prisma.DatabaseObjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDatabaseObject>;
          };
          groupBy: {
            args: Prisma.DatabaseObjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseObjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.DatabaseObjectCountArgs<ExtArgs>;
            result: $Utils.Optional<DatabaseObjectCountAggregateOutputType> | number;
          };
        };
      };
      SchemaIntelligence: {
        payload: Prisma.$SchemaIntelligencePayload<ExtArgs>;
        fields: Prisma.SchemaIntelligenceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SchemaIntelligenceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SchemaIntelligenceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          findFirst: {
            args: Prisma.SchemaIntelligenceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SchemaIntelligenceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          findMany: {
            args: Prisma.SchemaIntelligenceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>[];
          };
          create: {
            args: Prisma.SchemaIntelligenceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          createMany: {
            args: Prisma.SchemaIntelligenceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SchemaIntelligenceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>[];
          };
          delete: {
            args: Prisma.SchemaIntelligenceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          update: {
            args: Prisma.SchemaIntelligenceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          deleteMany: {
            args: Prisma.SchemaIntelligenceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SchemaIntelligenceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SchemaIntelligenceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>[];
          };
          upsert: {
            args: Prisma.SchemaIntelligenceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SchemaIntelligencePayload>;
          };
          aggregate: {
            args: Prisma.SchemaIntelligenceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSchemaIntelligence>;
          };
          groupBy: {
            args: Prisma.SchemaIntelligenceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SchemaIntelligenceGroupByOutputType>[];
          };
          count: {
            args: Prisma.SchemaIntelligenceCountArgs<ExtArgs>;
            result: $Utils.Optional<SchemaIntelligenceCountAggregateOutputType> | number;
          };
        };
      };
      GeneratedArtifact: {
        payload: Prisma.$GeneratedArtifactPayload<ExtArgs>;
        fields: Prisma.GeneratedArtifactFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GeneratedArtifactFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GeneratedArtifactFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          findFirst: {
            args: Prisma.GeneratedArtifactFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GeneratedArtifactFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          findMany: {
            args: Prisma.GeneratedArtifactFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>[];
          };
          create: {
            args: Prisma.GeneratedArtifactCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          createMany: {
            args: Prisma.GeneratedArtifactCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GeneratedArtifactCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>[];
          };
          delete: {
            args: Prisma.GeneratedArtifactDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          update: {
            args: Prisma.GeneratedArtifactUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          deleteMany: {
            args: Prisma.GeneratedArtifactDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GeneratedArtifactUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GeneratedArtifactUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>[];
          };
          upsert: {
            args: Prisma.GeneratedArtifactUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneratedArtifactPayload>;
          };
          aggregate: {
            args: Prisma.GeneratedArtifactAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGeneratedArtifact>;
          };
          groupBy: {
            args: Prisma.GeneratedArtifactGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GeneratedArtifactGroupByOutputType>[];
          };
          count: {
            args: Prisma.GeneratedArtifactCountArgs<ExtArgs>;
            result: $Utils.Optional<GeneratedArtifactCountAggregateOutputType> | number;
          };
        };
      };
      RateLimitConfig: {
        payload: Prisma.$RateLimitConfigPayload<ExtArgs>;
        fields: Prisma.RateLimitConfigFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RateLimitConfigFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RateLimitConfigFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          findFirst: {
            args: Prisma.RateLimitConfigFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RateLimitConfigFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          findMany: {
            args: Prisma.RateLimitConfigFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          create: {
            args: Prisma.RateLimitConfigCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          createMany: {
            args: Prisma.RateLimitConfigCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RateLimitConfigCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          delete: {
            args: Prisma.RateLimitConfigDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          update: {
            args: Prisma.RateLimitConfigUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          deleteMany: {
            args: Prisma.RateLimitConfigDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RateLimitConfigUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RateLimitConfigUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>[];
          };
          upsert: {
            args: Prisma.RateLimitConfigUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RateLimitConfigPayload>;
          };
          aggregate: {
            args: Prisma.RateLimitConfigAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRateLimitConfig>;
          };
          groupBy: {
            args: Prisma.RateLimitConfigGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitConfigGroupByOutputType>[];
          };
          count: {
            args: Prisma.RateLimitConfigCountArgs<ExtArgs>;
            result: $Utils.Optional<RateLimitConfigCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit;
    user?: UserOmit;
    connection?: ConnectionOmit;
    service?: ServiceOmit;
    application?: ApplicationOmit;
    workflow?: WorkflowOmit;
    workflowRun?: WorkflowRunOmit;
    role?: RoleOmit;
    endpoint?: EndpointOmit;
    apiActivityLog?: ApiActivityLogOmit;
    apiUsage?: ApiUsageOmit;
    notification?: NotificationOmit;
    userLog?: UserLogOmit;
    databaseObject?: DatabaseObjectOmit;
    schemaIntelligence?: SchemaIntelligenceOmit;
    generatedArtifact?: GeneratedArtifactOmit;
    rateLimitConfig?: RateLimitConfigOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T['emit'] extends 'event'
      ? T['level']
      : never
    : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number;
  };

  export type OrganizationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs;
  };

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apiActivityLogs: number;
    apiUsage: number;
    applications: number;
    connections: number;
    endpoints: number;
    notifications: number;
    roles: number;
    services: number;
    userLogs: number;
    workflowRuns: number;
    workflows: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    apiActivityLogs?: boolean | UserCountOutputTypeCountApiActivityLogsArgs;
    apiUsage?: boolean | UserCountOutputTypeCountApiUsageArgs;
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs;
    connections?: boolean | UserCountOutputTypeCountConnectionsArgs;
    endpoints?: boolean | UserCountOutputTypeCountEndpointsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    roles?: boolean | UserCountOutputTypeCountRolesArgs;
    services?: boolean | UserCountOutputTypeCountServicesArgs;
    userLogs?: boolean | UserCountOutputTypeCountUserLogsArgs;
    workflowRuns?: boolean | UserCountOutputTypeCountWorkflowRunsArgs;
    workflows?: boolean | UserCountOutputTypeCountWorkflowsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiUsageWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ConnectionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEndpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowRunWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowWhereInput;
  };

  /**
   * Count Type ConnectionCountOutputType
   */

  export type ConnectionCountOutputType = {
    services: number;
  };

  export type ConnectionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | ConnectionCountOutputTypeCountServicesArgs;
  };

  // Custom InputTypes
  /**
   * ConnectionCountOutputType without action
   */
  export type ConnectionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ConnectionCountOutputType
     */
    select?: ConnectionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ConnectionCountOutputType without action
   */
  export type ConnectionCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    applications: number;
    endpoints: number;
  };

  export type ServiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    applications?: boolean | ServiceCountOutputTypeCountApplicationsArgs;
    endpoints?: boolean | ServiceCountOutputTypeCountEndpointsArgs;
  };

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountApplicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEndpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    endpoints: number;
  };

  export type ApplicationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    endpoints?: boolean | ApplicationCountOutputTypeCountEndpointsArgs;
  };

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountEndpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
  };

  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    workflowRuns: number;
  };

  export type WorkflowCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    workflowRuns?: boolean | WorkflowCountOutputTypeCountWorkflowRunsArgs;
  };

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountWorkflowRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowRunWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  export type OrganizationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrganizationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrganizationCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    isActive: number;
    settings: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type OrganizationMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrganizationMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrganizationCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    isActive?: true;
    settings?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type OrganizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Organizations
     **/
    _count?: true | OrganizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrganizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrganizationMaxAggregateInputType;
  };

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
    [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>;
  };

  export type OrganizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrganizationWhereInput;
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[];
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum;
    having?: OrganizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrganizationCountAggregateInputType | true;
    _min?: OrganizationMinAggregateInputType;
    _max?: OrganizationMaxAggregateInputType;
  };

  export type OrganizationGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    isActive: boolean;
    settings: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof OrganizationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
          : GetScalarType<T[P], OrganizationGroupByOutputType[P]>;
      }
    >
  >;

  export type OrganizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      isActive?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      users?: boolean | Organization$usersArgs<ExtArgs>;
      _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      isActive?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      isActive?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['organization']
  >;

  export type OrganizationSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    isActive?: boolean;
    settings?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'id' | 'name' | 'slug' | 'isActive' | 'settings' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['organization']
    >;
  export type OrganizationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | Organization$usersArgs<ExtArgs>;
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrganizationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type OrganizationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $OrganizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Organization';
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        isActive: boolean;
        settings: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['organization']
    >;
    composites: {};
  };

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> =
    $Result.GetResult<Prisma.$OrganizationPayload, S>;

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true;
    };

  export interface OrganizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Organization'];
      meta: { name: 'Organization' };
    };
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     *
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     *
     */
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     *
     */
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      $Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
     **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrganizationAggregateArgs>(
      args: Subset<T, OrganizationAggregateArgs>
    ): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>;

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetOrganizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Organization model
     */
    readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    users<T extends Organization$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$usersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<'Organization', 'String'>;
    readonly name: FieldRef<'Organization', 'String'>;
    readonly slug: FieldRef<'Organization', 'String'>;
    readonly isActive: FieldRef<'Organization', 'Boolean'>;
    readonly settings: FieldRef<'Organization', 'Json'>;
    readonly createdAt: FieldRef<'Organization', 'DateTime'>;
    readonly updatedAt: FieldRef<'Organization', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
  };

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput;
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
  };

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number;
  };

  /**
   * Organization.users
   */
  export type Organization$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserAvgAggregateOutputType = {
    loginAttempts: number | null;
  };

  export type UserSumAggregateOutputType = {
    loginAttempts: number | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    password: string | null;
    firstName: string | null;
    lastName: string | null;
    phone: string | null;
    phoneCarrier: string | null;
    organizationId: string | null;
    role: string | null;
    accountSetupToken: string | null;
    accountSetupTokenExpires: Date | null;
    twoFactorSecret: string | null;
    twoFactorEnabledAt: Date | null;
    isActive: boolean | null;
    isEmailVerified: boolean | null;
    lastLoginAt: Date | null;
    loginAttempts: number | null;
    lockedUntil: Date | null;
    passwordResetToken: string | null;
    passwordResetTokenExpires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    password: string | null;
    firstName: string | null;
    lastName: string | null;
    phone: string | null;
    phoneCarrier: string | null;
    organizationId: string | null;
    role: string | null;
    accountSetupToken: string | null;
    accountSetupTokenExpires: Date | null;
    twoFactorSecret: string | null;
    twoFactorEnabledAt: Date | null;
    isActive: boolean | null;
    isEmailVerified: boolean | null;
    lastLoginAt: Date | null;
    loginAttempts: number | null;
    lockedUntil: Date | null;
    passwordResetToken: string | null;
    passwordResetTokenExpires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    password: number;
    firstName: number;
    lastName: number;
    phone: number;
    phoneCarrier: number;
    organizationId: number;
    role: number;
    accountSetupToken: number;
    accountSetupTokenExpires: number;
    twoFactorSecret: number;
    twoFactorBackupCodes: number;
    twoFactorEnabledAt: number;
    twoFactorOTP: number;
    trustedDevices: number;
    isActive: number;
    isEmailVerified: number;
    lastLoginAt: number;
    loginAttempts: number;
    lockedUntil: number;
    passwordResetToken: number;
    passwordResetTokenExpires: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserAvgAggregateInputType = {
    loginAttempts?: true;
  };

  export type UserSumAggregateInputType = {
    loginAttempts?: true;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    firstName?: true;
    lastName?: true;
    phone?: true;
    phoneCarrier?: true;
    organizationId?: true;
    role?: true;
    accountSetupToken?: true;
    accountSetupTokenExpires?: true;
    twoFactorSecret?: true;
    twoFactorEnabledAt?: true;
    isActive?: true;
    isEmailVerified?: true;
    lastLoginAt?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordResetToken?: true;
    passwordResetTokenExpires?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    firstName?: true;
    lastName?: true;
    phone?: true;
    phoneCarrier?: true;
    organizationId?: true;
    role?: true;
    accountSetupToken?: true;
    accountSetupTokenExpires?: true;
    twoFactorSecret?: true;
    twoFactorEnabledAt?: true;
    isActive?: true;
    isEmailVerified?: true;
    lastLoginAt?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordResetToken?: true;
    passwordResetTokenExpires?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    password?: true;
    firstName?: true;
    lastName?: true;
    phone?: true;
    phoneCarrier?: true;
    organizationId?: true;
    role?: true;
    accountSetupToken?: true;
    accountSetupTokenExpires?: true;
    twoFactorSecret?: true;
    twoFactorBackupCodes?: true;
    twoFactorEnabledAt?: true;
    twoFactorOTP?: true;
    trustedDevices?: true;
    isActive?: true;
    isEmailVerified?: true;
    lastLoginAt?: true;
    loginAttempts?: true;
    lockedUntil?: true;
    passwordResetToken?: true;
    passwordResetTokenExpires?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _avg?: UserAvgAggregateInputType;
      _sum?: UserSumAggregateInputType;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    password: string | null;
    firstName: string;
    lastName: string;
    phone: string | null;
    phoneCarrier: string | null;
    organizationId: string;
    role: string;
    accountSetupToken: string | null;
    accountSetupTokenExpires: Date | null;
    twoFactorSecret: string | null;
    twoFactorBackupCodes: JsonValue | null;
    twoFactorEnabledAt: Date | null;
    twoFactorOTP: JsonValue | null;
    trustedDevices: JsonValue | null;
    isActive: boolean;
    isEmailVerified: boolean;
    lastLoginAt: Date | null;
    loginAttempts: number;
    lockedUntil: Date | null;
    passwordResetToken: string | null;
    passwordResetTokenExpires: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _avg: UserAvgAggregateOutputType | null;
    _sum: UserSumAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        password?: boolean;
        firstName?: boolean;
        lastName?: boolean;
        phone?: boolean;
        phoneCarrier?: boolean;
        organizationId?: boolean;
        role?: boolean;
        accountSetupToken?: boolean;
        accountSetupTokenExpires?: boolean;
        twoFactorSecret?: boolean;
        twoFactorBackupCodes?: boolean;
        twoFactorEnabledAt?: boolean;
        twoFactorOTP?: boolean;
        trustedDevices?: boolean;
        isActive?: boolean;
        isEmailVerified?: boolean;
        lastLoginAt?: boolean;
        loginAttempts?: boolean;
        lockedUntil?: boolean;
        passwordResetToken?: boolean;
        passwordResetTokenExpires?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        apiActivityLogs?: boolean | User$apiActivityLogsArgs<ExtArgs>;
        apiUsage?: boolean | User$apiUsageArgs<ExtArgs>;
        applications?: boolean | User$applicationsArgs<ExtArgs>;
        connections?: boolean | User$connectionsArgs<ExtArgs>;
        endpoints?: boolean | User$endpointsArgs<ExtArgs>;
        notifications?: boolean | User$notificationsArgs<ExtArgs>;
        roles?: boolean | User$rolesArgs<ExtArgs>;
        services?: boolean | User$servicesArgs<ExtArgs>;
        userLogs?: boolean | User$userLogsArgs<ExtArgs>;
        organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
        workflowRuns?: boolean | User$workflowRunsArgs<ExtArgs>;
        workflows?: boolean | User$workflowsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      phone?: boolean;
      phoneCarrier?: boolean;
      organizationId?: boolean;
      role?: boolean;
      accountSetupToken?: boolean;
      accountSetupTokenExpires?: boolean;
      twoFactorSecret?: boolean;
      twoFactorBackupCodes?: boolean;
      twoFactorEnabledAt?: boolean;
      twoFactorOTP?: boolean;
      trustedDevices?: boolean;
      isActive?: boolean;
      isEmailVerified?: boolean;
      lastLoginAt?: boolean;
      loginAttempts?: boolean;
      lockedUntil?: boolean;
      passwordResetToken?: boolean;
      passwordResetTokenExpires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      password?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      phone?: boolean;
      phoneCarrier?: boolean;
      organizationId?: boolean;
      role?: boolean;
      accountSetupToken?: boolean;
      accountSetupTokenExpires?: boolean;
      twoFactorSecret?: boolean;
      twoFactorBackupCodes?: boolean;
      twoFactorEnabledAt?: boolean;
      twoFactorOTP?: boolean;
      trustedDevices?: boolean;
      isActive?: boolean;
      isEmailVerified?: boolean;
      lastLoginAt?: boolean;
      loginAttempts?: boolean;
      lockedUntil?: boolean;
      passwordResetToken?: boolean;
      passwordResetTokenExpires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    password?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    phone?: boolean;
    phoneCarrier?: boolean;
    organizationId?: boolean;
    role?: boolean;
    accountSetupToken?: boolean;
    accountSetupTokenExpires?: boolean;
    twoFactorSecret?: boolean;
    twoFactorBackupCodes?: boolean;
    twoFactorEnabledAt?: boolean;
    twoFactorOTP?: boolean;
    trustedDevices?: boolean;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: boolean;
    loginAttempts?: boolean;
    lockedUntil?: boolean;
    passwordResetToken?: boolean;
    passwordResetTokenExpires?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'email'
      | 'password'
      | 'firstName'
      | 'lastName'
      | 'phone'
      | 'phoneCarrier'
      | 'organizationId'
      | 'role'
      | 'accountSetupToken'
      | 'accountSetupTokenExpires'
      | 'twoFactorSecret'
      | 'twoFactorBackupCodes'
      | 'twoFactorEnabledAt'
      | 'twoFactorOTP'
      | 'trustedDevices'
      | 'isActive'
      | 'isEmailVerified'
      | 'lastLoginAt'
      | 'loginAttempts'
      | 'lockedUntil'
      | 'passwordResetToken'
      | 'passwordResetTokenExpires'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['user']
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiActivityLogs?: boolean | User$apiActivityLogsArgs<ExtArgs>;
    apiUsage?: boolean | User$apiUsageArgs<ExtArgs>;
    applications?: boolean | User$applicationsArgs<ExtArgs>;
    connections?: boolean | User$connectionsArgs<ExtArgs>;
    endpoints?: boolean | User$endpointsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    roles?: boolean | User$rolesArgs<ExtArgs>;
    services?: boolean | User$servicesArgs<ExtArgs>;
    userLogs?: boolean | User$userLogsArgs<ExtArgs>;
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
    workflowRuns?: boolean | User$workflowRunsArgs<ExtArgs>;
    workflows?: boolean | User$workflowsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      apiActivityLogs: Prisma.$ApiActivityLogPayload<ExtArgs>[];
      apiUsage: Prisma.$ApiUsagePayload<ExtArgs>[];
      applications: Prisma.$ApplicationPayload<ExtArgs>[];
      connections: Prisma.$ConnectionPayload<ExtArgs>[];
      endpoints: Prisma.$EndpointPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      roles: Prisma.$RolePayload<ExtArgs>[];
      services: Prisma.$ServicePayload<ExtArgs>[];
      userLogs: Prisma.$UserLogPayload<ExtArgs>[];
      organization: Prisma.$OrganizationPayload<ExtArgs>;
      workflowRuns: Prisma.$WorkflowRunPayload<ExtArgs>[];
      workflows: Prisma.$WorkflowPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        password: string | null;
        firstName: string;
        lastName: string;
        phone: string | null;
        phoneCarrier: string | null;
        organizationId: string;
        role: string;
        accountSetupToken: string | null;
        accountSetupTokenExpires: Date | null;
        twoFactorSecret: string | null;
        twoFactorBackupCodes: Prisma.JsonValue | null;
        twoFactorEnabledAt: Date | null;
        twoFactorOTP: Prisma.JsonValue | null;
        trustedDevices: Prisma.JsonValue | null;
        isActive: boolean;
        isEmailVerified: boolean;
        lastLoginAt: Date | null;
        loginAttempts: number;
        lockedUntil: Date | null;
        passwordResetToken: string | null;
        passwordResetTokenExpires: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    apiActivityLogs<T extends User$apiActivityLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$apiActivityLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    apiUsage<T extends User$apiUsageArgs<ExtArgs> = {}>(
      args?: Subset<T, User$apiUsageArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$applicationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    connections<T extends User$connectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$connectionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    endpoints<T extends User$endpointsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$endpointsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    roles<T extends User$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    services<T extends User$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    userLogs<T extends User$userLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$userLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    workflowRuns<T extends User$workflowRunsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$workflowRunsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    workflows<T extends User$workflowsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$workflowsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly firstName: FieldRef<'User', 'String'>;
    readonly lastName: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly phoneCarrier: FieldRef<'User', 'String'>;
    readonly organizationId: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'String'>;
    readonly accountSetupToken: FieldRef<'User', 'String'>;
    readonly accountSetupTokenExpires: FieldRef<'User', 'DateTime'>;
    readonly twoFactorSecret: FieldRef<'User', 'String'>;
    readonly twoFactorBackupCodes: FieldRef<'User', 'Json'>;
    readonly twoFactorEnabledAt: FieldRef<'User', 'DateTime'>;
    readonly twoFactorOTP: FieldRef<'User', 'Json'>;
    readonly trustedDevices: FieldRef<'User', 'Json'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly isEmailVerified: FieldRef<'User', 'Boolean'>;
    readonly lastLoginAt: FieldRef<'User', 'DateTime'>;
    readonly loginAttempts: FieldRef<'User', 'Int'>;
    readonly lockedUntil: FieldRef<'User', 'DateTime'>;
    readonly passwordResetToken: FieldRef<'User', 'String'>;
    readonly passwordResetTokenExpires: FieldRef<'User', 'DateTime'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.apiActivityLogs
   */
  export type User$apiActivityLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    where?: ApiActivityLogWhereInput;
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    cursor?: ApiActivityLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * User.apiUsage
   */
  export type User$apiUsageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    where?: ApiUsageWhereInput;
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[];
    cursor?: ApiUsageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[];
  };

  /**
   * User.applications
   */
  export type User$applicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    cursor?: ApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * User.connections
   */
  export type User$connectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    where?: ConnectionWhereInput;
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[];
    cursor?: ConnectionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[];
  };

  /**
   * User.endpoints
   */
  export type User$endpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    cursor?: RoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * User.services
   */
  export type User$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * User.userLogs
   */
  export type User$userLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    where?: UserLogWhereInput;
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[];
    cursor?: UserLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[];
  };

  /**
   * User.workflowRuns
   */
  export type User$workflowRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    where?: WorkflowRunWhereInput;
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    cursor?: WorkflowRunWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowRunScalarFieldEnum | WorkflowRunScalarFieldEnum[];
  };

  /**
   * User.workflows
   */
  export type User$workflowsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    cursor?: WorkflowWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null;
    _avg: ConnectionAvgAggregateOutputType | null;
    _sum: ConnectionSumAggregateOutputType | null;
    _min: ConnectionMinAggregateOutputType | null;
    _max: ConnectionMaxAggregateOutputType | null;
  };

  export type ConnectionAvgAggregateOutputType = {
    port: number | null;
  };

  export type ConnectionSumAggregateOutputType = {
    port: number | null;
  };

  export type ConnectionMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    host: string | null;
    port: number | null;
    username: string | null;
    password: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ConnectionMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    host: string | null;
    port: number | null;
    username: string | null;
    password: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ConnectionCountAggregateOutputType = {
    id: number;
    name: number;
    host: number;
    port: number;
    username: number;
    password: number;
    isActive: number;
    failoverHost: number;
    databases: number;
    createdById: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ConnectionAvgAggregateInputType = {
    port?: true;
  };

  export type ConnectionSumAggregateInputType = {
    port?: true;
  };

  export type ConnectionMinAggregateInputType = {
    id?: true;
    name?: true;
    host?: true;
    port?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ConnectionMaxAggregateInputType = {
    id?: true;
    name?: true;
    host?: true;
    port?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ConnectionCountAggregateInputType = {
    id?: true;
    name?: true;
    host?: true;
    port?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    databases?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ConnectionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Connections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Connections
     **/
    _count?: true | ConnectionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ConnectionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ConnectionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ConnectionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ConnectionMaxAggregateInputType;
  };

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
    [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>;
  };

  export type ConnectionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ConnectionWhereInput;
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[];
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum;
    having?: ConnectionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ConnectionCountAggregateInputType | true;
    _avg?: ConnectionAvgAggregateInputType;
    _sum?: ConnectionSumAggregateInputType;
    _min?: ConnectionMinAggregateInputType;
    _max?: ConnectionMaxAggregateInputType;
  };

  export type ConnectionGroupByOutputType = {
    id: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive: boolean;
    failoverHost: string | null;
    databases: string[];
    createdById: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ConnectionCountAggregateOutputType | null;
    _avg: ConnectionAvgAggregateOutputType | null;
    _sum: ConnectionSumAggregateOutputType | null;
    _min: ConnectionMinAggregateOutputType | null;
    _max: ConnectionMaxAggregateOutputType | null;
  };

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ConnectionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
          : GetScalarType<T[P], ConnectionGroupByOutputType[P]>;
      }
    >
  >;

  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        host?: boolean;
        port?: boolean;
        username?: boolean;
        password?: boolean;
        isActive?: boolean;
        failoverHost?: boolean;
        databases?: boolean;
        createdById?: boolean;
        organizationId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        services?: boolean | Connection$servicesArgs<ExtArgs>;
        _count?: boolean | ConnectionCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['connection']
    >;

  export type ConnectionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      host?: boolean;
      port?: boolean;
      username?: boolean;
      password?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      databases?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['connection']
  >;

  export type ConnectionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      host?: boolean;
      port?: boolean;
      username?: boolean;
      password?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      databases?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['connection']
  >;

  export type ConnectionSelectScalar = {
    id?: boolean;
    name?: boolean;
    host?: boolean;
    port?: boolean;
    username?: boolean;
    password?: boolean;
    isActive?: boolean;
    failoverHost?: boolean;
    databases?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'host'
      | 'port'
      | 'username'
      | 'password'
      | 'isActive'
      | 'failoverHost'
      | 'databases'
      | 'createdById'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['connection']
    >;
  export type ConnectionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    services?: boolean | Connection$servicesArgs<ExtArgs>;
    _count?: boolean | ConnectionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ConnectionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ConnectionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ConnectionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Connection';
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
      services: Prisma.$ServicePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        host: string;
        port: number;
        username: string;
        password: string;
        isActive: boolean;
        failoverHost: string | null;
        databases: string[];
        createdById: string;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['connection']
    >;
    composites: {};
  };

  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> =
    $Result.GetResult<Prisma.$ConnectionPayload, S>;

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionCountAggregateInputType | true;
    };

  export interface ConnectionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Connection'];
      meta: { name: 'Connection' };
    };
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionFindUniqueArgs>(
      args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Connection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionFindFirstArgs>(
      args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     *
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ConnectionFindManyArgs>(
      args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     *
     */
    create<T extends ConnectionCreateArgs>(
      args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Connections.
     * @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ConnectionCreateManyArgs>(
      args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Connections and returns the data saved in the database.
     * @param {ConnectionCreateManyAndReturnArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ConnectionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ConnectionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     *
     */
    delete<T extends ConnectionDeleteArgs>(
      args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ConnectionUpdateArgs>(
      args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ConnectionDeleteManyArgs>(
      args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ConnectionUpdateManyArgs>(
      args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Connections and returns the data updated in the database.
     * @param {ConnectionUpdateManyAndReturnArgs} args - Arguments to update many Connections.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Connections and only return the `id`
     * const connectionWithIdOnly = await prisma.connection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ConnectionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ConnectionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionUpsertArgs>(
      args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
     **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ConnectionAggregateArgs>(
      args: Subset<T, ConnectionAggregateArgs>
    ): Prisma.PrismaPromise<GetConnectionAggregateType<T>>;

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Connection model
     */
    readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    services<T extends Connection$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Connection$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Connection model
   */
  interface ConnectionFieldRefs {
    readonly id: FieldRef<'Connection', 'String'>;
    readonly name: FieldRef<'Connection', 'String'>;
    readonly host: FieldRef<'Connection', 'String'>;
    readonly port: FieldRef<'Connection', 'Int'>;
    readonly username: FieldRef<'Connection', 'String'>;
    readonly password: FieldRef<'Connection', 'String'>;
    readonly isActive: FieldRef<'Connection', 'Boolean'>;
    readonly failoverHost: FieldRef<'Connection', 'String'>;
    readonly databases: FieldRef<'Connection', 'String[]'>;
    readonly createdById: FieldRef<'Connection', 'String'>;
    readonly organizationId: FieldRef<'Connection', 'String'>;
    readonly createdAt: FieldRef<'Connection', 'DateTime'>;
    readonly updatedAt: FieldRef<'Connection', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput;
  };

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput;
  };

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Connections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[];
  };

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Connections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[];
  };

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Connections.
     */
    skip?: number;
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[];
  };

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>;
  };

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Connection createManyAndReturn
   */
  export type ConnectionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>;
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput;
  };

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>;
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput;
    /**
     * Limit how many Connections to update.
     */
    limit?: number;
  };

  /**
   * Connection updateManyAndReturn
   */
  export type ConnectionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>;
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput;
    /**
     * Limit how many Connections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput;
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>;
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>;
  };

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput;
  };

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput;
    /**
     * Limit how many Connections to delete.
     */
    limit?: number;
  };

  /**
   * Connection.services
   */
  export type Connection$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
  };

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  export type ServiceAvgAggregateOutputType = {
    port: number | null;
  };

  export type ServiceSumAggregateOutputType = {
    port: number | null;
  };

  export type ServiceMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    password: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdById: string | null;
    organizationId: string | null;
    connectionId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string | null;
    username: string | null;
    password: string | null;
    isActive: boolean | null;
    failoverHost: string | null;
    createdById: string | null;
    organizationId: string | null;
    connectionId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceCountAggregateOutputType = {
    id: number;
    name: number;
    label: number;
    description: number;
    host: number;
    port: number;
    database: number;
    username: number;
    password: number;
    isActive: number;
    failoverHost: number;
    objects: number;
    createdById: number;
    organizationId: number;
    connectionId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ServiceAvgAggregateInputType = {
    port?: true;
  };

  export type ServiceSumAggregateInputType = {
    port?: true;
  };

  export type ServiceMinAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    createdById?: true;
    organizationId?: true;
    connectionId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceMaxAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    createdById?: true;
    organizationId?: true;
    connectionId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceCountAggregateInputType = {
    id?: true;
    name?: true;
    label?: true;
    description?: true;
    host?: true;
    port?: true;
    database?: true;
    username?: true;
    password?: true;
    isActive?: true;
    failoverHost?: true;
    objects?: true;
    createdById?: true;
    organizationId?: true;
    connectionId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Services
     **/
    _count?: true | ServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceMaxAggregateInputType;
  };

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
    [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>;
  };

  export type ServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[];
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum;
    having?: ServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceCountAggregateInputType | true;
    _avg?: ServiceAvgAggregateInputType;
    _sum?: ServiceSumAggregateInputType;
    _min?: ServiceMinAggregateInputType;
    _max?: ServiceMaxAggregateInputType;
  };

  export type ServiceGroupByOutputType = {
    id: string;
    name: string;
    label: string | null;
    description: string | null;
    host: string | null;
    port: number | null;
    database: string;
    username: string | null;
    password: string | null;
    isActive: boolean;
    failoverHost: string | null;
    objects: JsonValue;
    createdById: string;
    organizationId: string;
    connectionId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        label?: boolean;
        description?: boolean;
        host?: boolean;
        port?: boolean;
        database?: boolean;
        username?: boolean;
        password?: boolean;
        isActive?: boolean;
        failoverHost?: boolean;
        objects?: boolean;
        createdById?: boolean;
        organizationId?: boolean;
        connectionId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        applications?: boolean | Service$applicationsArgs<ExtArgs>;
        endpoints?: boolean | Service$endpointsArgs<ExtArgs>;
        connection?: boolean | Service$connectionArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['service']
    >;

  export type ServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      label?: boolean;
      description?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      password?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      objects?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      connectionId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      connection?: boolean | Service$connectionArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      label?: boolean;
      description?: boolean;
      host?: boolean;
      port?: boolean;
      database?: boolean;
      username?: boolean;
      password?: boolean;
      isActive?: boolean;
      failoverHost?: boolean;
      objects?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      connectionId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      connection?: boolean | Service$connectionArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectScalar = {
    id?: boolean;
    name?: boolean;
    label?: boolean;
    description?: boolean;
    host?: boolean;
    port?: boolean;
    database?: boolean;
    username?: boolean;
    password?: boolean;
    isActive?: boolean;
    failoverHost?: boolean;
    objects?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    connectionId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'label'
      | 'description'
      | 'host'
      | 'port'
      | 'database'
      | 'username'
      | 'password'
      | 'isActive'
      | 'failoverHost'
      | 'objects'
      | 'createdById'
      | 'organizationId'
      | 'connectionId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['service']
    >;
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Service$applicationsArgs<ExtArgs>;
    endpoints?: boolean | Service$endpointsArgs<ExtArgs>;
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    connection?: boolean | Service$connectionArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Service';
      objects: {
        applications: Prisma.$ApplicationPayload<ExtArgs>[];
        endpoints: Prisma.$EndpointPayload<ExtArgs>[];
        connection: Prisma.$ConnectionPayload<ExtArgs> | null;
        createdBy: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          label: string | null;
          description: string | null;
          host: string | null;
          port: number | null;
          database: string;
          username: string | null;
          password: string | null;
          isActive: boolean;
          failoverHost: string | null;
          objects: Prisma.JsonValue;
          createdById: string;
          organizationId: string;
          connectionId: string | null;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['service']
      >;
      composites: {};
    };

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> =
    $Result.GetResult<Prisma.$ServicePayload, S>;

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ServiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ServiceCountAggregateInputType | true;
  };

  export interface ServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service']; meta: { name: 'Service' } };
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     *
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     *
     */
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     *
     */
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
     **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceAggregateArgs>(
      args: Subset<T, ServiceAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceAggregateType<T>>;

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Service model
     */
    readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    applications<T extends Service$applicationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$applicationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    endpoints<T extends Service$endpointsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$endpointsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    connection<T extends Service$connectionArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$connectionArgs<ExtArgs>>
    ): Prisma__ConnectionClient<
      $Result.GetResult<
        Prisma.$ConnectionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<'Service', 'String'>;
    readonly name: FieldRef<'Service', 'String'>;
    readonly label: FieldRef<'Service', 'String'>;
    readonly description: FieldRef<'Service', 'String'>;
    readonly host: FieldRef<'Service', 'String'>;
    readonly port: FieldRef<'Service', 'Int'>;
    readonly database: FieldRef<'Service', 'String'>;
    readonly username: FieldRef<'Service', 'String'>;
    readonly password: FieldRef<'Service', 'String'>;
    readonly isActive: FieldRef<'Service', 'Boolean'>;
    readonly failoverHost: FieldRef<'Service', 'String'>;
    readonly objects: FieldRef<'Service', 'Json'>;
    readonly createdById: FieldRef<'Service', 'String'>;
    readonly organizationId: FieldRef<'Service', 'String'>;
    readonly connectionId: FieldRef<'Service', 'String'>;
    readonly createdAt: FieldRef<'Service', 'DateTime'>;
    readonly updatedAt: FieldRef<'Service', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service create
   */
  export type ServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
  };

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service update
   */
  export type ServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
  };

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput;
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
  };

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to delete.
     */
    limit?: number;
  };

  /**
   * Service.applications
   */
  export type Service$applicationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    cursor?: ApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Service.endpoints
   */
  export type Service$endpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Service.connection
   */
  export type Service$connectionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null;
    where?: ConnectionWhereInput;
  };

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
  };

  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null;
    _min: ApplicationMinAggregateOutputType | null;
    _max: ApplicationMaxAggregateOutputType | null;
  };

  export type ApplicationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    serviceId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ApplicationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    serviceId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ApplicationCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    isActive: number;
    configuration: number;
    createdById: number;
    organizationId: number;
    serviceId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ApplicationMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ApplicationMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ApplicationCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    configuration?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ApplicationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Applications
     **/
    _count?: true | ApplicationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApplicationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApplicationMaxAggregateInputType;
  };

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
    [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>;
  };

  export type ApplicationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[];
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum;
    having?: ApplicationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApplicationCountAggregateInputType | true;
    _min?: ApplicationMinAggregateInputType;
    _max?: ApplicationMaxAggregateInputType;
  };

  export type ApplicationGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    isActive: boolean;
    configuration: JsonValue | null;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ApplicationCountAggregateOutputType | null;
    _min: ApplicationMinAggregateOutputType | null;
    _max: ApplicationMaxAggregateOutputType | null;
  };

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApplicationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
          : GetScalarType<T[P], ApplicationGroupByOutputType[P]>;
      }
    >
  >;

  export type ApplicationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      configuration?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      endpoints?: boolean | Application$endpointsArgs<ExtArgs>;
      _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      configuration?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      isActive?: boolean;
      configuration?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['application']
  >;

  export type ApplicationSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    isActive?: boolean;
    configuration?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    serviceId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'isActive'
      | 'configuration'
      | 'createdById'
      | 'organizationId'
      | 'serviceId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['application']
    >;
  export type ApplicationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    endpoints?: boolean | Application$endpointsArgs<ExtArgs>;
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ApplicationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type ApplicationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ApplicationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Application';
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs>;
      endpoints: Prisma.$EndpointPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        isActive: boolean;
        configuration: Prisma.JsonValue | null;
        createdById: string;
        organizationId: string;
        serviceId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['application']
    >;
    composites: {};
  };

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> =
    $Result.GetResult<Prisma.$ApplicationPayload, S>;

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true;
    };

  export interface ApplicationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Application'];
      meta: { name: 'Application' };
    };
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(
      args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(
      args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     *
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApplicationFindManyArgs>(
      args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     *
     */
    create<T extends ApplicationCreateArgs>(
      args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApplicationCreateManyArgs>(
      args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     *
     */
    delete<T extends ApplicationDeleteArgs>(
      args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApplicationUpdateArgs>(
      args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(
      args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApplicationUpdateManyArgs>(
      args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {ApplicationUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApplicationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApplicationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(
      args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
     **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApplicationAggregateArgs>(
      args: Subset<T, ApplicationAggregateArgs>
    ): Prisma.PrismaPromise<GetApplicationAggregateType<T>>;

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Application model
     */
    readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    endpoints<T extends Application$endpointsArgs<ExtArgs> = {}>(
      args?: Subset<T, Application$endpointsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<'Application', 'String'>;
    readonly name: FieldRef<'Application', 'String'>;
    readonly description: FieldRef<'Application', 'String'>;
    readonly isActive: FieldRef<'Application', 'Boolean'>;
    readonly configuration: FieldRef<'Application', 'Json'>;
    readonly createdById: FieldRef<'Application', 'String'>;
    readonly organizationId: FieldRef<'Application', 'String'>;
    readonly serviceId: FieldRef<'Application', 'String'>;
    readonly createdAt: FieldRef<'Application', 'DateTime'>;
    readonly updatedAt: FieldRef<'Application', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Applications.
     */
    skip?: number;
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[];
  };

  /**
   * Application create
   */
  export type ApplicationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>;
  };

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>;
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to update.
     */
    limit?: number;
  };

  /**
   * Application updateManyAndReturn
   */
  export type ApplicationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput;
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>;
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>;
  };

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput;
  };

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput;
    /**
     * Limit how many Applications to delete.
     */
    limit?: number;
  };

  /**
   * Application.endpoints
   */
  export type Application$endpointsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    cursor?: EndpointWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
  };

  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null;
    _min: WorkflowMinAggregateOutputType | null;
    _max: WorkflowMaxAggregateOutputType | null;
  };

  export type WorkflowMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    active: boolean | null;
    schedule: string | null;
    lastDatabaseCheck: Date | null;
    lastHubSpotCheck: Date | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WorkflowMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    active: boolean | null;
    schedule: string | null;
    lastDatabaseCheck: Date | null;
    lastHubSpotCheck: Date | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WorkflowCountAggregateOutputType = {
    id: number;
    name: number;
    active: number;
    schedule: number;
    lastDatabaseCheck: number;
    lastHubSpotCheck: number;
    nodes: number;
    edges: number;
    createdById: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type WorkflowMinAggregateInputType = {
    id?: true;
    name?: true;
    active?: true;
    schedule?: true;
    lastDatabaseCheck?: true;
    lastHubSpotCheck?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WorkflowMaxAggregateInputType = {
    id?: true;
    name?: true;
    active?: true;
    schedule?: true;
    lastDatabaseCheck?: true;
    lastHubSpotCheck?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WorkflowCountAggregateInputType = {
    id?: true;
    name?: true;
    active?: true;
    schedule?: true;
    lastDatabaseCheck?: true;
    lastHubSpotCheck?: true;
    nodes?: true;
    edges?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type WorkflowAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Workflows
     **/
    _count?: true | WorkflowCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WorkflowMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WorkflowMaxAggregateInputType;
  };

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
    [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>;
  };

  export type WorkflowGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[];
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum;
    having?: WorkflowScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WorkflowCountAggregateInputType | true;
    _min?: WorkflowMinAggregateInputType;
    _max?: WorkflowMaxAggregateInputType;
  };

  export type WorkflowGroupByOutputType = {
    id: string;
    name: string;
    active: boolean;
    schedule: string | null;
    lastDatabaseCheck: Date | null;
    lastHubSpotCheck: Date | null;
    nodes: JsonValue;
    edges: JsonValue;
    createdById: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: WorkflowCountAggregateOutputType | null;
    _min: WorkflowMinAggregateOutputType | null;
    _max: WorkflowMaxAggregateOutputType | null;
  };

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> & {
        [P in keyof T & keyof WorkflowGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
          : GetScalarType<T[P], WorkflowGroupByOutputType[P]>;
      }
    >
  >;

  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        active?: boolean;
        schedule?: boolean;
        lastDatabaseCheck?: boolean;
        lastHubSpotCheck?: boolean;
        nodes?: boolean;
        edges?: boolean;
        createdById?: boolean;
        organizationId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        workflowRuns?: boolean | Workflow$workflowRunsArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['workflow']
    >;

  export type WorkflowSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      active?: boolean;
      schedule?: boolean;
      lastDatabaseCheck?: boolean;
      lastHubSpotCheck?: boolean;
      nodes?: boolean;
      edges?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflow']
  >;

  export type WorkflowSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      active?: boolean;
      schedule?: boolean;
      lastDatabaseCheck?: boolean;
      lastHubSpotCheck?: boolean;
      nodes?: boolean;
      edges?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflow']
  >;

  export type WorkflowSelectScalar = {
    id?: boolean;
    name?: boolean;
    active?: boolean;
    schedule?: boolean;
    lastDatabaseCheck?: boolean;
    lastHubSpotCheck?: boolean;
    nodes?: boolean;
    edges?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'active'
      | 'schedule'
      | 'lastDatabaseCheck'
      | 'lastHubSpotCheck'
      | 'nodes'
      | 'edges'
      | 'createdById'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['workflow']
    >;
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      workflowRuns?: boolean | Workflow$workflowRunsArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type WorkflowIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type WorkflowIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Workflow';
      objects: {
        workflowRuns: Prisma.$WorkflowRunPayload<ExtArgs>[];
        createdBy: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          active: boolean;
          schedule: string | null;
          lastDatabaseCheck: Date | null;
          lastHubSpotCheck: Date | null;
          nodes: Prisma.JsonValue;
          edges: Prisma.JsonValue;
          createdById: string;
          organizationId: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['workflow']
      >;
      composites: {};
    };

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> =
    $Result.GetResult<Prisma.$WorkflowPayload, S>;

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WorkflowFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: WorkflowCountAggregateInputType | true;
  };

  export interface WorkflowDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Workflow'];
      meta: { name: 'Workflow' };
    };
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(
      args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(
      args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     *
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WorkflowFindManyArgs>(
      args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     *
     */
    create<T extends WorkflowCreateArgs>(
      args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WorkflowCreateManyArgs>(
      args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     *
     */
    delete<T extends WorkflowDeleteArgs>(
      args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WorkflowUpdateArgs>(
      args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(
      args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WorkflowUpdateManyArgs>(
      args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(
      args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      $Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
     **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WorkflowAggregateArgs>(
      args: Subset<T, WorkflowAggregateArgs>
    ): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>;

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Workflow model
     */
    readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    workflowRuns<T extends Workflow$workflowRunsArgs<ExtArgs> = {}>(
      args?: Subset<T, Workflow$workflowRunsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<'Workflow', 'String'>;
    readonly name: FieldRef<'Workflow', 'String'>;
    readonly active: FieldRef<'Workflow', 'Boolean'>;
    readonly schedule: FieldRef<'Workflow', 'String'>;
    readonly lastDatabaseCheck: FieldRef<'Workflow', 'DateTime'>;
    readonly lastHubSpotCheck: FieldRef<'Workflow', 'DateTime'>;
    readonly nodes: FieldRef<'Workflow', 'Json'>;
    readonly edges: FieldRef<'Workflow', 'Json'>;
    readonly createdById: FieldRef<'Workflow', 'String'>;
    readonly organizationId: FieldRef<'Workflow', 'String'>;
    readonly createdAt: FieldRef<'Workflow', 'DateTime'>;
    readonly updatedAt: FieldRef<'Workflow', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Workflows.
     */
    skip?: number;
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[];
  };

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>;
  };

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>;
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>;
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to update.
     */
    limit?: number;
  };

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>;
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput;
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>;
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>;
  };

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput;
  };

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput;
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number;
  };

  /**
   * Workflow.workflowRuns
   */
  export type Workflow$workflowRunsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    where?: WorkflowRunWhereInput;
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    cursor?: WorkflowRunWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WorkflowRunScalarFieldEnum | WorkflowRunScalarFieldEnum[];
  };

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null;
  };

  /**
   * Model WorkflowRun
   */

  export type AggregateWorkflowRun = {
    _count: WorkflowRunCountAggregateOutputType | null;
    _min: WorkflowRunMinAggregateOutputType | null;
    _max: WorkflowRunMaxAggregateOutputType | null;
  };

  export type WorkflowRunMinAggregateOutputType = {
    id: string | null;
    status: string | null;
    startedAt: Date | null;
    completedAt: Date | null;
    errorMessage: string | null;
    workflowId: string | null;
    triggeredById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WorkflowRunMaxAggregateOutputType = {
    id: string | null;
    status: string | null;
    startedAt: Date | null;
    completedAt: Date | null;
    errorMessage: string | null;
    workflowId: string | null;
    triggeredById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type WorkflowRunCountAggregateOutputType = {
    id: number;
    status: number;
    startedAt: number;
    completedAt: number;
    errorMessage: number;
    executionData: number;
    workflowId: number;
    triggeredById: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type WorkflowRunMinAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    errorMessage?: true;
    workflowId?: true;
    triggeredById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WorkflowRunMaxAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    errorMessage?: true;
    workflowId?: true;
    triggeredById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type WorkflowRunCountAggregateInputType = {
    id?: true;
    status?: true;
    startedAt?: true;
    completedAt?: true;
    errorMessage?: true;
    executionData?: true;
    workflowId?: true;
    triggeredById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type WorkflowRunAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WorkflowRun to aggregate.
     */
    where?: WorkflowRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowRuns to fetch.
     */
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WorkflowRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WorkflowRuns
     **/
    _count?: true | WorkflowRunCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WorkflowRunMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WorkflowRunMaxAggregateInputType;
  };

  export type GetWorkflowRunAggregateType<T extends WorkflowRunAggregateArgs> = {
    [P in keyof T & keyof AggregateWorkflowRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowRun[P]>
      : GetScalarType<T[P], AggregateWorkflowRun[P]>;
  };

  export type WorkflowRunGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WorkflowRunWhereInput;
    orderBy?: WorkflowRunOrderByWithAggregationInput | WorkflowRunOrderByWithAggregationInput[];
    by: WorkflowRunScalarFieldEnum[] | WorkflowRunScalarFieldEnum;
    having?: WorkflowRunScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WorkflowRunCountAggregateInputType | true;
    _min?: WorkflowRunMinAggregateInputType;
    _max?: WorkflowRunMaxAggregateInputType;
  };

  export type WorkflowRunGroupByOutputType = {
    id: string;
    status: string;
    startedAt: Date | null;
    completedAt: Date | null;
    errorMessage: string | null;
    executionData: JsonValue | null;
    workflowId: string;
    triggeredById: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: WorkflowRunCountAggregateOutputType | null;
    _min: WorkflowRunMinAggregateOutputType | null;
    _max: WorkflowRunMaxAggregateOutputType | null;
  };

  type GetWorkflowRunGroupByPayload<T extends WorkflowRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowRunGroupByOutputType, T['by']> & {
        [P in keyof T & keyof WorkflowRunGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WorkflowRunGroupByOutputType[P]>
          : GetScalarType<T[P], WorkflowRunGroupByOutputType[P]>;
      }
    >
  >;

  export type WorkflowRunSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      errorMessage?: boolean;
      executionData?: boolean;
      workflowId?: boolean;
      triggeredById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowRun']
  >;

  export type WorkflowRunSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      errorMessage?: boolean;
      executionData?: boolean;
      workflowId?: boolean;
      triggeredById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowRun']
  >;

  export type WorkflowRunSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      status?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      errorMessage?: boolean;
      executionData?: boolean;
      workflowId?: boolean;
      triggeredById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
      workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['workflowRun']
  >;

  export type WorkflowRunSelectScalar = {
    id?: boolean;
    status?: boolean;
    startedAt?: boolean;
    completedAt?: boolean;
    errorMessage?: boolean;
    executionData?: boolean;
    workflowId?: boolean;
    triggeredById?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type WorkflowRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'status'
      | 'startedAt'
      | 'completedAt'
      | 'errorMessage'
      | 'executionData'
      | 'workflowId'
      | 'triggeredById'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['workflowRun']
    >;
  export type WorkflowRunInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };
  export type WorkflowRunIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };
  export type WorkflowRunIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    triggeredBy?: boolean | UserDefaultArgs<ExtArgs>;
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>;
  };

  export type $WorkflowRunPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'WorkflowRun';
    objects: {
      triggeredBy: Prisma.$UserPayload<ExtArgs>;
      workflow: Prisma.$WorkflowPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        status: string;
        startedAt: Date | null;
        completedAt: Date | null;
        errorMessage: string | null;
        executionData: Prisma.JsonValue | null;
        workflowId: string;
        triggeredById: string;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['workflowRun']
    >;
    composites: {};
  };

  type WorkflowRunGetPayload<S extends boolean | null | undefined | WorkflowRunDefaultArgs> =
    $Result.GetResult<Prisma.$WorkflowRunPayload, S>;

  type WorkflowRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowRunCountAggregateInputType | true;
    };

  export interface WorkflowRunDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['WorkflowRun'];
      meta: { name: 'WorkflowRun' };
    };
    /**
     * Find zero or one WorkflowRun that matches the filter.
     * @param {WorkflowRunFindUniqueArgs} args - Arguments to find a WorkflowRun
     * @example
     * // Get one WorkflowRun
     * const workflowRun = await prisma.workflowRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowRunFindUniqueArgs>(
      args: SelectSubset<T, WorkflowRunFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WorkflowRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowRunFindUniqueOrThrowArgs} args - Arguments to find a WorkflowRun
     * @example
     * // Get one WorkflowRun
     * const workflowRun = await prisma.workflowRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowRunFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WorkflowRunFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WorkflowRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunFindFirstArgs} args - Arguments to find a WorkflowRun
     * @example
     * // Get one WorkflowRun
     * const workflowRun = await prisma.workflowRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowRunFindFirstArgs>(
      args?: SelectSubset<T, WorkflowRunFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WorkflowRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunFindFirstOrThrowArgs} args - Arguments to find a WorkflowRun
     * @example
     * // Get one WorkflowRun
     * const workflowRun = await prisma.workflowRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowRunFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkflowRunFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WorkflowRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowRuns
     * const workflowRuns = await prisma.workflowRun.findMany()
     *
     * // Get first 10 WorkflowRuns
     * const workflowRuns = await prisma.workflowRun.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const workflowRunWithIdOnly = await prisma.workflowRun.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WorkflowRunFindManyArgs>(
      args?: SelectSubset<T, WorkflowRunFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a WorkflowRun.
     * @param {WorkflowRunCreateArgs} args - Arguments to create a WorkflowRun.
     * @example
     * // Create one WorkflowRun
     * const WorkflowRun = await prisma.workflowRun.create({
     *   data: {
     *     // ... data to create a WorkflowRun
     *   }
     * })
     *
     */
    create<T extends WorkflowRunCreateArgs>(
      args: SelectSubset<T, WorkflowRunCreateArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WorkflowRuns.
     * @param {WorkflowRunCreateManyArgs} args - Arguments to create many WorkflowRuns.
     * @example
     * // Create many WorkflowRuns
     * const workflowRun = await prisma.workflowRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WorkflowRunCreateManyArgs>(
      args?: SelectSubset<T, WorkflowRunCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WorkflowRuns and returns the data saved in the database.
     * @param {WorkflowRunCreateManyAndReturnArgs} args - Arguments to create many WorkflowRuns.
     * @example
     * // Create many WorkflowRuns
     * const workflowRun = await prisma.workflowRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WorkflowRuns and only return the `id`
     * const workflowRunWithIdOnly = await prisma.workflowRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WorkflowRunCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WorkflowRunCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a WorkflowRun.
     * @param {WorkflowRunDeleteArgs} args - Arguments to delete one WorkflowRun.
     * @example
     * // Delete one WorkflowRun
     * const WorkflowRun = await prisma.workflowRun.delete({
     *   where: {
     *     // ... filter to delete one WorkflowRun
     *   }
     * })
     *
     */
    delete<T extends WorkflowRunDeleteArgs>(
      args: SelectSubset<T, WorkflowRunDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WorkflowRun.
     * @param {WorkflowRunUpdateArgs} args - Arguments to update one WorkflowRun.
     * @example
     * // Update one WorkflowRun
     * const workflowRun = await prisma.workflowRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WorkflowRunUpdateArgs>(
      args: SelectSubset<T, WorkflowRunUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WorkflowRuns.
     * @param {WorkflowRunDeleteManyArgs} args - Arguments to filter WorkflowRuns to delete.
     * @example
     * // Delete a few WorkflowRuns
     * const { count } = await prisma.workflowRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WorkflowRunDeleteManyArgs>(
      args?: SelectSubset<T, WorkflowRunDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WorkflowRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowRuns
     * const workflowRun = await prisma.workflowRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WorkflowRunUpdateManyArgs>(
      args: SelectSubset<T, WorkflowRunUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WorkflowRuns and returns the data updated in the database.
     * @param {WorkflowRunUpdateManyAndReturnArgs} args - Arguments to update many WorkflowRuns.
     * @example
     * // Update many WorkflowRuns
     * const workflowRun = await prisma.workflowRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WorkflowRuns and only return the `id`
     * const workflowRunWithIdOnly = await prisma.workflowRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WorkflowRunUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WorkflowRunUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WorkflowRunPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one WorkflowRun.
     * @param {WorkflowRunUpsertArgs} args - Arguments to update or create a WorkflowRun.
     * @example
     * // Update or create a WorkflowRun
     * const workflowRun = await prisma.workflowRun.upsert({
     *   create: {
     *     // ... data to create a WorkflowRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowRun we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowRunUpsertArgs>(
      args: SelectSubset<T, WorkflowRunUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowRunClient<
      $Result.GetResult<Prisma.$WorkflowRunPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WorkflowRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunCountArgs} args - Arguments to filter WorkflowRuns to count.
     * @example
     * // Count the number of WorkflowRuns
     * const count = await prisma.workflowRun.count({
     *   where: {
     *     // ... the filter for the WorkflowRuns we want to count
     *   }
     * })
     **/
    count<T extends WorkflowRunCountArgs>(
      args?: Subset<T, WorkflowRunCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowRunCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WorkflowRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WorkflowRunAggregateArgs>(
      args: Subset<T, WorkflowRunAggregateArgs>
    ): Prisma.PrismaPromise<GetWorkflowRunAggregateType<T>>;

    /**
     * Group by WorkflowRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WorkflowRunGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowRunGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WorkflowRunGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWorkflowRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WorkflowRun model
     */
    readonly fields: WorkflowRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowRunClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    triggeredBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>
    ): Prisma__WorkflowClient<
      | $Result.GetResult<
          Prisma.$WorkflowPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WorkflowRun model
   */
  interface WorkflowRunFieldRefs {
    readonly id: FieldRef<'WorkflowRun', 'String'>;
    readonly status: FieldRef<'WorkflowRun', 'String'>;
    readonly startedAt: FieldRef<'WorkflowRun', 'DateTime'>;
    readonly completedAt: FieldRef<'WorkflowRun', 'DateTime'>;
    readonly errorMessage: FieldRef<'WorkflowRun', 'String'>;
    readonly executionData: FieldRef<'WorkflowRun', 'Json'>;
    readonly workflowId: FieldRef<'WorkflowRun', 'String'>;
    readonly triggeredById: FieldRef<'WorkflowRun', 'String'>;
    readonly organizationId: FieldRef<'WorkflowRun', 'String'>;
    readonly createdAt: FieldRef<'WorkflowRun', 'DateTime'>;
    readonly updatedAt: FieldRef<'WorkflowRun', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * WorkflowRun findUnique
   */
  export type WorkflowRunFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowRun to fetch.
     */
    where: WorkflowRunWhereUniqueInput;
  };

  /**
   * WorkflowRun findUniqueOrThrow
   */
  export type WorkflowRunFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowRun to fetch.
     */
    where: WorkflowRunWhereUniqueInput;
  };

  /**
   * WorkflowRun findFirst
   */
  export type WorkflowRunFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowRun to fetch.
     */
    where?: WorkflowRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowRuns to fetch.
     */
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WorkflowRuns.
     */
    cursor?: WorkflowRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WorkflowRuns.
     */
    distinct?: WorkflowRunScalarFieldEnum | WorkflowRunScalarFieldEnum[];
  };

  /**
   * WorkflowRun findFirstOrThrow
   */
  export type WorkflowRunFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowRun to fetch.
     */
    where?: WorkflowRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowRuns to fetch.
     */
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WorkflowRuns.
     */
    cursor?: WorkflowRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowRuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WorkflowRuns.
     */
    distinct?: WorkflowRunScalarFieldEnum | WorkflowRunScalarFieldEnum[];
  };

  /**
   * WorkflowRun findMany
   */
  export type WorkflowRunFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter, which WorkflowRuns to fetch.
     */
    where?: WorkflowRunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WorkflowRuns to fetch.
     */
    orderBy?: WorkflowRunOrderByWithRelationInput | WorkflowRunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WorkflowRuns.
     */
    cursor?: WorkflowRunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WorkflowRuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WorkflowRuns.
     */
    skip?: number;
    distinct?: WorkflowRunScalarFieldEnum | WorkflowRunScalarFieldEnum[];
  };

  /**
   * WorkflowRun create
   */
  export type WorkflowRunCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * The data needed to create a WorkflowRun.
     */
    data: XOR<WorkflowRunCreateInput, WorkflowRunUncheckedCreateInput>;
  };

  /**
   * WorkflowRun createMany
   */
  export type WorkflowRunCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many WorkflowRuns.
     */
    data: WorkflowRunCreateManyInput | WorkflowRunCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WorkflowRun createManyAndReturn
   */
  export type WorkflowRunCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * The data used to create many WorkflowRuns.
     */
    data: WorkflowRunCreateManyInput | WorkflowRunCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WorkflowRun update
   */
  export type WorkflowRunUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * The data needed to update a WorkflowRun.
     */
    data: XOR<WorkflowRunUpdateInput, WorkflowRunUncheckedUpdateInput>;
    /**
     * Choose, which WorkflowRun to update.
     */
    where: WorkflowRunWhereUniqueInput;
  };

  /**
   * WorkflowRun updateMany
   */
  export type WorkflowRunUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update WorkflowRuns.
     */
    data: XOR<WorkflowRunUpdateManyMutationInput, WorkflowRunUncheckedUpdateManyInput>;
    /**
     * Filter which WorkflowRuns to update
     */
    where?: WorkflowRunWhereInput;
    /**
     * Limit how many WorkflowRuns to update.
     */
    limit?: number;
  };

  /**
   * WorkflowRun updateManyAndReturn
   */
  export type WorkflowRunUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * The data used to update WorkflowRuns.
     */
    data: XOR<WorkflowRunUpdateManyMutationInput, WorkflowRunUncheckedUpdateManyInput>;
    /**
     * Filter which WorkflowRuns to update
     */
    where?: WorkflowRunWhereInput;
    /**
     * Limit how many WorkflowRuns to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WorkflowRun upsert
   */
  export type WorkflowRunUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * The filter to search for the WorkflowRun to update in case it exists.
     */
    where: WorkflowRunWhereUniqueInput;
    /**
     * In case the WorkflowRun found by the `where` argument doesn't exist, create a new WorkflowRun with this data.
     */
    create: XOR<WorkflowRunCreateInput, WorkflowRunUncheckedCreateInput>;
    /**
     * In case the WorkflowRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowRunUpdateInput, WorkflowRunUncheckedUpdateInput>;
  };

  /**
   * WorkflowRun delete
   */
  export type WorkflowRunDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
    /**
     * Filter which WorkflowRun to delete.
     */
    where: WorkflowRunWhereUniqueInput;
  };

  /**
   * WorkflowRun deleteMany
   */
  export type WorkflowRunDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WorkflowRuns to delete
     */
    where?: WorkflowRunWhereInput;
    /**
     * Limit how many WorkflowRuns to delete.
     */
    limit?: number;
  };

  /**
   * WorkflowRun without action
   */
  export type WorkflowRunDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WorkflowRun
     */
    select?: WorkflowRunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WorkflowRun
     */
    omit?: WorkflowRunOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRunInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    permissions: number;
    isActive: number;
    createdById: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    permissions?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[];
      by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
      having?: RoleScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: RoleCountAggregateInputType | true;
      _min?: RoleMinAggregateInputType;
      _max?: RoleMaxAggregateInputType;
    };

  export type RoleGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    permissions: JsonValue;
    isActive: boolean;
    createdById: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        permissions?: boolean;
        isActive?: boolean;
        createdById?: boolean;
        organizationId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['role']
    >;

  export type RoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      permissions?: boolean;
      isActive?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      permissions?: boolean;
      isActive?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    permissions?: boolean;
    isActive?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'description'
      | 'permissions'
      | 'isActive'
      | 'createdById'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['role']
    >;
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Role';
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        permissions: Prisma.JsonValue;
        isActive: boolean;
        createdById: string;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['role']
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<
    Prisma.$RolePayload,
    S
  >;

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    RoleFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role']; meta: { name: 'Role' } };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<'Role', 'String'>;
    readonly name: FieldRef<'Role', 'String'>;
    readonly description: FieldRef<'Role', 'String'>;
    readonly permissions: FieldRef<'Role', 'Json'>;
    readonly isActive: FieldRef<'Role', 'Boolean'>;
    readonly createdById: FieldRef<'Role', 'String'>;
    readonly organizationId: FieldRef<'Role', 'String'>;
    readonly createdAt: FieldRef<'Role', 'DateTime'>;
    readonly updatedAt: FieldRef<'Role', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
      /**
       * Filter, which Roles to fetch.
       */
      where?: RoleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Roles to fetch.
       */
      orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Roles.
       */
      cursor?: RoleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Roles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Roles.
       */
      skip?: number;
      distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
    };

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
  };

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
    /**
     * Limit how many Roles to delete.
     */
    limit?: number;
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Role
       */
      select?: RoleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Role
       */
      omit?: RoleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: RoleInclude<ExtArgs> | null;
    };

  /**
   * Model Endpoint
   */

  export type AggregateEndpoint = {
    _count: EndpointCountAggregateOutputType | null;
    _min: EndpointMinAggregateOutputType | null;
    _max: EndpointMaxAggregateOutputType | null;
  };

  export type EndpointMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    path: string | null;
    method: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    serviceId: string | null;
    applicationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EndpointMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    path: string | null;
    method: string | null;
    description: string | null;
    isActive: boolean | null;
    createdById: string | null;
    organizationId: string | null;
    serviceId: string | null;
    applicationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EndpointCountAggregateOutputType = {
    id: number;
    name: number;
    path: number;
    method: number;
    description: number;
    isActive: number;
    configuration: number;
    createdById: number;
    organizationId: number;
    serviceId: number;
    applicationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type EndpointMinAggregateInputType = {
    id?: true;
    name?: true;
    path?: true;
    method?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    applicationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EndpointMaxAggregateInputType = {
    id?: true;
    name?: true;
    path?: true;
    method?: true;
    description?: true;
    isActive?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    applicationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EndpointCountAggregateInputType = {
    id?: true;
    name?: true;
    path?: true;
    method?: true;
    description?: true;
    isActive?: true;
    configuration?: true;
    createdById?: true;
    organizationId?: true;
    serviceId?: true;
    applicationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type EndpointAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Endpoint to aggregate.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Endpoints
     **/
    _count?: true | EndpointCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EndpointMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EndpointMaxAggregateInputType;
  };

  export type GetEndpointAggregateType<T extends EndpointAggregateArgs> = {
    [P in keyof T & keyof AggregateEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndpoint[P]>
      : GetScalarType<T[P], AggregateEndpoint[P]>;
  };

  export type EndpointGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EndpointWhereInput;
    orderBy?: EndpointOrderByWithAggregationInput | EndpointOrderByWithAggregationInput[];
    by: EndpointScalarFieldEnum[] | EndpointScalarFieldEnum;
    having?: EndpointScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EndpointCountAggregateInputType | true;
    _min?: EndpointMinAggregateInputType;
    _max?: EndpointMaxAggregateInputType;
  };

  export type EndpointGroupByOutputType = {
    id: string;
    name: string;
    path: string;
    method: string;
    description: string | null;
    isActive: boolean;
    configuration: JsonValue | null;
    createdById: string;
    organizationId: string;
    serviceId: string;
    applicationId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: EndpointCountAggregateOutputType | null;
    _min: EndpointMinAggregateOutputType | null;
    _max: EndpointMaxAggregateOutputType | null;
  };

  type GetEndpointGroupByPayload<T extends EndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EndpointGroupByOutputType, T['by']> & {
        [P in keyof T & keyof EndpointGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EndpointGroupByOutputType[P]>
          : GetScalarType<T[P], EndpointGroupByOutputType[P]>;
      }
    >
  >;

  export type EndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        path?: boolean;
        method?: boolean;
        description?: boolean;
        isActive?: boolean;
        configuration?: boolean;
        createdById?: boolean;
        organizationId?: boolean;
        serviceId?: boolean;
        applicationId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        application?: boolean | Endpoint$applicationArgs<ExtArgs>;
        createdBy?: boolean | UserDefaultArgs<ExtArgs>;
        service?: boolean | ServiceDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['endpoint']
    >;

  export type EndpointSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      path?: boolean;
      method?: boolean;
      description?: boolean;
      isActive?: boolean;
      configuration?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      applicationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      application?: boolean | Endpoint$applicationArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['endpoint']
  >;

  export type EndpointSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      path?: boolean;
      method?: boolean;
      description?: boolean;
      isActive?: boolean;
      configuration?: boolean;
      createdById?: boolean;
      organizationId?: boolean;
      serviceId?: boolean;
      applicationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      application?: boolean | Endpoint$applicationArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['endpoint']
  >;

  export type EndpointSelectScalar = {
    id?: boolean;
    name?: boolean;
    path?: boolean;
    method?: boolean;
    description?: boolean;
    isActive?: boolean;
    configuration?: boolean;
    createdById?: boolean;
    organizationId?: boolean;
    serviceId?: boolean;
    applicationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type EndpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'path'
      | 'method'
      | 'description'
      | 'isActive'
      | 'configuration'
      | 'createdById'
      | 'organizationId'
      | 'serviceId'
      | 'applicationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['endpoint']
    >;
  export type EndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      application?: boolean | Endpoint$applicationArgs<ExtArgs>;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    };
  export type EndpointIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    application?: boolean | Endpoint$applicationArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type EndpointIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    application?: boolean | Endpoint$applicationArgs<ExtArgs>;
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $EndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Endpoint';
      objects: {
        application: Prisma.$ApplicationPayload<ExtArgs> | null;
        createdBy: Prisma.$UserPayload<ExtArgs>;
        service: Prisma.$ServicePayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          path: string;
          method: string;
          description: string | null;
          isActive: boolean;
          configuration: Prisma.JsonValue | null;
          createdById: string;
          organizationId: string;
          serviceId: string;
          applicationId: string | null;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['endpoint']
      >;
      composites: {};
    };

  type EndpointGetPayload<S extends boolean | null | undefined | EndpointDefaultArgs> =
    $Result.GetResult<Prisma.$EndpointPayload, S>;

  type EndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    EndpointFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: EndpointCountAggregateInputType | true;
  };

  export interface EndpointDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Endpoint'];
      meta: { name: 'Endpoint' };
    };
    /**
     * Find zero or one Endpoint that matches the filter.
     * @param {EndpointFindUniqueArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EndpointFindUniqueArgs>(
      args: SelectSubset<T, EndpointFindUniqueArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Endpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EndpointFindUniqueOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EndpointFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EndpointFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Endpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EndpointFindFirstArgs>(
      args?: SelectSubset<T, EndpointFindFirstArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Endpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindFirstOrThrowArgs} args - Arguments to find a Endpoint
     * @example
     * // Get one Endpoint
     * const endpoint = await prisma.endpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EndpointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EndpointFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Endpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endpoints
     * const endpoints = await prisma.endpoint.findMany()
     *
     * // Get first 10 Endpoints
     * const endpoints = await prisma.endpoint.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const endpointWithIdOnly = await prisma.endpoint.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EndpointFindManyArgs>(
      args?: SelectSubset<T, EndpointFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Endpoint.
     * @param {EndpointCreateArgs} args - Arguments to create a Endpoint.
     * @example
     * // Create one Endpoint
     * const Endpoint = await prisma.endpoint.create({
     *   data: {
     *     // ... data to create a Endpoint
     *   }
     * })
     *
     */
    create<T extends EndpointCreateArgs>(
      args: SelectSubset<T, EndpointCreateArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Endpoints.
     * @param {EndpointCreateManyArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EndpointCreateManyArgs>(
      args?: SelectSubset<T, EndpointCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Endpoints and returns the data saved in the database.
     * @param {EndpointCreateManyAndReturnArgs} args - Arguments to create many Endpoints.
     * @example
     * // Create many Endpoints
     * const endpoint = await prisma.endpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends EndpointCreateManyAndReturnArgs>(
      args?: SelectSubset<T, EndpointCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Endpoint.
     * @param {EndpointDeleteArgs} args - Arguments to delete one Endpoint.
     * @example
     * // Delete one Endpoint
     * const Endpoint = await prisma.endpoint.delete({
     *   where: {
     *     // ... filter to delete one Endpoint
     *   }
     * })
     *
     */
    delete<T extends EndpointDeleteArgs>(
      args: SelectSubset<T, EndpointDeleteArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Endpoint.
     * @param {EndpointUpdateArgs} args - Arguments to update one Endpoint.
     * @example
     * // Update one Endpoint
     * const endpoint = await prisma.endpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EndpointUpdateArgs>(
      args: SelectSubset<T, EndpointUpdateArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Endpoints.
     * @param {EndpointDeleteManyArgs} args - Arguments to filter Endpoints to delete.
     * @example
     * // Delete a few Endpoints
     * const { count } = await prisma.endpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EndpointDeleteManyArgs>(
      args?: SelectSubset<T, EndpointDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EndpointUpdateManyArgs>(
      args: SelectSubset<T, EndpointUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Endpoints and returns the data updated in the database.
     * @param {EndpointUpdateManyAndReturnArgs} args - Arguments to update many Endpoints.
     * @example
     * // Update many Endpoints
     * const endpoint = await prisma.endpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Endpoints and only return the `id`
     * const endpointWithIdOnly = await prisma.endpoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends EndpointUpdateManyAndReturnArgs>(
      args: SelectSubset<T, EndpointUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EndpointPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Endpoint.
     * @param {EndpointUpsertArgs} args - Arguments to update or create a Endpoint.
     * @example
     * // Update or create a Endpoint
     * const endpoint = await prisma.endpoint.upsert({
     *   create: {
     *     // ... data to create a Endpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endpoint we want to update
     *   }
     * })
     */
    upsert<T extends EndpointUpsertArgs>(
      args: SelectSubset<T, EndpointUpsertArgs<ExtArgs>>
    ): Prisma__EndpointClient<
      $Result.GetResult<Prisma.$EndpointPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Endpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointCountArgs} args - Arguments to filter Endpoints to count.
     * @example
     * // Count the number of Endpoints
     * const count = await prisma.endpoint.count({
     *   where: {
     *     // ... the filter for the Endpoints we want to count
     *   }
     * })
     **/
    count<T extends EndpointCountArgs>(
      args?: Subset<T, EndpointCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndpointCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EndpointAggregateArgs>(
      args: Subset<T, EndpointAggregateArgs>
    ): Prisma.PrismaPromise<GetEndpointAggregateType<T>>;

    /**
     * Group by Endpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EndpointGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndpointGroupByArgs['orderBy'] }
        : { orderBy?: EndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EndpointGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Endpoint model
     */
    readonly fields: EndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EndpointClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    application<T extends Endpoint$applicationArgs<ExtArgs> = {}>(
      args?: Subset<T, Endpoint$applicationArgs<ExtArgs>>
    ): Prisma__ApplicationClient<
      $Result.GetResult<
        Prisma.$ApplicationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Endpoint model
   */
  interface EndpointFieldRefs {
    readonly id: FieldRef<'Endpoint', 'String'>;
    readonly name: FieldRef<'Endpoint', 'String'>;
    readonly path: FieldRef<'Endpoint', 'String'>;
    readonly method: FieldRef<'Endpoint', 'String'>;
    readonly description: FieldRef<'Endpoint', 'String'>;
    readonly isActive: FieldRef<'Endpoint', 'Boolean'>;
    readonly configuration: FieldRef<'Endpoint', 'Json'>;
    readonly createdById: FieldRef<'Endpoint', 'String'>;
    readonly organizationId: FieldRef<'Endpoint', 'String'>;
    readonly serviceId: FieldRef<'Endpoint', 'String'>;
    readonly applicationId: FieldRef<'Endpoint', 'String'>;
    readonly createdAt: FieldRef<'Endpoint', 'DateTime'>;
    readonly updatedAt: FieldRef<'Endpoint', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Endpoint findUnique
   */
  export type EndpointFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint findUniqueOrThrow
   */
  export type EndpointFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint findFirst
   */
  export type EndpointFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint findFirstOrThrow
   */
  export type EndpointFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoint to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Endpoints.
     */
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint findMany
   */
  export type EndpointFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter, which Endpoints to fetch.
     */
    where?: EndpointWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Endpoints to fetch.
     */
    orderBy?: EndpointOrderByWithRelationInput | EndpointOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Endpoints.
     */
    cursor?: EndpointWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Endpoints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Endpoints.
     */
    skip?: number;
    distinct?: EndpointScalarFieldEnum | EndpointScalarFieldEnum[];
  };

  /**
   * Endpoint create
   */
  export type EndpointCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The data needed to create a Endpoint.
     */
    data: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>;
  };

  /**
   * Endpoint createMany
   */
  export type EndpointCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Endpoint createManyAndReturn
   */
  export type EndpointCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * The data used to create many Endpoints.
     */
    data: EndpointCreateManyInput | EndpointCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Endpoint update
   */
  export type EndpointUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The data needed to update a Endpoint.
     */
    data: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>;
    /**
     * Choose, which Endpoint to update.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint updateMany
   */
  export type EndpointUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>;
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number;
  };

  /**
   * Endpoint updateManyAndReturn
   */
  export type EndpointUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * The data used to update Endpoints.
     */
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyInput>;
    /**
     * Filter which Endpoints to update
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Endpoint upsert
   */
  export type EndpointUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * The filter to search for the Endpoint to update in case it exists.
     */
    where: EndpointWhereUniqueInput;
    /**
     * In case the Endpoint found by the `where` argument doesn't exist, create a new Endpoint with this data.
     */
    create: XOR<EndpointCreateInput, EndpointUncheckedCreateInput>;
    /**
     * In case the Endpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EndpointUpdateInput, EndpointUncheckedUpdateInput>;
  };

  /**
   * Endpoint delete
   */
  export type EndpointDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
    /**
     * Filter which Endpoint to delete.
     */
    where: EndpointWhereUniqueInput;
  };

  /**
   * Endpoint deleteMany
   */
  export type EndpointDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Endpoints to delete
     */
    where?: EndpointWhereInput;
    /**
     * Limit how many Endpoints to delete.
     */
    limit?: number;
  };

  /**
   * Endpoint.application
   */
  export type Endpoint$applicationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null;
    where?: ApplicationWhereInput;
  };

  /**
   * Endpoint without action
   */
  export type EndpointDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Endpoint
     */
    select?: EndpointSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Endpoint
     */
    omit?: EndpointOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndpointInclude<ExtArgs> | null;
  };

  /**
   * Model ApiActivityLog
   */

  export type AggregateApiActivityLog = {
    _count: ApiActivityLogCountAggregateOutputType | null;
    _avg: ApiActivityLogAvgAggregateOutputType | null;
    _sum: ApiActivityLogSumAggregateOutputType | null;
    _min: ApiActivityLogMinAggregateOutputType | null;
    _max: ApiActivityLogMaxAggregateOutputType | null;
  };

  export type ApiActivityLogAvgAggregateOutputType = {
    statusCode: number | null;
    responseTime: number | null;
  };

  export type ApiActivityLogSumAggregateOutputType = {
    statusCode: number | null;
    responseTime: number | null;
  };

  export type ApiActivityLogMinAggregateOutputType = {
    id: string | null;
    method: string | null;
    endpoint: string | null;
    statusCode: number | null;
    responseTime: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
  };

  export type ApiActivityLogMaxAggregateOutputType = {
    id: string | null;
    method: string | null;
    endpoint: string | null;
    statusCode: number | null;
    responseTime: number | null;
    userAgent: string | null;
    ipAddress: string | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
  };

  export type ApiActivityLogCountAggregateOutputType = {
    id: number;
    method: number;
    endpoint: number;
    statusCode: number;
    responseTime: number;
    requestBody: number;
    responseBody: number;
    userAgent: number;
    ipAddress: number;
    userId: number;
    organizationId: number;
    createdAt: number;
    _all: number;
  };

  export type ApiActivityLogAvgAggregateInputType = {
    statusCode?: true;
    responseTime?: true;
  };

  export type ApiActivityLogSumAggregateInputType = {
    statusCode?: true;
    responseTime?: true;
  };

  export type ApiActivityLogMinAggregateInputType = {
    id?: true;
    method?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    userAgent?: true;
    ipAddress?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
  };

  export type ApiActivityLogMaxAggregateInputType = {
    id?: true;
    method?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    userAgent?: true;
    ipAddress?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
  };

  export type ApiActivityLogCountAggregateInputType = {
    id?: true;
    method?: true;
    endpoint?: true;
    statusCode?: true;
    responseTime?: true;
    requestBody?: true;
    responseBody?: true;
    userAgent?: true;
    ipAddress?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ApiActivityLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiActivityLog to aggregate.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApiActivityLogs
     **/
    _count?: true | ApiActivityLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ApiActivityLogAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ApiActivityLogSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApiActivityLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApiActivityLogMaxAggregateInputType;
  };

  export type GetApiActivityLogAggregateType<T extends ApiActivityLogAggregateArgs> = {
    [P in keyof T & keyof AggregateApiActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiActivityLog[P]>
      : GetScalarType<T[P], AggregateApiActivityLog[P]>;
  };

  export type ApiActivityLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiActivityLogWhereInput;
    orderBy?:
      | ApiActivityLogOrderByWithAggregationInput
      | ApiActivityLogOrderByWithAggregationInput[];
    by: ApiActivityLogScalarFieldEnum[] | ApiActivityLogScalarFieldEnum;
    having?: ApiActivityLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApiActivityLogCountAggregateInputType | true;
    _avg?: ApiActivityLogAvgAggregateInputType;
    _sum?: ApiActivityLogSumAggregateInputType;
    _min?: ApiActivityLogMinAggregateInputType;
    _max?: ApiActivityLogMaxAggregateInputType;
  };

  export type ApiActivityLogGroupByOutputType = {
    id: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody: JsonValue | null;
    responseBody: JsonValue | null;
    userAgent: string | null;
    ipAddress: string | null;
    userId: string;
    organizationId: string;
    createdAt: Date;
    _count: ApiActivityLogCountAggregateOutputType | null;
    _avg: ApiActivityLogAvgAggregateOutputType | null;
    _sum: ApiActivityLogSumAggregateOutputType | null;
    _min: ApiActivityLogMinAggregateOutputType | null;
    _max: ApiActivityLogMaxAggregateOutputType | null;
  };

  type GetApiActivityLogGroupByPayload<T extends ApiActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiActivityLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApiActivityLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApiActivityLogGroupByOutputType[P]>
          : GetScalarType<T[P], ApiActivityLogGroupByOutputType[P]>;
      }
    >
  >;

  export type ApiActivityLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      method?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      requestBody?: boolean;
      responseBody?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      method?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      requestBody?: boolean;
      responseBody?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      method?: boolean;
      endpoint?: boolean;
      statusCode?: boolean;
      responseTime?: boolean;
      requestBody?: boolean;
      responseBody?: boolean;
      userAgent?: boolean;
      ipAddress?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiActivityLog']
  >;

  export type ApiActivityLogSelectScalar = {
    id?: boolean;
    method?: boolean;
    endpoint?: boolean;
    statusCode?: boolean;
    responseTime?: boolean;
    requestBody?: boolean;
    responseBody?: boolean;
    userAgent?: boolean;
    ipAddress?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
  };

  export type ApiActivityLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'method'
    | 'endpoint'
    | 'statusCode'
    | 'responseTime'
    | 'requestBody'
    | 'responseBody'
    | 'userAgent'
    | 'ipAddress'
    | 'userId'
    | 'organizationId'
    | 'createdAt',
    ExtArgs['result']['apiActivityLog']
  >;
  export type ApiActivityLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ApiActivityLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ApiActivityLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ApiActivityLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ApiActivityLog';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        method: string;
        endpoint: string;
        statusCode: number;
        responseTime: number;
        requestBody: Prisma.JsonValue | null;
        responseBody: Prisma.JsonValue | null;
        userAgent: string | null;
        ipAddress: string | null;
        userId: string;
        organizationId: string;
        createdAt: Date;
      },
      ExtArgs['result']['apiActivityLog']
    >;
    composites: {};
  };

  type ApiActivityLogGetPayload<S extends boolean | null | undefined | ApiActivityLogDefaultArgs> =
    $Result.GetResult<Prisma.$ApiActivityLogPayload, S>;

  type ApiActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiActivityLogCountAggregateInputType | true;
    };

  export interface ApiActivityLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ApiActivityLog'];
      meta: { name: 'ApiActivityLog' };
    };
    /**
     * Find zero or one ApiActivityLog that matches the filter.
     * @param {ApiActivityLogFindUniqueArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiActivityLogFindUniqueArgs>(
      args: SelectSubset<T, ApiActivityLogFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ApiActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiActivityLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApiActivityLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindFirstArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiActivityLogFindFirstArgs>(
      args?: SelectSubset<T, ApiActivityLogFindFirstArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindFirstOrThrowArgs} args - Arguments to find a ApiActivityLog
     * @example
     * // Get one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiActivityLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApiActivityLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApiActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiActivityLogs
     * const apiActivityLogs = await prisma.apiActivityLog.findMany()
     *
     * // Get first 10 ApiActivityLogs
     * const apiActivityLogs = await prisma.apiActivityLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApiActivityLogFindManyArgs>(
      args?: SelectSubset<T, ApiActivityLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ApiActivityLog.
     * @param {ApiActivityLogCreateArgs} args - Arguments to create a ApiActivityLog.
     * @example
     * // Create one ApiActivityLog
     * const ApiActivityLog = await prisma.apiActivityLog.create({
     *   data: {
     *     // ... data to create a ApiActivityLog
     *   }
     * })
     *
     */
    create<T extends ApiActivityLogCreateArgs>(
      args: SelectSubset<T, ApiActivityLogCreateArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ApiActivityLogs.
     * @param {ApiActivityLogCreateManyArgs} args - Arguments to create many ApiActivityLogs.
     * @example
     * // Create many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApiActivityLogCreateManyArgs>(
      args?: SelectSubset<T, ApiActivityLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ApiActivityLogs and returns the data saved in the database.
     * @param {ApiActivityLogCreateManyAndReturnArgs} args - Arguments to create many ApiActivityLogs.
     * @example
     * // Create many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ApiActivityLogs and only return the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApiActivityLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApiActivityLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ApiActivityLog.
     * @param {ApiActivityLogDeleteArgs} args - Arguments to delete one ApiActivityLog.
     * @example
     * // Delete one ApiActivityLog
     * const ApiActivityLog = await prisma.apiActivityLog.delete({
     *   where: {
     *     // ... filter to delete one ApiActivityLog
     *   }
     * })
     *
     */
    delete<T extends ApiActivityLogDeleteArgs>(
      args: SelectSubset<T, ApiActivityLogDeleteArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ApiActivityLog.
     * @param {ApiActivityLogUpdateArgs} args - Arguments to update one ApiActivityLog.
     * @example
     * // Update one ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApiActivityLogUpdateArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ApiActivityLogs.
     * @param {ApiActivityLogDeleteManyArgs} args - Arguments to filter ApiActivityLogs to delete.
     * @example
     * // Delete a few ApiActivityLogs
     * const { count } = await prisma.apiActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApiActivityLogDeleteManyArgs>(
      args?: SelectSubset<T, ApiActivityLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApiActivityLogUpdateManyArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiActivityLogs and returns the data updated in the database.
     * @param {ApiActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ApiActivityLogs.
     * @example
     * // Update many ApiActivityLogs
     * const apiActivityLog = await prisma.apiActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ApiActivityLogs and only return the `id`
     * const apiActivityLogWithIdOnly = await prisma.apiActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApiActivityLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApiActivityLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiActivityLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ApiActivityLog.
     * @param {ApiActivityLogUpsertArgs} args - Arguments to update or create a ApiActivityLog.
     * @example
     * // Update or create a ApiActivityLog
     * const apiActivityLog = await prisma.apiActivityLog.upsert({
     *   create: {
     *     // ... data to create a ApiActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiActivityLogUpsertArgs>(
      args: SelectSubset<T, ApiActivityLogUpsertArgs<ExtArgs>>
    ): Prisma__ApiActivityLogClient<
      $Result.GetResult<Prisma.$ApiActivityLogPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ApiActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogCountArgs} args - Arguments to filter ApiActivityLogs to count.
     * @example
     * // Count the number of ApiActivityLogs
     * const count = await prisma.apiActivityLog.count({
     *   where: {
     *     // ... the filter for the ApiActivityLogs we want to count
     *   }
     * })
     **/
    count<T extends ApiActivityLogCountArgs>(
      args?: Subset<T, ApiActivityLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiActivityLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApiActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApiActivityLogAggregateArgs>(
      args: Subset<T, ApiActivityLogAggregateArgs>
    ): Prisma.PrismaPromise<GetApiActivityLogAggregateType<T>>;

    /**
     * Group by ApiActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApiActivityLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApiActivityLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetApiActivityLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApiActivityLog model
     */
    readonly fields: ApiActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiActivityLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApiActivityLog model
   */
  interface ApiActivityLogFieldRefs {
    readonly id: FieldRef<'ApiActivityLog', 'String'>;
    readonly method: FieldRef<'ApiActivityLog', 'String'>;
    readonly endpoint: FieldRef<'ApiActivityLog', 'String'>;
    readonly statusCode: FieldRef<'ApiActivityLog', 'Int'>;
    readonly responseTime: FieldRef<'ApiActivityLog', 'Int'>;
    readonly requestBody: FieldRef<'ApiActivityLog', 'Json'>;
    readonly responseBody: FieldRef<'ApiActivityLog', 'Json'>;
    readonly userAgent: FieldRef<'ApiActivityLog', 'String'>;
    readonly ipAddress: FieldRef<'ApiActivityLog', 'String'>;
    readonly userId: FieldRef<'ApiActivityLog', 'String'>;
    readonly organizationId: FieldRef<'ApiActivityLog', 'String'>;
    readonly createdAt: FieldRef<'ApiActivityLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ApiActivityLog findUnique
   */
  export type ApiActivityLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog findUniqueOrThrow
   */
  export type ApiActivityLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog findFirst
   */
  export type ApiActivityLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiActivityLogs.
     */
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog findFirstOrThrow
   */
  export type ApiActivityLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLog to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiActivityLogs.
     */
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog findMany
   */
  export type ApiActivityLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter, which ApiActivityLogs to fetch.
     */
    where?: ApiActivityLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiActivityLogs to fetch.
     */
    orderBy?: ApiActivityLogOrderByWithRelationInput | ApiActivityLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApiActivityLogs.
     */
    cursor?: ApiActivityLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiActivityLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiActivityLogs.
     */
    skip?: number;
    distinct?: ApiActivityLogScalarFieldEnum | ApiActivityLogScalarFieldEnum[];
  };

  /**
   * ApiActivityLog create
   */
  export type ApiActivityLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a ApiActivityLog.
     */
    data: XOR<ApiActivityLogCreateInput, ApiActivityLogUncheckedCreateInput>;
  };

  /**
   * ApiActivityLog createMany
   */
  export type ApiActivityLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApiActivityLogs.
     */
    data: ApiActivityLogCreateManyInput | ApiActivityLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ApiActivityLog createManyAndReturn
   */
  export type ApiActivityLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * The data used to create many ApiActivityLogs.
     */
    data: ApiActivityLogCreateManyInput | ApiActivityLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiActivityLog update
   */
  export type ApiActivityLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a ApiActivityLog.
     */
    data: XOR<ApiActivityLogUpdateInput, ApiActivityLogUncheckedUpdateInput>;
    /**
     * Choose, which ApiActivityLog to update.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog updateMany
   */
  export type ApiActivityLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApiActivityLogs.
     */
    data: XOR<ApiActivityLogUpdateManyMutationInput, ApiActivityLogUncheckedUpdateManyInput>;
    /**
     * Filter which ApiActivityLogs to update
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to update.
     */
    limit?: number;
  };

  /**
   * ApiActivityLog updateManyAndReturn
   */
  export type ApiActivityLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * The data used to update ApiActivityLogs.
     */
    data: XOR<ApiActivityLogUpdateManyMutationInput, ApiActivityLogUncheckedUpdateManyInput>;
    /**
     * Filter which ApiActivityLogs to update
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiActivityLog upsert
   */
  export type ApiActivityLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the ApiActivityLog to update in case it exists.
     */
    where: ApiActivityLogWhereUniqueInput;
    /**
     * In case the ApiActivityLog found by the `where` argument doesn't exist, create a new ApiActivityLog with this data.
     */
    create: XOR<ApiActivityLogCreateInput, ApiActivityLogUncheckedCreateInput>;
    /**
     * In case the ApiActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiActivityLogUpdateInput, ApiActivityLogUncheckedUpdateInput>;
  };

  /**
   * ApiActivityLog delete
   */
  export type ApiActivityLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
    /**
     * Filter which ApiActivityLog to delete.
     */
    where: ApiActivityLogWhereUniqueInput;
  };

  /**
   * ApiActivityLog deleteMany
   */
  export type ApiActivityLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiActivityLogs to delete
     */
    where?: ApiActivityLogWhereInput;
    /**
     * Limit how many ApiActivityLogs to delete.
     */
    limit?: number;
  };

  /**
   * ApiActivityLog without action
   */
  export type ApiActivityLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiActivityLog
     */
    select?: ApiActivityLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiActivityLog
     */
    omit?: ApiActivityLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiActivityLogInclude<ExtArgs> | null;
  };

  /**
   * Model ApiUsage
   */

  export type AggregateApiUsage = {
    _count: ApiUsageCountAggregateOutputType | null;
    _avg: ApiUsageAvgAggregateOutputType | null;
    _sum: ApiUsageSumAggregateOutputType | null;
    _min: ApiUsageMinAggregateOutputType | null;
    _max: ApiUsageMaxAggregateOutputType | null;
  };

  export type ApiUsageAvgAggregateOutputType = {
    callCount: number | null;
    totalResponseTime: number | null;
  };

  export type ApiUsageSumAggregateOutputType = {
    callCount: number | null;
    totalResponseTime: number | null;
  };

  export type ApiUsageMinAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    method: string | null;
    callCount: number | null;
    totalResponseTime: number | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ApiUsageMaxAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    method: string | null;
    callCount: number | null;
    totalResponseTime: number | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ApiUsageCountAggregateOutputType = {
    id: number;
    endpoint: number;
    method: number;
    callCount: number;
    totalResponseTime: number;
    userId: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ApiUsageAvgAggregateInputType = {
    callCount?: true;
    totalResponseTime?: true;
  };

  export type ApiUsageSumAggregateInputType = {
    callCount?: true;
    totalResponseTime?: true;
  };

  export type ApiUsageMinAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    callCount?: true;
    totalResponseTime?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ApiUsageMaxAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    callCount?: true;
    totalResponseTime?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ApiUsageCountAggregateInputType = {
    id?: true;
    endpoint?: true;
    method?: true;
    callCount?: true;
    totalResponseTime?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ApiUsageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiUsage to aggregate.
     */
    where?: ApiUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApiUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApiUsages
     **/
    _count?: true | ApiUsageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ApiUsageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ApiUsageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApiUsageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApiUsageMaxAggregateInputType;
  };

  export type GetApiUsageAggregateType<T extends ApiUsageAggregateArgs> = {
    [P in keyof T & keyof AggregateApiUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiUsage[P]>
      : GetScalarType<T[P], AggregateApiUsage[P]>;
  };

  export type ApiUsageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiUsageWhereInput;
    orderBy?: ApiUsageOrderByWithAggregationInput | ApiUsageOrderByWithAggregationInput[];
    by: ApiUsageScalarFieldEnum[] | ApiUsageScalarFieldEnum;
    having?: ApiUsageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApiUsageCountAggregateInputType | true;
    _avg?: ApiUsageAvgAggregateInputType;
    _sum?: ApiUsageSumAggregateInputType;
    _min?: ApiUsageMinAggregateInputType;
    _max?: ApiUsageMaxAggregateInputType;
  };

  export type ApiUsageGroupByOutputType = {
    id: string;
    endpoint: string;
    method: string;
    callCount: number;
    totalResponseTime: number;
    userId: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ApiUsageCountAggregateOutputType | null;
    _avg: ApiUsageAvgAggregateOutputType | null;
    _sum: ApiUsageSumAggregateOutputType | null;
    _min: ApiUsageMinAggregateOutputType | null;
    _max: ApiUsageMaxAggregateOutputType | null;
  };

  type GetApiUsageGroupByPayload<T extends ApiUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiUsageGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApiUsageGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApiUsageGroupByOutputType[P]>
          : GetScalarType<T[P], ApiUsageGroupByOutputType[P]>;
      }
    >
  >;

  export type ApiUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        endpoint?: boolean;
        method?: boolean;
        callCount?: boolean;
        totalResponseTime?: boolean;
        userId?: boolean;
        organizationId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['apiUsage']
    >;

  export type ApiUsageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      method?: boolean;
      callCount?: boolean;
      totalResponseTime?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiUsage']
  >;

  export type ApiUsageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      method?: boolean;
      callCount?: boolean;
      totalResponseTime?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiUsage']
  >;

  export type ApiUsageSelectScalar = {
    id?: boolean;
    endpoint?: boolean;
    method?: boolean;
    callCount?: boolean;
    totalResponseTime?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ApiUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'endpoint'
      | 'method'
      | 'callCount'
      | 'totalResponseTime'
      | 'userId'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['apiUsage']
    >;
  export type ApiUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | UserDefaultArgs<ExtArgs>;
    };
  export type ApiUsageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ApiUsageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ApiUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'ApiUsage';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          endpoint: string;
          method: string;
          callCount: number;
          totalResponseTime: number;
          userId: string;
          organizationId: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['apiUsage']
      >;
      composites: {};
    };

  type ApiUsageGetPayload<S extends boolean | null | undefined | ApiUsageDefaultArgs> =
    $Result.GetResult<Prisma.$ApiUsagePayload, S>;

  type ApiUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ApiUsageFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ApiUsageCountAggregateInputType | true;
  };

  export interface ApiUsageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ApiUsage'];
      meta: { name: 'ApiUsage' };
    };
    /**
     * Find zero or one ApiUsage that matches the filter.
     * @param {ApiUsageFindUniqueArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiUsageFindUniqueArgs>(
      args: SelectSubset<T, ApiUsageFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<
        Prisma.$ApiUsagePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ApiUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiUsageFindUniqueOrThrowArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiUsageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApiUsageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<
        Prisma.$ApiUsagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindFirstArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiUsageFindFirstArgs>(
      args?: SelectSubset<T, ApiUsageFindFirstArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApiUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindFirstOrThrowArgs} args - Arguments to find a ApiUsage
     * @example
     * // Get one ApiUsage
     * const apiUsage = await prisma.apiUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiUsageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApiUsageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApiUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiUsages
     * const apiUsages = await prisma.apiUsage.findMany()
     *
     * // Get first 10 ApiUsages
     * const apiUsages = await prisma.apiUsage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apiUsageWithIdOnly = await prisma.apiUsage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApiUsageFindManyArgs>(
      args?: SelectSubset<T, ApiUsageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ApiUsage.
     * @param {ApiUsageCreateArgs} args - Arguments to create a ApiUsage.
     * @example
     * // Create one ApiUsage
     * const ApiUsage = await prisma.apiUsage.create({
     *   data: {
     *     // ... data to create a ApiUsage
     *   }
     * })
     *
     */
    create<T extends ApiUsageCreateArgs>(
      args: SelectSubset<T, ApiUsageCreateArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ApiUsages.
     * @param {ApiUsageCreateManyArgs} args - Arguments to create many ApiUsages.
     * @example
     * // Create many ApiUsages
     * const apiUsage = await prisma.apiUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApiUsageCreateManyArgs>(
      args?: SelectSubset<T, ApiUsageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ApiUsages and returns the data saved in the database.
     * @param {ApiUsageCreateManyAndReturnArgs} args - Arguments to create many ApiUsages.
     * @example
     * // Create many ApiUsages
     * const apiUsage = await prisma.apiUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ApiUsages and only return the `id`
     * const apiUsageWithIdOnly = await prisma.apiUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApiUsageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApiUsageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiUsagePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ApiUsage.
     * @param {ApiUsageDeleteArgs} args - Arguments to delete one ApiUsage.
     * @example
     * // Delete one ApiUsage
     * const ApiUsage = await prisma.apiUsage.delete({
     *   where: {
     *     // ... filter to delete one ApiUsage
     *   }
     * })
     *
     */
    delete<T extends ApiUsageDeleteArgs>(
      args: SelectSubset<T, ApiUsageDeleteArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ApiUsage.
     * @param {ApiUsageUpdateArgs} args - Arguments to update one ApiUsage.
     * @example
     * // Update one ApiUsage
     * const apiUsage = await prisma.apiUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApiUsageUpdateArgs>(
      args: SelectSubset<T, ApiUsageUpdateArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ApiUsages.
     * @param {ApiUsageDeleteManyArgs} args - Arguments to filter ApiUsages to delete.
     * @example
     * // Delete a few ApiUsages
     * const { count } = await prisma.apiUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApiUsageDeleteManyArgs>(
      args?: SelectSubset<T, ApiUsageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiUsages
     * const apiUsage = await prisma.apiUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApiUsageUpdateManyArgs>(
      args: SelectSubset<T, ApiUsageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiUsages and returns the data updated in the database.
     * @param {ApiUsageUpdateManyAndReturnArgs} args - Arguments to update many ApiUsages.
     * @example
     * // Update many ApiUsages
     * const apiUsage = await prisma.apiUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ApiUsages and only return the `id`
     * const apiUsageWithIdOnly = await prisma.apiUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ApiUsageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ApiUsageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApiUsagePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ApiUsage.
     * @param {ApiUsageUpsertArgs} args - Arguments to update or create a ApiUsage.
     * @example
     * // Update or create a ApiUsage
     * const apiUsage = await prisma.apiUsage.upsert({
     *   create: {
     *     // ... data to create a ApiUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiUsage we want to update
     *   }
     * })
     */
    upsert<T extends ApiUsageUpsertArgs>(
      args: SelectSubset<T, ApiUsageUpsertArgs<ExtArgs>>
    ): Prisma__ApiUsageClient<
      $Result.GetResult<Prisma.$ApiUsagePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ApiUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageCountArgs} args - Arguments to filter ApiUsages to count.
     * @example
     * // Count the number of ApiUsages
     * const count = await prisma.apiUsage.count({
     *   where: {
     *     // ... the filter for the ApiUsages we want to count
     *   }
     * })
     **/
    count<T extends ApiUsageCountArgs>(
      args?: Subset<T, ApiUsageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiUsageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApiUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApiUsageAggregateArgs>(
      args: Subset<T, ApiUsageAggregateArgs>
    ): Prisma.PrismaPromise<GetApiUsageAggregateType<T>>;

    /**
     * Group by ApiUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApiUsageGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiUsageGroupByArgs['orderBy'] }
        : { orderBy?: ApiUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApiUsageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetApiUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApiUsage model
     */
    readonly fields: ApiUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiUsageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApiUsage model
   */
  interface ApiUsageFieldRefs {
    readonly id: FieldRef<'ApiUsage', 'String'>;
    readonly endpoint: FieldRef<'ApiUsage', 'String'>;
    readonly method: FieldRef<'ApiUsage', 'String'>;
    readonly callCount: FieldRef<'ApiUsage', 'Int'>;
    readonly totalResponseTime: FieldRef<'ApiUsage', 'Int'>;
    readonly userId: FieldRef<'ApiUsage', 'String'>;
    readonly organizationId: FieldRef<'ApiUsage', 'String'>;
    readonly createdAt: FieldRef<'ApiUsage', 'DateTime'>;
    readonly updatedAt: FieldRef<'ApiUsage', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ApiUsage findUnique
   */
  export type ApiUsageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter, which ApiUsage to fetch.
     */
    where: ApiUsageWhereUniqueInput;
  };

  /**
   * ApiUsage findUniqueOrThrow
   */
  export type ApiUsageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter, which ApiUsage to fetch.
     */
    where: ApiUsageWhereUniqueInput;
  };

  /**
   * ApiUsage findFirst
   */
  export type ApiUsageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter, which ApiUsage to fetch.
     */
    where?: ApiUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiUsages.
     */
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[];
  };

  /**
   * ApiUsage findFirstOrThrow
   */
  export type ApiUsageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter, which ApiUsage to fetch.
     */
    where?: ApiUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiUsages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiUsages.
     */
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[];
  };

  /**
   * ApiUsage findMany
   */
  export type ApiUsageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter, which ApiUsages to fetch.
     */
    where?: ApiUsageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiUsages to fetch.
     */
    orderBy?: ApiUsageOrderByWithRelationInput | ApiUsageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApiUsages.
     */
    cursor?: ApiUsageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiUsages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiUsages.
     */
    skip?: number;
    distinct?: ApiUsageScalarFieldEnum | ApiUsageScalarFieldEnum[];
  };

  /**
   * ApiUsage create
   */
  export type ApiUsageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * The data needed to create a ApiUsage.
     */
    data: XOR<ApiUsageCreateInput, ApiUsageUncheckedCreateInput>;
  };

  /**
   * ApiUsage createMany
   */
  export type ApiUsageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApiUsages.
     */
    data: ApiUsageCreateManyInput | ApiUsageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ApiUsage createManyAndReturn
   */
  export type ApiUsageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * The data used to create many ApiUsages.
     */
    data: ApiUsageCreateManyInput | ApiUsageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiUsage update
   */
  export type ApiUsageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * The data needed to update a ApiUsage.
     */
    data: XOR<ApiUsageUpdateInput, ApiUsageUncheckedUpdateInput>;
    /**
     * Choose, which ApiUsage to update.
     */
    where: ApiUsageWhereUniqueInput;
  };

  /**
   * ApiUsage updateMany
   */
  export type ApiUsageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApiUsages.
     */
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyInput>;
    /**
     * Filter which ApiUsages to update
     */
    where?: ApiUsageWhereInput;
    /**
     * Limit how many ApiUsages to update.
     */
    limit?: number;
  };

  /**
   * ApiUsage updateManyAndReturn
   */
  export type ApiUsageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * The data used to update ApiUsages.
     */
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyInput>;
    /**
     * Filter which ApiUsages to update
     */
    where?: ApiUsageWhereInput;
    /**
     * Limit how many ApiUsages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiUsage upsert
   */
  export type ApiUsageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * The filter to search for the ApiUsage to update in case it exists.
     */
    where: ApiUsageWhereUniqueInput;
    /**
     * In case the ApiUsage found by the `where` argument doesn't exist, create a new ApiUsage with this data.
     */
    create: XOR<ApiUsageCreateInput, ApiUsageUncheckedCreateInput>;
    /**
     * In case the ApiUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiUsageUpdateInput, ApiUsageUncheckedUpdateInput>;
  };

  /**
   * ApiUsage delete
   */
  export type ApiUsageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
    /**
     * Filter which ApiUsage to delete.
     */
    where: ApiUsageWhereUniqueInput;
  };

  /**
   * ApiUsage deleteMany
   */
  export type ApiUsageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiUsages to delete
     */
    where?: ApiUsageWhereInput;
    /**
     * Limit how many ApiUsages to delete.
     */
    limit?: number;
  };

  /**
   * ApiUsage without action
   */
  export type ApiUsageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiUsage
     */
    select?: ApiUsageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApiUsage
     */
    omit?: ApiUsageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    isRead: boolean | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    isRead: boolean | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    title: number;
    message: number;
    type: number;
    isRead: number;
    data: number;
    userId: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    title?: true;
    message?: true;
    type?: true;
    isRead?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    title?: true;
    message?: true;
    type?: true;
    isRead?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    title?: true;
    message?: true;
    type?: true;
    isRead?: true;
    data?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    title: string;
    message: string;
    type: string;
    isRead: boolean;
    data: JsonValue | null;
    userId: string;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      isRead?: boolean;
      data?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      isRead?: boolean;
      data?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      isRead?: boolean;
      data?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    title?: boolean;
    message?: boolean;
    type?: boolean;
    isRead?: boolean;
    data?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'title'
      | 'message'
      | 'type'
      | 'isRead'
      | 'data'
      | 'userId'
      | 'organizationId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['notification']
    >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        message: string;
        type: string;
        isRead: boolean;
        data: Prisma.JsonValue | null;
        userId: string;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> =
    $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true;
    };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'String'>;
    readonly isRead: FieldRef<'Notification', 'Boolean'>;
    readonly data: FieldRef<'Notification', 'Json'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly organizationId: FieldRef<'Notification', 'String'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
    readonly updatedAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model UserLog
   */

  export type AggregateUserLog = {
    _count: UserLogCountAggregateOutputType | null;
    _min: UserLogMinAggregateOutputType | null;
    _max: UserLogMaxAggregateOutputType | null;
  };

  export type UserLogMinAggregateOutputType = {
    id: string | null;
    action: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
  };

  export type UserLogMaxAggregateOutputType = {
    id: string | null;
    action: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
    organizationId: string | null;
    createdAt: Date | null;
  };

  export type UserLogCountAggregateOutputType = {
    id: number;
    action: number;
    details: number;
    ipAddress: number;
    userAgent: number;
    userId: number;
    organizationId: number;
    createdAt: number;
    _all: number;
  };

  export type UserLogMinAggregateInputType = {
    id?: true;
    action?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
  };

  export type UserLogMaxAggregateInputType = {
    id?: true;
    action?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
  };

  export type UserLogCountAggregateInputType = {
    id?: true;
    action?: true;
    details?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
    organizationId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserLog to aggregate.
     */
    where?: UserLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserLogs
     **/
    _count?: true | UserLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserLogMaxAggregateInputType;
  };

  export type GetUserLogAggregateType<T extends UserLogAggregateArgs> = {
    [P in keyof T & keyof AggregateUserLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLog[P]>
      : GetScalarType<T[P], AggregateUserLog[P]>;
  };

  export type UserLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserLogWhereInput;
    orderBy?: UserLogOrderByWithAggregationInput | UserLogOrderByWithAggregationInput[];
    by: UserLogScalarFieldEnum[] | UserLogScalarFieldEnum;
    having?: UserLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserLogCountAggregateInputType | true;
    _min?: UserLogMinAggregateInputType;
    _max?: UserLogMaxAggregateInputType;
  };

  export type UserLogGroupByOutputType = {
    id: string;
    action: string;
    details: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string;
    organizationId: string;
    createdAt: Date;
    _count: UserLogCountAggregateOutputType | null;
    _min: UserLogMinAggregateOutputType | null;
    _max: UserLogMaxAggregateOutputType | null;
  };

  type GetUserLogGroupByPayload<T extends UserLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserLogGroupByOutputType[P]>
          : GetScalarType<T[P], UserLogGroupByOutputType[P]>;
      }
    >
  >;

  export type UserLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        action?: boolean;
        details?: boolean;
        ipAddress?: boolean;
        userAgent?: boolean;
        userId?: boolean;
        organizationId?: boolean;
        createdAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['userLog']
    >;

  export type UserLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      details?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userLog']
  >;

  export type UserLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      details?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      userId?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userLog']
  >;

  export type UserLogSelectScalar = {
    id?: boolean;
    action?: boolean;
    details?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
  };

  export type UserLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'action'
      | 'details'
      | 'ipAddress'
      | 'userAgent'
      | 'userId'
      | 'organizationId'
      | 'createdAt',
      ExtArgs['result']['userLog']
    >;
  export type UserLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type UserLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $UserLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'UserLog';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          action: string;
          details: Prisma.JsonValue | null;
          ipAddress: string | null;
          userAgent: string | null;
          userId: string;
          organizationId: string;
          createdAt: Date;
        },
        ExtArgs['result']['userLog']
      >;
      composites: {};
    };

  type UserLogGetPayload<S extends boolean | null | undefined | UserLogDefaultArgs> =
    $Result.GetResult<Prisma.$UserLogPayload, S>;

  type UserLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserLogFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserLogCountAggregateInputType | true;
  };

  export interface UserLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLog']; meta: { name: 'UserLog' } };
    /**
     * Find zero or one UserLog that matches the filter.
     * @param {UserLogFindUniqueArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLogFindUniqueArgs>(
      args: SelectSubset<T, UserLogFindUniqueArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLogFindUniqueOrThrowArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindFirstArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLogFindFirstArgs>(
      args?: SelectSubset<T, UserLogFindFirstArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindFirstOrThrowArgs} args - Arguments to find a UserLog
     * @example
     * // Get one UserLog
     * const userLog = await prisma.userLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLogs
     * const userLogs = await prisma.userLog.findMany()
     *
     * // Get first 10 UserLogs
     * const userLogs = await prisma.userLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userLogWithIdOnly = await prisma.userLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserLogFindManyArgs>(
      args?: SelectSubset<T, UserLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a UserLog.
     * @param {UserLogCreateArgs} args - Arguments to create a UserLog.
     * @example
     * // Create one UserLog
     * const UserLog = await prisma.userLog.create({
     *   data: {
     *     // ... data to create a UserLog
     *   }
     * })
     *
     */
    create<T extends UserLogCreateArgs>(
      args: SelectSubset<T, UserLogCreateArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserLogs.
     * @param {UserLogCreateManyArgs} args - Arguments to create many UserLogs.
     * @example
     * // Create many UserLogs
     * const userLog = await prisma.userLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserLogCreateManyArgs>(
      args?: SelectSubset<T, UserLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserLogs and returns the data saved in the database.
     * @param {UserLogCreateManyAndReturnArgs} args - Arguments to create many UserLogs.
     * @example
     * // Create many UserLogs
     * const userLog = await prisma.userLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserLogs and only return the `id`
     * const userLogWithIdOnly = await prisma.userLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserLog.
     * @param {UserLogDeleteArgs} args - Arguments to delete one UserLog.
     * @example
     * // Delete one UserLog
     * const UserLog = await prisma.userLog.delete({
     *   where: {
     *     // ... filter to delete one UserLog
     *   }
     * })
     *
     */
    delete<T extends UserLogDeleteArgs>(
      args: SelectSubset<T, UserLogDeleteArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserLog.
     * @param {UserLogUpdateArgs} args - Arguments to update one UserLog.
     * @example
     * // Update one UserLog
     * const userLog = await prisma.userLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserLogUpdateArgs>(
      args: SelectSubset<T, UserLogUpdateArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserLogs.
     * @param {UserLogDeleteManyArgs} args - Arguments to filter UserLogs to delete.
     * @example
     * // Delete a few UserLogs
     * const { count } = await prisma.userLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserLogDeleteManyArgs>(
      args?: SelectSubset<T, UserLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLogs
     * const userLog = await prisma.userLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserLogUpdateManyArgs>(
      args: SelectSubset<T, UserLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserLogs and returns the data updated in the database.
     * @param {UserLogUpdateManyAndReturnArgs} args - Arguments to update many UserLogs.
     * @example
     * // Update many UserLogs
     * const userLog = await prisma.userLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserLogs and only return the `id`
     * const userLogWithIdOnly = await prisma.userLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserLog.
     * @param {UserLogUpsertArgs} args - Arguments to update or create a UserLog.
     * @example
     * // Update or create a UserLog
     * const userLog = await prisma.userLog.upsert({
     *   create: {
     *     // ... data to create a UserLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLog we want to update
     *   }
     * })
     */
    upsert<T extends UserLogUpsertArgs>(
      args: SelectSubset<T, UserLogUpsertArgs<ExtArgs>>
    ): Prisma__UserLogClient<
      $Result.GetResult<Prisma.$UserLogPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogCountArgs} args - Arguments to filter UserLogs to count.
     * @example
     * // Count the number of UserLogs
     * const count = await prisma.userLog.count({
     *   where: {
     *     // ... the filter for the UserLogs we want to count
     *   }
     * })
     **/
    count<T extends UserLogCountArgs>(
      args?: Subset<T, UserLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserLogAggregateArgs>(
      args: Subset<T, UserLogAggregateArgs>
    ): Prisma.PrismaPromise<GetUserLogAggregateType<T>>;

    /**
     * Group by UserLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLogGroupByArgs['orderBy'] }
        : { orderBy?: UserLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserLog model
     */
    readonly fields: UserLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserLog model
   */
  interface UserLogFieldRefs {
    readonly id: FieldRef<'UserLog', 'String'>;
    readonly action: FieldRef<'UserLog', 'String'>;
    readonly details: FieldRef<'UserLog', 'Json'>;
    readonly ipAddress: FieldRef<'UserLog', 'String'>;
    readonly userAgent: FieldRef<'UserLog', 'String'>;
    readonly userId: FieldRef<'UserLog', 'String'>;
    readonly organizationId: FieldRef<'UserLog', 'String'>;
    readonly createdAt: FieldRef<'UserLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserLog findUnique
   */
  export type UserLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter, which UserLog to fetch.
     */
    where: UserLogWhereUniqueInput;
  };

  /**
   * UserLog findUniqueOrThrow
   */
  export type UserLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter, which UserLog to fetch.
     */
    where: UserLogWhereUniqueInput;
  };

  /**
   * UserLog findFirst
   */
  export type UserLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter, which UserLog to fetch.
     */
    where?: UserLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserLogs.
     */
    cursor?: UserLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserLogs.
     */
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[];
  };

  /**
   * UserLog findFirstOrThrow
   */
  export type UserLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter, which UserLog to fetch.
     */
    where?: UserLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserLogs.
     */
    cursor?: UserLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserLogs.
     */
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[];
  };

  /**
   * UserLog findMany
   */
  export type UserLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter, which UserLogs to fetch.
     */
    where?: UserLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserLogs to fetch.
     */
    orderBy?: UserLogOrderByWithRelationInput | UserLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserLogs.
     */
    cursor?: UserLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserLogs.
     */
    skip?: number;
    distinct?: UserLogScalarFieldEnum | UserLogScalarFieldEnum[];
  };

  /**
   * UserLog create
   */
  export type UserLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserLog.
     */
    data: XOR<UserLogCreateInput, UserLogUncheckedCreateInput>;
  };

  /**
   * UserLog createMany
   */
  export type UserLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserLogs.
     */
    data: UserLogCreateManyInput | UserLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserLog createManyAndReturn
   */
  export type UserLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * The data used to create many UserLogs.
     */
    data: UserLogCreateManyInput | UserLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserLog update
   */
  export type UserLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserLog.
     */
    data: XOR<UserLogUpdateInput, UserLogUncheckedUpdateInput>;
    /**
     * Choose, which UserLog to update.
     */
    where: UserLogWhereUniqueInput;
  };

  /**
   * UserLog updateMany
   */
  export type UserLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserLogs.
     */
    data: XOR<UserLogUpdateManyMutationInput, UserLogUncheckedUpdateManyInput>;
    /**
     * Filter which UserLogs to update
     */
    where?: UserLogWhereInput;
    /**
     * Limit how many UserLogs to update.
     */
    limit?: number;
  };

  /**
   * UserLog updateManyAndReturn
   */
  export type UserLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * The data used to update UserLogs.
     */
    data: XOR<UserLogUpdateManyMutationInput, UserLogUncheckedUpdateManyInput>;
    /**
     * Filter which UserLogs to update
     */
    where?: UserLogWhereInput;
    /**
     * Limit how many UserLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserLog upsert
   */
  export type UserLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserLog to update in case it exists.
     */
    where: UserLogWhereUniqueInput;
    /**
     * In case the UserLog found by the `where` argument doesn't exist, create a new UserLog with this data.
     */
    create: XOR<UserLogCreateInput, UserLogUncheckedCreateInput>;
    /**
     * In case the UserLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLogUpdateInput, UserLogUncheckedUpdateInput>;
  };

  /**
   * UserLog delete
   */
  export type UserLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
    /**
     * Filter which UserLog to delete.
     */
    where: UserLogWhereUniqueInput;
  };

  /**
   * UserLog deleteMany
   */
  export type UserLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserLogs to delete
     */
    where?: UserLogWhereInput;
    /**
     * Limit how many UserLogs to delete.
     */
    limit?: number;
  };

  /**
   * UserLog without action
   */
  export type UserLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserLog
     */
    select?: UserLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserLog
     */
    omit?: UserLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLogInclude<ExtArgs> | null;
  };

  /**
   * Model DatabaseObject
   */

  export type AggregateDatabaseObject = {
    _count: DatabaseObjectCountAggregateOutputType | null;
    _min: DatabaseObjectMinAggregateOutputType | null;
    _max: DatabaseObjectMaxAggregateOutputType | null;
  };

  export type DatabaseObjectMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    schema: string | null;
    definition: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DatabaseObjectMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    schema: string | null;
    definition: string | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DatabaseObjectCountAggregateOutputType = {
    id: number;
    name: number;
    type: number;
    schema: number;
    definition: number;
    metadata: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type DatabaseObjectMinAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    schema?: true;
    definition?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DatabaseObjectMaxAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    schema?: true;
    definition?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DatabaseObjectCountAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    schema?: true;
    definition?: true;
    metadata?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type DatabaseObjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseObject to aggregate.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DatabaseObjects
     **/
    _count?: true | DatabaseObjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DatabaseObjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DatabaseObjectMaxAggregateInputType;
  };

  export type GetDatabaseObjectAggregateType<T extends DatabaseObjectAggregateArgs> = {
    [P in keyof T & keyof AggregateDatabaseObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseObject[P]>
      : GetScalarType<T[P], AggregateDatabaseObject[P]>;
  };

  export type DatabaseObjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DatabaseObjectWhereInput;
    orderBy?:
      | DatabaseObjectOrderByWithAggregationInput
      | DatabaseObjectOrderByWithAggregationInput[];
    by: DatabaseObjectScalarFieldEnum[] | DatabaseObjectScalarFieldEnum;
    having?: DatabaseObjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DatabaseObjectCountAggregateInputType | true;
    _min?: DatabaseObjectMinAggregateInputType;
    _max?: DatabaseObjectMaxAggregateInputType;
  };

  export type DatabaseObjectGroupByOutputType = {
    id: string;
    name: string;
    type: string;
    schema: string | null;
    definition: string | null;
    metadata: JsonValue | null;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: DatabaseObjectCountAggregateOutputType | null;
    _min: DatabaseObjectMinAggregateOutputType | null;
    _max: DatabaseObjectMaxAggregateOutputType | null;
  };

  type GetDatabaseObjectGroupByPayload<T extends DatabaseObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseObjectGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DatabaseObjectGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DatabaseObjectGroupByOutputType[P]>
          : GetScalarType<T[P], DatabaseObjectGroupByOutputType[P]>;
      }
    >
  >;

  export type DatabaseObjectSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      schema?: boolean;
      definition?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      schema?: boolean;
      definition?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      schema?: boolean;
      definition?: boolean;
      metadata?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['databaseObject']
  >;

  export type DatabaseObjectSelectScalar = {
    id?: boolean;
    name?: boolean;
    type?: boolean;
    schema?: boolean;
    definition?: boolean;
    metadata?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type DatabaseObjectOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'type'
    | 'schema'
    | 'definition'
    | 'metadata'
    | 'organizationId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['databaseObject']
  >;

  export type $DatabaseObjectPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DatabaseObject';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        type: string;
        schema: string | null;
        definition: string | null;
        metadata: Prisma.JsonValue | null;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['databaseObject']
    >;
    composites: {};
  };

  type DatabaseObjectGetPayload<S extends boolean | null | undefined | DatabaseObjectDefaultArgs> =
    $Result.GetResult<Prisma.$DatabaseObjectPayload, S>;

  type DatabaseObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseObjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseObjectCountAggregateInputType | true;
    };

  export interface DatabaseObjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DatabaseObject'];
      meta: { name: 'DatabaseObject' };
    };
    /**
     * Find zero or one DatabaseObject that matches the filter.
     * @param {DatabaseObjectFindUniqueArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseObjectFindUniqueArgs>(
      args: SelectSubset<T, DatabaseObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DatabaseObject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseObjectFindUniqueOrThrowArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseObjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DatabaseObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindFirstArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseObjectFindFirstArgs>(
      args?: SelectSubset<T, DatabaseObjectFindFirstArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DatabaseObject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindFirstOrThrowArgs} args - Arguments to find a DatabaseObject
     * @example
     * // Get one DatabaseObject
     * const databaseObject = await prisma.databaseObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseObjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DatabaseObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DatabaseObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseObjects
     * const databaseObjects = await prisma.databaseObject.findMany()
     *
     * // Get first 10 DatabaseObjects
     * const databaseObjects = await prisma.databaseObject.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DatabaseObjectFindManyArgs>(
      args?: SelectSubset<T, DatabaseObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a DatabaseObject.
     * @param {DatabaseObjectCreateArgs} args - Arguments to create a DatabaseObject.
     * @example
     * // Create one DatabaseObject
     * const DatabaseObject = await prisma.databaseObject.create({
     *   data: {
     *     // ... data to create a DatabaseObject
     *   }
     * })
     *
     */
    create<T extends DatabaseObjectCreateArgs>(
      args: SelectSubset<T, DatabaseObjectCreateArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DatabaseObjects.
     * @param {DatabaseObjectCreateManyArgs} args - Arguments to create many DatabaseObjects.
     * @example
     * // Create many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DatabaseObjectCreateManyArgs>(
      args?: SelectSubset<T, DatabaseObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DatabaseObjects and returns the data saved in the database.
     * @param {DatabaseObjectCreateManyAndReturnArgs} args - Arguments to create many DatabaseObjects.
     * @example
     * // Create many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DatabaseObjects and only return the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DatabaseObjectCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DatabaseObjectCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DatabaseObject.
     * @param {DatabaseObjectDeleteArgs} args - Arguments to delete one DatabaseObject.
     * @example
     * // Delete one DatabaseObject
     * const DatabaseObject = await prisma.databaseObject.delete({
     *   where: {
     *     // ... filter to delete one DatabaseObject
     *   }
     * })
     *
     */
    delete<T extends DatabaseObjectDeleteArgs>(
      args: SelectSubset<T, DatabaseObjectDeleteArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DatabaseObject.
     * @param {DatabaseObjectUpdateArgs} args - Arguments to update one DatabaseObject.
     * @example
     * // Update one DatabaseObject
     * const databaseObject = await prisma.databaseObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DatabaseObjectUpdateArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DatabaseObjects.
     * @param {DatabaseObjectDeleteManyArgs} args - Arguments to filter DatabaseObjects to delete.
     * @example
     * // Delete a few DatabaseObjects
     * const { count } = await prisma.databaseObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DatabaseObjectDeleteManyArgs>(
      args?: SelectSubset<T, DatabaseObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DatabaseObjectUpdateManyArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DatabaseObjects and returns the data updated in the database.
     * @param {DatabaseObjectUpdateManyAndReturnArgs} args - Arguments to update many DatabaseObjects.
     * @example
     * // Update many DatabaseObjects
     * const databaseObject = await prisma.databaseObject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DatabaseObjects and only return the `id`
     * const databaseObjectWithIdOnly = await prisma.databaseObject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DatabaseObjectUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DatabaseObjectUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DatabaseObjectPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DatabaseObject.
     * @param {DatabaseObjectUpsertArgs} args - Arguments to update or create a DatabaseObject.
     * @example
     * // Update or create a DatabaseObject
     * const databaseObject = await prisma.databaseObject.upsert({
     *   create: {
     *     // ... data to create a DatabaseObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseObject we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseObjectUpsertArgs>(
      args: SelectSubset<T, DatabaseObjectUpsertArgs<ExtArgs>>
    ): Prisma__DatabaseObjectClient<
      $Result.GetResult<Prisma.$DatabaseObjectPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DatabaseObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectCountArgs} args - Arguments to filter DatabaseObjects to count.
     * @example
     * // Count the number of DatabaseObjects
     * const count = await prisma.databaseObject.count({
     *   where: {
     *     // ... the filter for the DatabaseObjects we want to count
     *   }
     * })
     **/
    count<T extends DatabaseObjectCountArgs>(
      args?: Subset<T, DatabaseObjectCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseObjectCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DatabaseObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DatabaseObjectAggregateArgs>(
      args: Subset<T, DatabaseObjectAggregateArgs>
    ): Prisma.PrismaPromise<GetDatabaseObjectAggregateType<T>>;

    /**
     * Group by DatabaseObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DatabaseObjectGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseObjectGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DatabaseObjectGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDatabaseObjectGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DatabaseObject model
     */
    readonly fields: DatabaseObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseObjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DatabaseObject model
   */
  interface DatabaseObjectFieldRefs {
    readonly id: FieldRef<'DatabaseObject', 'String'>;
    readonly name: FieldRef<'DatabaseObject', 'String'>;
    readonly type: FieldRef<'DatabaseObject', 'String'>;
    readonly schema: FieldRef<'DatabaseObject', 'String'>;
    readonly definition: FieldRef<'DatabaseObject', 'String'>;
    readonly metadata: FieldRef<'DatabaseObject', 'Json'>;
    readonly organizationId: FieldRef<'DatabaseObject', 'String'>;
    readonly createdAt: FieldRef<'DatabaseObject', 'DateTime'>;
    readonly updatedAt: FieldRef<'DatabaseObject', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * DatabaseObject findUnique
   */
  export type DatabaseObjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject findUniqueOrThrow
   */
  export type DatabaseObjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject findFirst
   */
  export type DatabaseObjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseObjects.
     */
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject findFirstOrThrow
   */
  export type DatabaseObjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter, which DatabaseObject to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DatabaseObjects.
     */
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject findMany
   */
  export type DatabaseObjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter, which DatabaseObjects to fetch.
     */
    where?: DatabaseObjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DatabaseObjects to fetch.
     */
    orderBy?: DatabaseObjectOrderByWithRelationInput | DatabaseObjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DatabaseObjects.
     */
    cursor?: DatabaseObjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DatabaseObjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DatabaseObjects.
     */
    skip?: number;
    distinct?: DatabaseObjectScalarFieldEnum | DatabaseObjectScalarFieldEnum[];
  };

  /**
   * DatabaseObject create
   */
  export type DatabaseObjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data needed to create a DatabaseObject.
     */
    data: XOR<DatabaseObjectCreateInput, DatabaseObjectUncheckedCreateInput>;
  };

  /**
   * DatabaseObject createMany
   */
  export type DatabaseObjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DatabaseObjects.
     */
    data: DatabaseObjectCreateManyInput | DatabaseObjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DatabaseObject createManyAndReturn
   */
  export type DatabaseObjectCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data used to create many DatabaseObjects.
     */
    data: DatabaseObjectCreateManyInput | DatabaseObjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DatabaseObject update
   */
  export type DatabaseObjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data needed to update a DatabaseObject.
     */
    data: XOR<DatabaseObjectUpdateInput, DatabaseObjectUncheckedUpdateInput>;
    /**
     * Choose, which DatabaseObject to update.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject updateMany
   */
  export type DatabaseObjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DatabaseObjects.
     */
    data: XOR<DatabaseObjectUpdateManyMutationInput, DatabaseObjectUncheckedUpdateManyInput>;
    /**
     * Filter which DatabaseObjects to update
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to update.
     */
    limit?: number;
  };

  /**
   * DatabaseObject updateManyAndReturn
   */
  export type DatabaseObjectUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The data used to update DatabaseObjects.
     */
    data: XOR<DatabaseObjectUpdateManyMutationInput, DatabaseObjectUncheckedUpdateManyInput>;
    /**
     * Filter which DatabaseObjects to update
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to update.
     */
    limit?: number;
  };

  /**
   * DatabaseObject upsert
   */
  export type DatabaseObjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * The filter to search for the DatabaseObject to update in case it exists.
     */
    where: DatabaseObjectWhereUniqueInput;
    /**
     * In case the DatabaseObject found by the `where` argument doesn't exist, create a new DatabaseObject with this data.
     */
    create: XOR<DatabaseObjectCreateInput, DatabaseObjectUncheckedCreateInput>;
    /**
     * In case the DatabaseObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseObjectUpdateInput, DatabaseObjectUncheckedUpdateInput>;
  };

  /**
   * DatabaseObject delete
   */
  export type DatabaseObjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
    /**
     * Filter which DatabaseObject to delete.
     */
    where: DatabaseObjectWhereUniqueInput;
  };

  /**
   * DatabaseObject deleteMany
   */
  export type DatabaseObjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DatabaseObjects to delete
     */
    where?: DatabaseObjectWhereInput;
    /**
     * Limit how many DatabaseObjects to delete.
     */
    limit?: number;
  };

  /**
   * DatabaseObject without action
   */
  export type DatabaseObjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DatabaseObject
     */
    select?: DatabaseObjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DatabaseObject
     */
    omit?: DatabaseObjectOmit<ExtArgs> | null;
  };

  /**
   * Model SchemaIntelligence
   */

  export type AggregateSchemaIntelligence = {
    _count: SchemaIntelligenceCountAggregateOutputType | null;
    _avg: SchemaIntelligenceAvgAggregateOutputType | null;
    _sum: SchemaIntelligenceSumAggregateOutputType | null;
    _min: SchemaIntelligenceMinAggregateOutputType | null;
    _max: SchemaIntelligenceMaxAggregateOutputType | null;
  };

  export type SchemaIntelligenceAvgAggregateOutputType = {
    confidence: number | null;
  };

  export type SchemaIntelligenceSumAggregateOutputType = {
    confidence: number | null;
  };

  export type SchemaIntelligenceMinAggregateOutputType = {
    id: string | null;
    entityName: string | null;
    entityType: string | null;
    confidence: number | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SchemaIntelligenceMaxAggregateOutputType = {
    id: string | null;
    entityName: string | null;
    entityType: string | null;
    confidence: number | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SchemaIntelligenceCountAggregateOutputType = {
    id: number;
    entityName: number;
    entityType: number;
    confidence: number;
    analysis: number;
    procedures: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SchemaIntelligenceAvgAggregateInputType = {
    confidence?: true;
  };

  export type SchemaIntelligenceSumAggregateInputType = {
    confidence?: true;
  };

  export type SchemaIntelligenceMinAggregateInputType = {
    id?: true;
    entityName?: true;
    entityType?: true;
    confidence?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SchemaIntelligenceMaxAggregateInputType = {
    id?: true;
    entityName?: true;
    entityType?: true;
    confidence?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SchemaIntelligenceCountAggregateInputType = {
    id?: true;
    entityName?: true;
    entityType?: true;
    confidence?: true;
    analysis?: true;
    procedures?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SchemaIntelligenceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SchemaIntelligence to aggregate.
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SchemaIntelligences to fetch.
     */
    orderBy?:
      | SchemaIntelligenceOrderByWithRelationInput
      | SchemaIntelligenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SchemaIntelligenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SchemaIntelligences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SchemaIntelligences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SchemaIntelligences
     **/
    _count?: true | SchemaIntelligenceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SchemaIntelligenceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SchemaIntelligenceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SchemaIntelligenceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SchemaIntelligenceMaxAggregateInputType;
  };

  export type GetSchemaIntelligenceAggregateType<T extends SchemaIntelligenceAggregateArgs> = {
    [P in keyof T & keyof AggregateSchemaIntelligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchemaIntelligence[P]>
      : GetScalarType<T[P], AggregateSchemaIntelligence[P]>;
  };

  export type SchemaIntelligenceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SchemaIntelligenceWhereInput;
    orderBy?:
      | SchemaIntelligenceOrderByWithAggregationInput
      | SchemaIntelligenceOrderByWithAggregationInput[];
    by: SchemaIntelligenceScalarFieldEnum[] | SchemaIntelligenceScalarFieldEnum;
    having?: SchemaIntelligenceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SchemaIntelligenceCountAggregateInputType | true;
    _avg?: SchemaIntelligenceAvgAggregateInputType;
    _sum?: SchemaIntelligenceSumAggregateInputType;
    _min?: SchemaIntelligenceMinAggregateInputType;
    _max?: SchemaIntelligenceMaxAggregateInputType;
  };

  export type SchemaIntelligenceGroupByOutputType = {
    id: string;
    entityName: string;
    entityType: string;
    confidence: number;
    analysis: JsonValue;
    procedures: JsonValue;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: SchemaIntelligenceCountAggregateOutputType | null;
    _avg: SchemaIntelligenceAvgAggregateOutputType | null;
    _sum: SchemaIntelligenceSumAggregateOutputType | null;
    _min: SchemaIntelligenceMinAggregateOutputType | null;
    _max: SchemaIntelligenceMaxAggregateOutputType | null;
  };

  type GetSchemaIntelligenceGroupByPayload<T extends SchemaIntelligenceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SchemaIntelligenceGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SchemaIntelligenceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchemaIntelligenceGroupByOutputType[P]>
            : GetScalarType<T[P], SchemaIntelligenceGroupByOutputType[P]>;
        }
      >
    >;

  export type SchemaIntelligenceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityName?: boolean;
      entityType?: boolean;
      confidence?: boolean;
      analysis?: boolean;
      procedures?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['schemaIntelligence']
  >;

  export type SchemaIntelligenceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityName?: boolean;
      entityType?: boolean;
      confidence?: boolean;
      analysis?: boolean;
      procedures?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['schemaIntelligence']
  >;

  export type SchemaIntelligenceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityName?: boolean;
      entityType?: boolean;
      confidence?: boolean;
      analysis?: boolean;
      procedures?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['schemaIntelligence']
  >;

  export type SchemaIntelligenceSelectScalar = {
    id?: boolean;
    entityName?: boolean;
    entityType?: boolean;
    confidence?: boolean;
    analysis?: boolean;
    procedures?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SchemaIntelligenceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'entityName'
    | 'entityType'
    | 'confidence'
    | 'analysis'
    | 'procedures'
    | 'organizationId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['schemaIntelligence']
  >;

  export type $SchemaIntelligencePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SchemaIntelligence';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        entityName: string;
        entityType: string;
        confidence: number;
        analysis: Prisma.JsonValue;
        procedures: Prisma.JsonValue;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['schemaIntelligence']
    >;
    composites: {};
  };

  type SchemaIntelligenceGetPayload<
    S extends boolean | null | undefined | SchemaIntelligenceDefaultArgs,
  > = $Result.GetResult<Prisma.$SchemaIntelligencePayload, S>;

  type SchemaIntelligenceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SchemaIntelligenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SchemaIntelligenceCountAggregateInputType | true;
  };

  export interface SchemaIntelligenceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SchemaIntelligence'];
      meta: { name: 'SchemaIntelligence' };
    };
    /**
     * Find zero or one SchemaIntelligence that matches the filter.
     * @param {SchemaIntelligenceFindUniqueArgs} args - Arguments to find a SchemaIntelligence
     * @example
     * // Get one SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchemaIntelligenceFindUniqueArgs>(
      args: SelectSubset<T, SchemaIntelligenceFindUniqueArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SchemaIntelligence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchemaIntelligenceFindUniqueOrThrowArgs} args - Arguments to find a SchemaIntelligence
     * @example
     * // Get one SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchemaIntelligenceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SchemaIntelligenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SchemaIntelligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceFindFirstArgs} args - Arguments to find a SchemaIntelligence
     * @example
     * // Get one SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchemaIntelligenceFindFirstArgs>(
      args?: SelectSubset<T, SchemaIntelligenceFindFirstArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SchemaIntelligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceFindFirstOrThrowArgs} args - Arguments to find a SchemaIntelligence
     * @example
     * // Get one SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchemaIntelligenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SchemaIntelligenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SchemaIntelligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchemaIntelligences
     * const schemaIntelligences = await prisma.schemaIntelligence.findMany()
     *
     * // Get first 10 SchemaIntelligences
     * const schemaIntelligences = await prisma.schemaIntelligence.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const schemaIntelligenceWithIdOnly = await prisma.schemaIntelligence.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SchemaIntelligenceFindManyArgs>(
      args?: SelectSubset<T, SchemaIntelligenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SchemaIntelligence.
     * @param {SchemaIntelligenceCreateArgs} args - Arguments to create a SchemaIntelligence.
     * @example
     * // Create one SchemaIntelligence
     * const SchemaIntelligence = await prisma.schemaIntelligence.create({
     *   data: {
     *     // ... data to create a SchemaIntelligence
     *   }
     * })
     *
     */
    create<T extends SchemaIntelligenceCreateArgs>(
      args: SelectSubset<T, SchemaIntelligenceCreateArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<Prisma.$SchemaIntelligencePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SchemaIntelligences.
     * @param {SchemaIntelligenceCreateManyArgs} args - Arguments to create many SchemaIntelligences.
     * @example
     * // Create many SchemaIntelligences
     * const schemaIntelligence = await prisma.schemaIntelligence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SchemaIntelligenceCreateManyArgs>(
      args?: SelectSubset<T, SchemaIntelligenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SchemaIntelligences and returns the data saved in the database.
     * @param {SchemaIntelligenceCreateManyAndReturnArgs} args - Arguments to create many SchemaIntelligences.
     * @example
     * // Create many SchemaIntelligences
     * const schemaIntelligence = await prisma.schemaIntelligence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SchemaIntelligences and only return the `id`
     * const schemaIntelligenceWithIdOnly = await prisma.schemaIntelligence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SchemaIntelligenceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SchemaIntelligenceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SchemaIntelligence.
     * @param {SchemaIntelligenceDeleteArgs} args - Arguments to delete one SchemaIntelligence.
     * @example
     * // Delete one SchemaIntelligence
     * const SchemaIntelligence = await prisma.schemaIntelligence.delete({
     *   where: {
     *     // ... filter to delete one SchemaIntelligence
     *   }
     * })
     *
     */
    delete<T extends SchemaIntelligenceDeleteArgs>(
      args: SelectSubset<T, SchemaIntelligenceDeleteArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<Prisma.$SchemaIntelligencePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SchemaIntelligence.
     * @param {SchemaIntelligenceUpdateArgs} args - Arguments to update one SchemaIntelligence.
     * @example
     * // Update one SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SchemaIntelligenceUpdateArgs>(
      args: SelectSubset<T, SchemaIntelligenceUpdateArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<Prisma.$SchemaIntelligencePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SchemaIntelligences.
     * @param {SchemaIntelligenceDeleteManyArgs} args - Arguments to filter SchemaIntelligences to delete.
     * @example
     * // Delete a few SchemaIntelligences
     * const { count } = await prisma.schemaIntelligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SchemaIntelligenceDeleteManyArgs>(
      args?: SelectSubset<T, SchemaIntelligenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SchemaIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchemaIntelligences
     * const schemaIntelligence = await prisma.schemaIntelligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SchemaIntelligenceUpdateManyArgs>(
      args: SelectSubset<T, SchemaIntelligenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SchemaIntelligences and returns the data updated in the database.
     * @param {SchemaIntelligenceUpdateManyAndReturnArgs} args - Arguments to update many SchemaIntelligences.
     * @example
     * // Update many SchemaIntelligences
     * const schemaIntelligence = await prisma.schemaIntelligence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SchemaIntelligences and only return the `id`
     * const schemaIntelligenceWithIdOnly = await prisma.schemaIntelligence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SchemaIntelligenceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SchemaIntelligenceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SchemaIntelligencePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SchemaIntelligence.
     * @param {SchemaIntelligenceUpsertArgs} args - Arguments to update or create a SchemaIntelligence.
     * @example
     * // Update or create a SchemaIntelligence
     * const schemaIntelligence = await prisma.schemaIntelligence.upsert({
     *   create: {
     *     // ... data to create a SchemaIntelligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchemaIntelligence we want to update
     *   }
     * })
     */
    upsert<T extends SchemaIntelligenceUpsertArgs>(
      args: SelectSubset<T, SchemaIntelligenceUpsertArgs<ExtArgs>>
    ): Prisma__SchemaIntelligenceClient<
      $Result.GetResult<Prisma.$SchemaIntelligencePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SchemaIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceCountArgs} args - Arguments to filter SchemaIntelligences to count.
     * @example
     * // Count the number of SchemaIntelligences
     * const count = await prisma.schemaIntelligence.count({
     *   where: {
     *     // ... the filter for the SchemaIntelligences we want to count
     *   }
     * })
     **/
    count<T extends SchemaIntelligenceCountArgs>(
      args?: Subset<T, SchemaIntelligenceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchemaIntelligenceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SchemaIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SchemaIntelligenceAggregateArgs>(
      args: Subset<T, SchemaIntelligenceAggregateArgs>
    ): Prisma.PrismaPromise<GetSchemaIntelligenceAggregateType<T>>;

    /**
     * Group by SchemaIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchemaIntelligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SchemaIntelligenceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchemaIntelligenceGroupByArgs['orderBy'] }
        : { orderBy?: SchemaIntelligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SchemaIntelligenceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSchemaIntelligenceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SchemaIntelligence model
     */
    readonly fields: SchemaIntelligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchemaIntelligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchemaIntelligenceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SchemaIntelligence model
   */
  interface SchemaIntelligenceFieldRefs {
    readonly id: FieldRef<'SchemaIntelligence', 'String'>;
    readonly entityName: FieldRef<'SchemaIntelligence', 'String'>;
    readonly entityType: FieldRef<'SchemaIntelligence', 'String'>;
    readonly confidence: FieldRef<'SchemaIntelligence', 'Float'>;
    readonly analysis: FieldRef<'SchemaIntelligence', 'Json'>;
    readonly procedures: FieldRef<'SchemaIntelligence', 'Json'>;
    readonly organizationId: FieldRef<'SchemaIntelligence', 'String'>;
    readonly createdAt: FieldRef<'SchemaIntelligence', 'DateTime'>;
    readonly updatedAt: FieldRef<'SchemaIntelligence', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SchemaIntelligence findUnique
   */
  export type SchemaIntelligenceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter, which SchemaIntelligence to fetch.
     */
    where: SchemaIntelligenceWhereUniqueInput;
  };

  /**
   * SchemaIntelligence findUniqueOrThrow
   */
  export type SchemaIntelligenceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter, which SchemaIntelligence to fetch.
     */
    where: SchemaIntelligenceWhereUniqueInput;
  };

  /**
   * SchemaIntelligence findFirst
   */
  export type SchemaIntelligenceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter, which SchemaIntelligence to fetch.
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SchemaIntelligences to fetch.
     */
    orderBy?:
      | SchemaIntelligenceOrderByWithRelationInput
      | SchemaIntelligenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SchemaIntelligences.
     */
    cursor?: SchemaIntelligenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SchemaIntelligences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SchemaIntelligences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SchemaIntelligences.
     */
    distinct?: SchemaIntelligenceScalarFieldEnum | SchemaIntelligenceScalarFieldEnum[];
  };

  /**
   * SchemaIntelligence findFirstOrThrow
   */
  export type SchemaIntelligenceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter, which SchemaIntelligence to fetch.
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SchemaIntelligences to fetch.
     */
    orderBy?:
      | SchemaIntelligenceOrderByWithRelationInput
      | SchemaIntelligenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SchemaIntelligences.
     */
    cursor?: SchemaIntelligenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SchemaIntelligences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SchemaIntelligences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SchemaIntelligences.
     */
    distinct?: SchemaIntelligenceScalarFieldEnum | SchemaIntelligenceScalarFieldEnum[];
  };

  /**
   * SchemaIntelligence findMany
   */
  export type SchemaIntelligenceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter, which SchemaIntelligences to fetch.
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SchemaIntelligences to fetch.
     */
    orderBy?:
      | SchemaIntelligenceOrderByWithRelationInput
      | SchemaIntelligenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SchemaIntelligences.
     */
    cursor?: SchemaIntelligenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SchemaIntelligences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SchemaIntelligences.
     */
    skip?: number;
    distinct?: SchemaIntelligenceScalarFieldEnum | SchemaIntelligenceScalarFieldEnum[];
  };

  /**
   * SchemaIntelligence create
   */
  export type SchemaIntelligenceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * The data needed to create a SchemaIntelligence.
     */
    data: XOR<SchemaIntelligenceCreateInput, SchemaIntelligenceUncheckedCreateInput>;
  };

  /**
   * SchemaIntelligence createMany
   */
  export type SchemaIntelligenceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SchemaIntelligences.
     */
    data: SchemaIntelligenceCreateManyInput | SchemaIntelligenceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SchemaIntelligence createManyAndReturn
   */
  export type SchemaIntelligenceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * The data used to create many SchemaIntelligences.
     */
    data: SchemaIntelligenceCreateManyInput | SchemaIntelligenceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SchemaIntelligence update
   */
  export type SchemaIntelligenceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * The data needed to update a SchemaIntelligence.
     */
    data: XOR<SchemaIntelligenceUpdateInput, SchemaIntelligenceUncheckedUpdateInput>;
    /**
     * Choose, which SchemaIntelligence to update.
     */
    where: SchemaIntelligenceWhereUniqueInput;
  };

  /**
   * SchemaIntelligence updateMany
   */
  export type SchemaIntelligenceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SchemaIntelligences.
     */
    data: XOR<
      SchemaIntelligenceUpdateManyMutationInput,
      SchemaIntelligenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which SchemaIntelligences to update
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * Limit how many SchemaIntelligences to update.
     */
    limit?: number;
  };

  /**
   * SchemaIntelligence updateManyAndReturn
   */
  export type SchemaIntelligenceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * The data used to update SchemaIntelligences.
     */
    data: XOR<
      SchemaIntelligenceUpdateManyMutationInput,
      SchemaIntelligenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which SchemaIntelligences to update
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * Limit how many SchemaIntelligences to update.
     */
    limit?: number;
  };

  /**
   * SchemaIntelligence upsert
   */
  export type SchemaIntelligenceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * The filter to search for the SchemaIntelligence to update in case it exists.
     */
    where: SchemaIntelligenceWhereUniqueInput;
    /**
     * In case the SchemaIntelligence found by the `where` argument doesn't exist, create a new SchemaIntelligence with this data.
     */
    create: XOR<SchemaIntelligenceCreateInput, SchemaIntelligenceUncheckedCreateInput>;
    /**
     * In case the SchemaIntelligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchemaIntelligenceUpdateInput, SchemaIntelligenceUncheckedUpdateInput>;
  };

  /**
   * SchemaIntelligence delete
   */
  export type SchemaIntelligenceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
    /**
     * Filter which SchemaIntelligence to delete.
     */
    where: SchemaIntelligenceWhereUniqueInput;
  };

  /**
   * SchemaIntelligence deleteMany
   */
  export type SchemaIntelligenceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SchemaIntelligences to delete
     */
    where?: SchemaIntelligenceWhereInput;
    /**
     * Limit how many SchemaIntelligences to delete.
     */
    limit?: number;
  };

  /**
   * SchemaIntelligence without action
   */
  export type SchemaIntelligenceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SchemaIntelligence
     */
    select?: SchemaIntelligenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SchemaIntelligence
     */
    omit?: SchemaIntelligenceOmit<ExtArgs> | null;
  };

  /**
   * Model GeneratedArtifact
   */

  export type AggregateGeneratedArtifact = {
    _count: GeneratedArtifactCountAggregateOutputType | null;
    _min: GeneratedArtifactMinAggregateOutputType | null;
    _max: GeneratedArtifactMaxAggregateOutputType | null;
  };

  export type GeneratedArtifactMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    content: string | null;
    isActive: boolean | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type GeneratedArtifactMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    content: string | null;
    isActive: boolean | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type GeneratedArtifactCountAggregateOutputType = {
    id: number;
    name: number;
    type: number;
    content: number;
    metadata: number;
    isActive: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type GeneratedArtifactMinAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    content?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type GeneratedArtifactMaxAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    content?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type GeneratedArtifactCountAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    content?: true;
    metadata?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type GeneratedArtifactAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GeneratedArtifact to aggregate.
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneratedArtifacts to fetch.
     */
    orderBy?:
      | GeneratedArtifactOrderByWithRelationInput
      | GeneratedArtifactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GeneratedArtifactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneratedArtifacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneratedArtifacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned GeneratedArtifacts
     **/
    _count?: true | GeneratedArtifactCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GeneratedArtifactMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GeneratedArtifactMaxAggregateInputType;
  };

  export type GetGeneratedArtifactAggregateType<T extends GeneratedArtifactAggregateArgs> = {
    [P in keyof T & keyof AggregateGeneratedArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedArtifact[P]>
      : GetScalarType<T[P], AggregateGeneratedArtifact[P]>;
  };

  export type GeneratedArtifactGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GeneratedArtifactWhereInput;
    orderBy?:
      | GeneratedArtifactOrderByWithAggregationInput
      | GeneratedArtifactOrderByWithAggregationInput[];
    by: GeneratedArtifactScalarFieldEnum[] | GeneratedArtifactScalarFieldEnum;
    having?: GeneratedArtifactScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GeneratedArtifactCountAggregateInputType | true;
    _min?: GeneratedArtifactMinAggregateInputType;
    _max?: GeneratedArtifactMaxAggregateInputType;
  };

  export type GeneratedArtifactGroupByOutputType = {
    id: string;
    name: string;
    type: string;
    content: string;
    metadata: JsonValue | null;
    isActive: boolean;
    organizationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: GeneratedArtifactCountAggregateOutputType | null;
    _min: GeneratedArtifactMinAggregateOutputType | null;
    _max: GeneratedArtifactMaxAggregateOutputType | null;
  };

  type GetGeneratedArtifactGroupByPayload<T extends GeneratedArtifactGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GeneratedArtifactGroupByOutputType, T['by']> & {
          [P in keyof T & keyof GeneratedArtifactGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedArtifactGroupByOutputType[P]>;
        }
      >
    >;

  export type GeneratedArtifactSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      content?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['generatedArtifact']
  >;

  export type GeneratedArtifactSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      content?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['generatedArtifact']
  >;

  export type GeneratedArtifactSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      content?: boolean;
      metadata?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['generatedArtifact']
  >;

  export type GeneratedArtifactSelectScalar = {
    id?: boolean;
    name?: boolean;
    type?: boolean;
    content?: boolean;
    metadata?: boolean;
    isActive?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type GeneratedArtifactOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'type'
    | 'content'
    | 'metadata'
    | 'isActive'
    | 'organizationId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['generatedArtifact']
  >;

  export type $GeneratedArtifactPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'GeneratedArtifact';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        type: string;
        content: string;
        metadata: Prisma.JsonValue | null;
        isActive: boolean;
        organizationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['generatedArtifact']
    >;
    composites: {};
  };

  type GeneratedArtifactGetPayload<
    S extends boolean | null | undefined | GeneratedArtifactDefaultArgs,
  > = $Result.GetResult<Prisma.$GeneratedArtifactPayload, S>;

  type GeneratedArtifactCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<GeneratedArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GeneratedArtifactCountAggregateInputType | true;
  };

  export interface GeneratedArtifactDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['GeneratedArtifact'];
      meta: { name: 'GeneratedArtifact' };
    };
    /**
     * Find zero or one GeneratedArtifact that matches the filter.
     * @param {GeneratedArtifactFindUniqueArgs} args - Arguments to find a GeneratedArtifact
     * @example
     * // Get one GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedArtifactFindUniqueArgs>(
      args: SelectSubset<T, GeneratedArtifactFindUniqueArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one GeneratedArtifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedArtifactFindUniqueOrThrowArgs} args - Arguments to find a GeneratedArtifact
     * @example
     * // Get one GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedArtifactFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GeneratedArtifactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GeneratedArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactFindFirstArgs} args - Arguments to find a GeneratedArtifact
     * @example
     * // Get one GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedArtifactFindFirstArgs>(
      args?: SelectSubset<T, GeneratedArtifactFindFirstArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GeneratedArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactFindFirstOrThrowArgs} args - Arguments to find a GeneratedArtifact
     * @example
     * // Get one GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedArtifactFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GeneratedArtifactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more GeneratedArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedArtifacts
     * const generatedArtifacts = await prisma.generatedArtifact.findMany()
     *
     * // Get first 10 GeneratedArtifacts
     * const generatedArtifacts = await prisma.generatedArtifact.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const generatedArtifactWithIdOnly = await prisma.generatedArtifact.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GeneratedArtifactFindManyArgs>(
      args?: SelectSubset<T, GeneratedArtifactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GeneratedArtifactPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a GeneratedArtifact.
     * @param {GeneratedArtifactCreateArgs} args - Arguments to create a GeneratedArtifact.
     * @example
     * // Create one GeneratedArtifact
     * const GeneratedArtifact = await prisma.generatedArtifact.create({
     *   data: {
     *     // ... data to create a GeneratedArtifact
     *   }
     * })
     *
     */
    create<T extends GeneratedArtifactCreateArgs>(
      args: SelectSubset<T, GeneratedArtifactCreateArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<Prisma.$GeneratedArtifactPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many GeneratedArtifacts.
     * @param {GeneratedArtifactCreateManyArgs} args - Arguments to create many GeneratedArtifacts.
     * @example
     * // Create many GeneratedArtifacts
     * const generatedArtifact = await prisma.generatedArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GeneratedArtifactCreateManyArgs>(
      args?: SelectSubset<T, GeneratedArtifactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many GeneratedArtifacts and returns the data saved in the database.
     * @param {GeneratedArtifactCreateManyAndReturnArgs} args - Arguments to create many GeneratedArtifacts.
     * @example
     * // Create many GeneratedArtifacts
     * const generatedArtifact = await prisma.generatedArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many GeneratedArtifacts and only return the `id`
     * const generatedArtifactWithIdOnly = await prisma.generatedArtifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GeneratedArtifactCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GeneratedArtifactCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a GeneratedArtifact.
     * @param {GeneratedArtifactDeleteArgs} args - Arguments to delete one GeneratedArtifact.
     * @example
     * // Delete one GeneratedArtifact
     * const GeneratedArtifact = await prisma.generatedArtifact.delete({
     *   where: {
     *     // ... filter to delete one GeneratedArtifact
     *   }
     * })
     *
     */
    delete<T extends GeneratedArtifactDeleteArgs>(
      args: SelectSubset<T, GeneratedArtifactDeleteArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<Prisma.$GeneratedArtifactPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one GeneratedArtifact.
     * @param {GeneratedArtifactUpdateArgs} args - Arguments to update one GeneratedArtifact.
     * @example
     * // Update one GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GeneratedArtifactUpdateArgs>(
      args: SelectSubset<T, GeneratedArtifactUpdateArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<Prisma.$GeneratedArtifactPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more GeneratedArtifacts.
     * @param {GeneratedArtifactDeleteManyArgs} args - Arguments to filter GeneratedArtifacts to delete.
     * @example
     * // Delete a few GeneratedArtifacts
     * const { count } = await prisma.generatedArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GeneratedArtifactDeleteManyArgs>(
      args?: SelectSubset<T, GeneratedArtifactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GeneratedArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedArtifacts
     * const generatedArtifact = await prisma.generatedArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GeneratedArtifactUpdateManyArgs>(
      args: SelectSubset<T, GeneratedArtifactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GeneratedArtifacts and returns the data updated in the database.
     * @param {GeneratedArtifactUpdateManyAndReturnArgs} args - Arguments to update many GeneratedArtifacts.
     * @example
     * // Update many GeneratedArtifacts
     * const generatedArtifact = await prisma.generatedArtifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more GeneratedArtifacts and only return the `id`
     * const generatedArtifactWithIdOnly = await prisma.generatedArtifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GeneratedArtifactUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GeneratedArtifactUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GeneratedArtifactPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one GeneratedArtifact.
     * @param {GeneratedArtifactUpsertArgs} args - Arguments to update or create a GeneratedArtifact.
     * @example
     * // Update or create a GeneratedArtifact
     * const generatedArtifact = await prisma.generatedArtifact.upsert({
     *   create: {
     *     // ... data to create a GeneratedArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedArtifact we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedArtifactUpsertArgs>(
      args: SelectSubset<T, GeneratedArtifactUpsertArgs<ExtArgs>>
    ): Prisma__GeneratedArtifactClient<
      $Result.GetResult<Prisma.$GeneratedArtifactPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of GeneratedArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactCountArgs} args - Arguments to filter GeneratedArtifacts to count.
     * @example
     * // Count the number of GeneratedArtifacts
     * const count = await prisma.generatedArtifact.count({
     *   where: {
     *     // ... the filter for the GeneratedArtifacts we want to count
     *   }
     * })
     **/
    count<T extends GeneratedArtifactCountArgs>(
      args?: Subset<T, GeneratedArtifactCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedArtifactCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a GeneratedArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GeneratedArtifactAggregateArgs>(
      args: Subset<T, GeneratedArtifactAggregateArgs>
    ): Prisma.PrismaPromise<GetGeneratedArtifactAggregateType<T>>;

    /**
     * Group by GeneratedArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GeneratedArtifactGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedArtifactGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GeneratedArtifactGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetGeneratedArtifactGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the GeneratedArtifact model
     */
    readonly fields: GeneratedArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedArtifactClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the GeneratedArtifact model
   */
  interface GeneratedArtifactFieldRefs {
    readonly id: FieldRef<'GeneratedArtifact', 'String'>;
    readonly name: FieldRef<'GeneratedArtifact', 'String'>;
    readonly type: FieldRef<'GeneratedArtifact', 'String'>;
    readonly content: FieldRef<'GeneratedArtifact', 'String'>;
    readonly metadata: FieldRef<'GeneratedArtifact', 'Json'>;
    readonly isActive: FieldRef<'GeneratedArtifact', 'Boolean'>;
    readonly organizationId: FieldRef<'GeneratedArtifact', 'String'>;
    readonly createdAt: FieldRef<'GeneratedArtifact', 'DateTime'>;
    readonly updatedAt: FieldRef<'GeneratedArtifact', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * GeneratedArtifact findUnique
   */
  export type GeneratedArtifactFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter, which GeneratedArtifact to fetch.
     */
    where: GeneratedArtifactWhereUniqueInput;
  };

  /**
   * GeneratedArtifact findUniqueOrThrow
   */
  export type GeneratedArtifactFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter, which GeneratedArtifact to fetch.
     */
    where: GeneratedArtifactWhereUniqueInput;
  };

  /**
   * GeneratedArtifact findFirst
   */
  export type GeneratedArtifactFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter, which GeneratedArtifact to fetch.
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneratedArtifacts to fetch.
     */
    orderBy?:
      | GeneratedArtifactOrderByWithRelationInput
      | GeneratedArtifactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GeneratedArtifacts.
     */
    cursor?: GeneratedArtifactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneratedArtifacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneratedArtifacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GeneratedArtifacts.
     */
    distinct?: GeneratedArtifactScalarFieldEnum | GeneratedArtifactScalarFieldEnum[];
  };

  /**
   * GeneratedArtifact findFirstOrThrow
   */
  export type GeneratedArtifactFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter, which GeneratedArtifact to fetch.
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneratedArtifacts to fetch.
     */
    orderBy?:
      | GeneratedArtifactOrderByWithRelationInput
      | GeneratedArtifactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GeneratedArtifacts.
     */
    cursor?: GeneratedArtifactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneratedArtifacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneratedArtifacts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GeneratedArtifacts.
     */
    distinct?: GeneratedArtifactScalarFieldEnum | GeneratedArtifactScalarFieldEnum[];
  };

  /**
   * GeneratedArtifact findMany
   */
  export type GeneratedArtifactFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter, which GeneratedArtifacts to fetch.
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneratedArtifacts to fetch.
     */
    orderBy?:
      | GeneratedArtifactOrderByWithRelationInput
      | GeneratedArtifactOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing GeneratedArtifacts.
     */
    cursor?: GeneratedArtifactWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneratedArtifacts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneratedArtifacts.
     */
    skip?: number;
    distinct?: GeneratedArtifactScalarFieldEnum | GeneratedArtifactScalarFieldEnum[];
  };

  /**
   * GeneratedArtifact create
   */
  export type GeneratedArtifactCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * The data needed to create a GeneratedArtifact.
     */
    data: XOR<GeneratedArtifactCreateInput, GeneratedArtifactUncheckedCreateInput>;
  };

  /**
   * GeneratedArtifact createMany
   */
  export type GeneratedArtifactCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many GeneratedArtifacts.
     */
    data: GeneratedArtifactCreateManyInput | GeneratedArtifactCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * GeneratedArtifact createManyAndReturn
   */
  export type GeneratedArtifactCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * The data used to create many GeneratedArtifacts.
     */
    data: GeneratedArtifactCreateManyInput | GeneratedArtifactCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * GeneratedArtifact update
   */
  export type GeneratedArtifactUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * The data needed to update a GeneratedArtifact.
     */
    data: XOR<GeneratedArtifactUpdateInput, GeneratedArtifactUncheckedUpdateInput>;
    /**
     * Choose, which GeneratedArtifact to update.
     */
    where: GeneratedArtifactWhereUniqueInput;
  };

  /**
   * GeneratedArtifact updateMany
   */
  export type GeneratedArtifactUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update GeneratedArtifacts.
     */
    data: XOR<GeneratedArtifactUpdateManyMutationInput, GeneratedArtifactUncheckedUpdateManyInput>;
    /**
     * Filter which GeneratedArtifacts to update
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * Limit how many GeneratedArtifacts to update.
     */
    limit?: number;
  };

  /**
   * GeneratedArtifact updateManyAndReturn
   */
  export type GeneratedArtifactUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * The data used to update GeneratedArtifacts.
     */
    data: XOR<GeneratedArtifactUpdateManyMutationInput, GeneratedArtifactUncheckedUpdateManyInput>;
    /**
     * Filter which GeneratedArtifacts to update
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * Limit how many GeneratedArtifacts to update.
     */
    limit?: number;
  };

  /**
   * GeneratedArtifact upsert
   */
  export type GeneratedArtifactUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * The filter to search for the GeneratedArtifact to update in case it exists.
     */
    where: GeneratedArtifactWhereUniqueInput;
    /**
     * In case the GeneratedArtifact found by the `where` argument doesn't exist, create a new GeneratedArtifact with this data.
     */
    create: XOR<GeneratedArtifactCreateInput, GeneratedArtifactUncheckedCreateInput>;
    /**
     * In case the GeneratedArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedArtifactUpdateInput, GeneratedArtifactUncheckedUpdateInput>;
  };

  /**
   * GeneratedArtifact delete
   */
  export type GeneratedArtifactDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
    /**
     * Filter which GeneratedArtifact to delete.
     */
    where: GeneratedArtifactWhereUniqueInput;
  };

  /**
   * GeneratedArtifact deleteMany
   */
  export type GeneratedArtifactDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GeneratedArtifacts to delete
     */
    where?: GeneratedArtifactWhereInput;
    /**
     * Limit how many GeneratedArtifacts to delete.
     */
    limit?: number;
  };

  /**
   * GeneratedArtifact without action
   */
  export type GeneratedArtifactDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneratedArtifact
     */
    select?: GeneratedArtifactSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneratedArtifact
     */
    omit?: GeneratedArtifactOmit<ExtArgs> | null;
  };

  /**
   * Model RateLimitConfig
   */

  export type AggregateRateLimitConfig = {
    _count: RateLimitConfigCountAggregateOutputType | null;
    _avg: RateLimitConfigAvgAggregateOutputType | null;
    _sum: RateLimitConfigSumAggregateOutputType | null;
    _min: RateLimitConfigMinAggregateOutputType | null;
    _max: RateLimitConfigMaxAggregateOutputType | null;
  };

  export type RateLimitConfigAvgAggregateOutputType = {
    limit: number | null;
    windowMs: number | null;
  };

  export type RateLimitConfigSumAggregateOutputType = {
    limit: number | null;
    windowMs: number | null;
  };

  export type RateLimitConfigMinAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    type: string | null;
    limit: number | null;
    windowMs: number | null;
    isActive: boolean | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RateLimitConfigMaxAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    type: string | null;
    limit: number | null;
    windowMs: number | null;
    isActive: boolean | null;
    organizationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RateLimitConfigCountAggregateOutputType = {
    id: number;
    identifier: number;
    type: number;
    limit: number;
    windowMs: number;
    isActive: number;
    organizationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RateLimitConfigAvgAggregateInputType = {
    limit?: true;
    windowMs?: true;
  };

  export type RateLimitConfigSumAggregateInputType = {
    limit?: true;
    windowMs?: true;
  };

  export type RateLimitConfigMinAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    limit?: true;
    windowMs?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RateLimitConfigMaxAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    limit?: true;
    windowMs?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RateLimitConfigCountAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    limit?: true;
    windowMs?: true;
    isActive?: true;
    organizationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RateLimitConfigAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitConfig to aggregate.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RateLimitConfigs
     **/
    _count?: true | RateLimitConfigCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RateLimitConfigAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RateLimitConfigSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RateLimitConfigMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RateLimitConfigMaxAggregateInputType;
  };

  export type GetRateLimitConfigAggregateType<T extends RateLimitConfigAggregateArgs> = {
    [P in keyof T & keyof AggregateRateLimitConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimitConfig[P]>
      : GetScalarType<T[P], AggregateRateLimitConfig[P]>;
  };

  export type RateLimitConfigGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RateLimitConfigWhereInput;
    orderBy?:
      | RateLimitConfigOrderByWithAggregationInput
      | RateLimitConfigOrderByWithAggregationInput[];
    by: RateLimitConfigScalarFieldEnum[] | RateLimitConfigScalarFieldEnum;
    having?: RateLimitConfigScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RateLimitConfigCountAggregateInputType | true;
    _avg?: RateLimitConfigAvgAggregateInputType;
    _sum?: RateLimitConfigSumAggregateInputType;
    _min?: RateLimitConfigMinAggregateInputType;
    _max?: RateLimitConfigMaxAggregateInputType;
  };

  export type RateLimitConfigGroupByOutputType = {
    id: string;
    identifier: string;
    type: string;
    limit: number;
    windowMs: number;
    isActive: boolean;
    organizationId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: RateLimitConfigCountAggregateOutputType | null;
    _avg: RateLimitConfigAvgAggregateOutputType | null;
    _sum: RateLimitConfigSumAggregateOutputType | null;
    _min: RateLimitConfigMinAggregateOutputType | null;
    _max: RateLimitConfigMaxAggregateOutputType | null;
  };

  type GetRateLimitConfigGroupByPayload<T extends RateLimitConfigGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RateLimitConfigGroupByOutputType, T['by']> & {
          [P in keyof T & keyof RateLimitConfigGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitConfigGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitConfigGroupByOutputType[P]>;
        }
      >
    >;

  export type RateLimitConfigSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      type?: boolean;
      limit?: boolean;
      windowMs?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      type?: boolean;
      limit?: boolean;
      windowMs?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      identifier?: boolean;
      type?: boolean;
      limit?: boolean;
      windowMs?: boolean;
      isActive?: boolean;
      organizationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['rateLimitConfig']
  >;

  export type RateLimitConfigSelectScalar = {
    id?: boolean;
    identifier?: boolean;
    type?: boolean;
    limit?: boolean;
    windowMs?: boolean;
    isActive?: boolean;
    organizationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RateLimitConfigOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'identifier'
    | 'type'
    | 'limit'
    | 'windowMs'
    | 'isActive'
    | 'organizationId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['rateLimitConfig']
  >;

  export type $RateLimitConfigPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RateLimitConfig';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        identifier: string;
        type: string;
        limit: number;
        windowMs: number;
        isActive: boolean;
        organizationId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['rateLimitConfig']
    >;
    composites: {};
  };

  type RateLimitConfigGetPayload<
    S extends boolean | null | undefined | RateLimitConfigDefaultArgs,
  > = $Result.GetResult<Prisma.$RateLimitConfigPayload, S>;

  type RateLimitConfigCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RateLimitConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RateLimitConfigCountAggregateInputType | true;
  };

  export interface RateLimitConfigDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RateLimitConfig'];
      meta: { name: 'RateLimitConfig' };
    };
    /**
     * Find zero or one RateLimitConfig that matches the filter.
     * @param {RateLimitConfigFindUniqueArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitConfigFindUniqueArgs>(
      args: SelectSubset<T, RateLimitConfigFindUniqueArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RateLimitConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RateLimitConfigFindUniqueOrThrowArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitConfigFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RateLimitConfigFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindFirstArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitConfigFindFirstArgs>(
      args?: SelectSubset<T, RateLimitConfigFindFirstArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RateLimitConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindFirstOrThrowArgs} args - Arguments to find a RateLimitConfig
     * @example
     * // Get one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitConfigFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RateLimitConfigFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RateLimitConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitConfigs
     * const rateLimitConfigs = await prisma.rateLimitConfig.findMany()
     *
     * // Get first 10 RateLimitConfigs
     * const rateLimitConfigs = await prisma.rateLimitConfig.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RateLimitConfigFindManyArgs>(
      args?: SelectSubset<T, RateLimitConfigFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a RateLimitConfig.
     * @param {RateLimitConfigCreateArgs} args - Arguments to create a RateLimitConfig.
     * @example
     * // Create one RateLimitConfig
     * const RateLimitConfig = await prisma.rateLimitConfig.create({
     *   data: {
     *     // ... data to create a RateLimitConfig
     *   }
     * })
     *
     */
    create<T extends RateLimitConfigCreateArgs>(
      args: SelectSubset<T, RateLimitConfigCreateArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RateLimitConfigs.
     * @param {RateLimitConfigCreateManyArgs} args - Arguments to create many RateLimitConfigs.
     * @example
     * // Create many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RateLimitConfigCreateManyArgs>(
      args?: SelectSubset<T, RateLimitConfigCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RateLimitConfigs and returns the data saved in the database.
     * @param {RateLimitConfigCreateManyAndReturnArgs} args - Arguments to create many RateLimitConfigs.
     * @example
     * // Create many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RateLimitConfigs and only return the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RateLimitConfigCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RateLimitConfigCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a RateLimitConfig.
     * @param {RateLimitConfigDeleteArgs} args - Arguments to delete one RateLimitConfig.
     * @example
     * // Delete one RateLimitConfig
     * const RateLimitConfig = await prisma.rateLimitConfig.delete({
     *   where: {
     *     // ... filter to delete one RateLimitConfig
     *   }
     * })
     *
     */
    delete<T extends RateLimitConfigDeleteArgs>(
      args: SelectSubset<T, RateLimitConfigDeleteArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RateLimitConfig.
     * @param {RateLimitConfigUpdateArgs} args - Arguments to update one RateLimitConfig.
     * @example
     * // Update one RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RateLimitConfigUpdateArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RateLimitConfigs.
     * @param {RateLimitConfigDeleteManyArgs} args - Arguments to filter RateLimitConfigs to delete.
     * @example
     * // Delete a few RateLimitConfigs
     * const { count } = await prisma.rateLimitConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RateLimitConfigDeleteManyArgs>(
      args?: SelectSubset<T, RateLimitConfigDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RateLimitConfigUpdateManyArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RateLimitConfigs and returns the data updated in the database.
     * @param {RateLimitConfigUpdateManyAndReturnArgs} args - Arguments to update many RateLimitConfigs.
     * @example
     * // Update many RateLimitConfigs
     * const rateLimitConfig = await prisma.rateLimitConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RateLimitConfigs and only return the `id`
     * const rateLimitConfigWithIdOnly = await prisma.rateLimitConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RateLimitConfigUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RateLimitConfigUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RateLimitConfigPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one RateLimitConfig.
     * @param {RateLimitConfigUpsertArgs} args - Arguments to update or create a RateLimitConfig.
     * @example
     * // Update or create a RateLimitConfig
     * const rateLimitConfig = await prisma.rateLimitConfig.upsert({
     *   create: {
     *     // ... data to create a RateLimitConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimitConfig we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitConfigUpsertArgs>(
      args: SelectSubset<T, RateLimitConfigUpsertArgs<ExtArgs>>
    ): Prisma__RateLimitConfigClient<
      $Result.GetResult<Prisma.$RateLimitConfigPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RateLimitConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigCountArgs} args - Arguments to filter RateLimitConfigs to count.
     * @example
     * // Count the number of RateLimitConfigs
     * const count = await prisma.rateLimitConfig.count({
     *   where: {
     *     // ... the filter for the RateLimitConfigs we want to count
     *   }
     * })
     **/
    count<T extends RateLimitConfigCountArgs>(
      args?: Subset<T, RateLimitConfigCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitConfigCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RateLimitConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RateLimitConfigAggregateArgs>(
      args: Subset<T, RateLimitConfigAggregateArgs>
    ): Prisma.PrismaPromise<GetRateLimitConfigAggregateType<T>>;

    /**
     * Group by RateLimitConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RateLimitConfigGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitConfigGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RateLimitConfigGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRateLimitConfigGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RateLimitConfig model
     */
    readonly fields: RateLimitConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimitConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitConfigClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RateLimitConfig model
   */
  interface RateLimitConfigFieldRefs {
    readonly id: FieldRef<'RateLimitConfig', 'String'>;
    readonly identifier: FieldRef<'RateLimitConfig', 'String'>;
    readonly type: FieldRef<'RateLimitConfig', 'String'>;
    readonly limit: FieldRef<'RateLimitConfig', 'Int'>;
    readonly windowMs: FieldRef<'RateLimitConfig', 'Int'>;
    readonly isActive: FieldRef<'RateLimitConfig', 'Boolean'>;
    readonly organizationId: FieldRef<'RateLimitConfig', 'String'>;
    readonly createdAt: FieldRef<'RateLimitConfig', 'DateTime'>;
    readonly updatedAt: FieldRef<'RateLimitConfig', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * RateLimitConfig findUnique
   */
  export type RateLimitConfigFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig findUniqueOrThrow
   */
  export type RateLimitConfigFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig findFirst
   */
  export type RateLimitConfigFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitConfigs.
     */
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig findFirstOrThrow
   */
  export type RateLimitConfigFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfig to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RateLimitConfigs.
     */
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig findMany
   */
  export type RateLimitConfigFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter, which RateLimitConfigs to fetch.
     */
    where?: RateLimitConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RateLimitConfigs to fetch.
     */
    orderBy?: RateLimitConfigOrderByWithRelationInput | RateLimitConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RateLimitConfigs.
     */
    cursor?: RateLimitConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RateLimitConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RateLimitConfigs.
     */
    skip?: number;
    distinct?: RateLimitConfigScalarFieldEnum | RateLimitConfigScalarFieldEnum[];
  };

  /**
   * RateLimitConfig create
   */
  export type RateLimitConfigCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data needed to create a RateLimitConfig.
     */
    data: XOR<RateLimitConfigCreateInput, RateLimitConfigUncheckedCreateInput>;
  };

  /**
   * RateLimitConfig createMany
   */
  export type RateLimitConfigCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RateLimitConfigs.
     */
    data: RateLimitConfigCreateManyInput | RateLimitConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RateLimitConfig createManyAndReturn
   */
  export type RateLimitConfigCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data used to create many RateLimitConfigs.
     */
    data: RateLimitConfigCreateManyInput | RateLimitConfigCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RateLimitConfig update
   */
  export type RateLimitConfigUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data needed to update a RateLimitConfig.
     */
    data: XOR<RateLimitConfigUpdateInput, RateLimitConfigUncheckedUpdateInput>;
    /**
     * Choose, which RateLimitConfig to update.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig updateMany
   */
  export type RateLimitConfigUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RateLimitConfigs.
     */
    data: XOR<RateLimitConfigUpdateManyMutationInput, RateLimitConfigUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitConfigs to update
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to update.
     */
    limit?: number;
  };

  /**
   * RateLimitConfig updateManyAndReturn
   */
  export type RateLimitConfigUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The data used to update RateLimitConfigs.
     */
    data: XOR<RateLimitConfigUpdateManyMutationInput, RateLimitConfigUncheckedUpdateManyInput>;
    /**
     * Filter which RateLimitConfigs to update
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to update.
     */
    limit?: number;
  };

  /**
   * RateLimitConfig upsert
   */
  export type RateLimitConfigUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * The filter to search for the RateLimitConfig to update in case it exists.
     */
    where: RateLimitConfigWhereUniqueInput;
    /**
     * In case the RateLimitConfig found by the `where` argument doesn't exist, create a new RateLimitConfig with this data.
     */
    create: XOR<RateLimitConfigCreateInput, RateLimitConfigUncheckedCreateInput>;
    /**
     * In case the RateLimitConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitConfigUpdateInput, RateLimitConfigUncheckedUpdateInput>;
  };

  /**
   * RateLimitConfig delete
   */
  export type RateLimitConfigDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
    /**
     * Filter which RateLimitConfig to delete.
     */
    where: RateLimitConfigWhereUniqueInput;
  };

  /**
   * RateLimitConfig deleteMany
   */
  export type RateLimitConfigDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RateLimitConfigs to delete
     */
    where?: RateLimitConfigWhereInput;
    /**
     * Limit how many RateLimitConfigs to delete.
     */
    limit?: number;
  };

  /**
   * RateLimitConfig without action
   */
  export type RateLimitConfigDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RateLimitConfig
     */
    select?: RateLimitConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RateLimitConfig
     */
    omit?: RateLimitConfigOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const OrganizationScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    isActive: 'isActive';
    settings: 'settings';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type OrganizationScalarFieldEnum =
    (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    password: 'password';
    firstName: 'firstName';
    lastName: 'lastName';
    phone: 'phone';
    phoneCarrier: 'phoneCarrier';
    organizationId: 'organizationId';
    role: 'role';
    accountSetupToken: 'accountSetupToken';
    accountSetupTokenExpires: 'accountSetupTokenExpires';
    twoFactorSecret: 'twoFactorSecret';
    twoFactorBackupCodes: 'twoFactorBackupCodes';
    twoFactorEnabledAt: 'twoFactorEnabledAt';
    twoFactorOTP: 'twoFactorOTP';
    trustedDevices: 'trustedDevices';
    isActive: 'isActive';
    isEmailVerified: 'isEmailVerified';
    lastLoginAt: 'lastLoginAt';
    loginAttempts: 'loginAttempts';
    lockedUntil: 'lockedUntil';
    passwordResetToken: 'passwordResetToken';
    passwordResetTokenExpires: 'passwordResetTokenExpires';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const ConnectionScalarFieldEnum: {
    id: 'id';
    name: 'name';
    host: 'host';
    port: 'port';
    username: 'username';
    password: 'password';
    isActive: 'isActive';
    failoverHost: 'failoverHost';
    databases: 'databases';
    createdById: 'createdById';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ConnectionScalarFieldEnum =
    (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum];

  export const ServiceScalarFieldEnum: {
    id: 'id';
    name: 'name';
    label: 'label';
    description: 'description';
    host: 'host';
    port: 'port';
    database: 'database';
    username: 'username';
    password: 'password';
    isActive: 'isActive';
    failoverHost: 'failoverHost';
    objects: 'objects';
    createdById: 'createdById';
    organizationId: 'organizationId';
    connectionId: 'connectionId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

  export const ApplicationScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    isActive: 'isActive';
    configuration: 'configuration';
    createdById: 'createdById';
    organizationId: 'organizationId';
    serviceId: 'serviceId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ApplicationScalarFieldEnum =
    (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum];

  export const WorkflowScalarFieldEnum: {
    id: 'id';
    name: 'name';
    active: 'active';
    schedule: 'schedule';
    lastDatabaseCheck: 'lastDatabaseCheck';
    lastHubSpotCheck: 'lastHubSpotCheck';
    nodes: 'nodes';
    edges: 'edges';
    createdById: 'createdById';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type WorkflowScalarFieldEnum =
    (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum];

  export const WorkflowRunScalarFieldEnum: {
    id: 'id';
    status: 'status';
    startedAt: 'startedAt';
    completedAt: 'completedAt';
    errorMessage: 'errorMessage';
    executionData: 'executionData';
    workflowId: 'workflowId';
    triggeredById: 'triggeredById';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type WorkflowRunScalarFieldEnum =
    (typeof WorkflowRunScalarFieldEnum)[keyof typeof WorkflowRunScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    permissions: 'permissions';
    isActive: 'isActive';
    createdById: 'createdById';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const EndpointScalarFieldEnum: {
    id: 'id';
    name: 'name';
    path: 'path';
    method: 'method';
    description: 'description';
    isActive: 'isActive';
    configuration: 'configuration';
    createdById: 'createdById';
    organizationId: 'organizationId';
    serviceId: 'serviceId';
    applicationId: 'applicationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type EndpointScalarFieldEnum =
    (typeof EndpointScalarFieldEnum)[keyof typeof EndpointScalarFieldEnum];

  export const ApiActivityLogScalarFieldEnum: {
    id: 'id';
    method: 'method';
    endpoint: 'endpoint';
    statusCode: 'statusCode';
    responseTime: 'responseTime';
    requestBody: 'requestBody';
    responseBody: 'responseBody';
    userAgent: 'userAgent';
    ipAddress: 'ipAddress';
    userId: 'userId';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
  };

  export type ApiActivityLogScalarFieldEnum =
    (typeof ApiActivityLogScalarFieldEnum)[keyof typeof ApiActivityLogScalarFieldEnum];

  export const ApiUsageScalarFieldEnum: {
    id: 'id';
    endpoint: 'endpoint';
    method: 'method';
    callCount: 'callCount';
    totalResponseTime: 'totalResponseTime';
    userId: 'userId';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ApiUsageScalarFieldEnum =
    (typeof ApiUsageScalarFieldEnum)[keyof typeof ApiUsageScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    title: 'title';
    message: 'message';
    type: 'type';
    isRead: 'isRead';
    data: 'data';
    userId: 'userId';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const UserLogScalarFieldEnum: {
    id: 'id';
    action: 'action';
    details: 'details';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    userId: 'userId';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
  };

  export type UserLogScalarFieldEnum =
    (typeof UserLogScalarFieldEnum)[keyof typeof UserLogScalarFieldEnum];

  export const DatabaseObjectScalarFieldEnum: {
    id: 'id';
    name: 'name';
    type: 'type';
    schema: 'schema';
    definition: 'definition';
    metadata: 'metadata';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type DatabaseObjectScalarFieldEnum =
    (typeof DatabaseObjectScalarFieldEnum)[keyof typeof DatabaseObjectScalarFieldEnum];

  export const SchemaIntelligenceScalarFieldEnum: {
    id: 'id';
    entityName: 'entityName';
    entityType: 'entityType';
    confidence: 'confidence';
    analysis: 'analysis';
    procedures: 'procedures';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SchemaIntelligenceScalarFieldEnum =
    (typeof SchemaIntelligenceScalarFieldEnum)[keyof typeof SchemaIntelligenceScalarFieldEnum];

  export const GeneratedArtifactScalarFieldEnum: {
    id: 'id';
    name: 'name';
    type: 'type';
    content: 'content';
    metadata: 'metadata';
    isActive: 'isActive';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type GeneratedArtifactScalarFieldEnum =
    (typeof GeneratedArtifactScalarFieldEnum)[keyof typeof GeneratedArtifactScalarFieldEnum];

  export const RateLimitConfigScalarFieldEnum: {
    id: 'id';
    identifier: 'identifier';
    type: 'type';
    limit: 'limit';
    windowMs: 'windowMs';
    isActive: 'isActive';
    organizationId: 'organizationId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RateLimitConfigScalarFieldEnum =
    (typeof RateLimitConfigScalarFieldEnum)[keyof typeof RateLimitConfigScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Deep Input Types
   */

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[];
    OR?: OrganizationWhereInput[];
    NOT?: OrganizationWhereInput | OrganizationWhereInput[];
    id?: StringFilter<'Organization'> | string;
    name?: StringFilter<'Organization'> | string;
    slug?: StringFilter<'Organization'> | string;
    isActive?: BoolFilter<'Organization'> | boolean;
    settings?: JsonNullableFilter<'Organization'>;
    createdAt?: DateTimeFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeFilter<'Organization'> | Date | string;
    users?: UserListRelationFilter;
  };

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    isActive?: SortOrder;
    settings?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    users?: UserOrderByRelationAggregateInput;
  };

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: OrganizationWhereInput | OrganizationWhereInput[];
      OR?: OrganizationWhereInput[];
      NOT?: OrganizationWhereInput | OrganizationWhereInput[];
      name?: StringFilter<'Organization'> | string;
      isActive?: BoolFilter<'Organization'> | boolean;
      settings?: JsonNullableFilter<'Organization'>;
      createdAt?: DateTimeFilter<'Organization'> | Date | string;
      updatedAt?: DateTimeFilter<'Organization'> | Date | string;
      users?: UserListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    isActive?: SortOrder;
    settings?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: OrganizationCountOrderByAggregateInput;
    _max?: OrganizationMaxOrderByAggregateInput;
    _min?: OrganizationMinOrderByAggregateInput;
  };

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[];
    OR?: OrganizationScalarWhereWithAggregatesInput[];
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Organization'> | string;
    name?: StringWithAggregatesFilter<'Organization'> | string;
    slug?: StringWithAggregatesFilter<'Organization'> | string;
    isActive?: BoolWithAggregatesFilter<'Organization'> | boolean;
    settings?: JsonNullableWithAggregatesFilter<'Organization'>;
    createdAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Organization'> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    password?: StringNullableFilter<'User'> | string | null;
    firstName?: StringFilter<'User'> | string;
    lastName?: StringFilter<'User'> | string;
    phone?: StringNullableFilter<'User'> | string | null;
    phoneCarrier?: StringNullableFilter<'User'> | string | null;
    organizationId?: StringFilter<'User'> | string;
    role?: StringFilter<'User'> | string;
    accountSetupToken?: StringNullableFilter<'User'> | string | null;
    accountSetupTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
    twoFactorSecret?: StringNullableFilter<'User'> | string | null;
    twoFactorBackupCodes?: JsonNullableFilter<'User'>;
    twoFactorEnabledAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    twoFactorOTP?: JsonNullableFilter<'User'>;
    trustedDevices?: JsonNullableFilter<'User'>;
    isActive?: BoolFilter<'User'> | boolean;
    isEmailVerified?: BoolFilter<'User'> | boolean;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    loginAttempts?: IntFilter<'User'> | number;
    lockedUntil?: DateTimeNullableFilter<'User'> | Date | string | null;
    passwordResetToken?: StringNullableFilter<'User'> | string | null;
    passwordResetTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    apiActivityLogs?: ApiActivityLogListRelationFilter;
    apiUsage?: ApiUsageListRelationFilter;
    applications?: ApplicationListRelationFilter;
    connections?: ConnectionListRelationFilter;
    endpoints?: EndpointListRelationFilter;
    notifications?: NotificationListRelationFilter;
    roles?: RoleListRelationFilter;
    services?: ServiceListRelationFilter;
    userLogs?: UserLogListRelationFilter;
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    workflowRuns?: WorkflowRunListRelationFilter;
    workflows?: WorkflowListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrderInput | SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    phoneCarrier?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    accountSetupToken?: SortOrderInput | SortOrder;
    accountSetupTokenExpires?: SortOrderInput | SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    twoFactorBackupCodes?: SortOrderInput | SortOrder;
    twoFactorEnabledAt?: SortOrderInput | SortOrder;
    twoFactorOTP?: SortOrderInput | SortOrder;
    trustedDevices?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isEmailVerified?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrderInput | SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    passwordResetTokenExpires?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    apiActivityLogs?: ApiActivityLogOrderByRelationAggregateInput;
    apiUsage?: ApiUsageOrderByRelationAggregateInput;
    applications?: ApplicationOrderByRelationAggregateInput;
    connections?: ConnectionOrderByRelationAggregateInput;
    endpoints?: EndpointOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    roles?: RoleOrderByRelationAggregateInput;
    services?: ServiceOrderByRelationAggregateInput;
    userLogs?: UserLogOrderByRelationAggregateInput;
    organization?: OrganizationOrderByWithRelationInput;
    workflowRuns?: WorkflowRunOrderByRelationAggregateInput;
    workflows?: WorkflowOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      password?: StringNullableFilter<'User'> | string | null;
      firstName?: StringFilter<'User'> | string;
      lastName?: StringFilter<'User'> | string;
      phone?: StringNullableFilter<'User'> | string | null;
      phoneCarrier?: StringNullableFilter<'User'> | string | null;
      organizationId?: StringFilter<'User'> | string;
      role?: StringFilter<'User'> | string;
      accountSetupToken?: StringNullableFilter<'User'> | string | null;
      accountSetupTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
      twoFactorSecret?: StringNullableFilter<'User'> | string | null;
      twoFactorBackupCodes?: JsonNullableFilter<'User'>;
      twoFactorEnabledAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      twoFactorOTP?: JsonNullableFilter<'User'>;
      trustedDevices?: JsonNullableFilter<'User'>;
      isActive?: BoolFilter<'User'> | boolean;
      isEmailVerified?: BoolFilter<'User'> | boolean;
      lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      loginAttempts?: IntFilter<'User'> | number;
      lockedUntil?: DateTimeNullableFilter<'User'> | Date | string | null;
      passwordResetToken?: StringNullableFilter<'User'> | string | null;
      passwordResetTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      apiActivityLogs?: ApiActivityLogListRelationFilter;
      apiUsage?: ApiUsageListRelationFilter;
      applications?: ApplicationListRelationFilter;
      connections?: ConnectionListRelationFilter;
      endpoints?: EndpointListRelationFilter;
      notifications?: NotificationListRelationFilter;
      roles?: RoleListRelationFilter;
      services?: ServiceListRelationFilter;
      userLogs?: UserLogListRelationFilter;
      organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      workflowRuns?: WorkflowRunListRelationFilter;
      workflows?: WorkflowListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrderInput | SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    phoneCarrier?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    accountSetupToken?: SortOrderInput | SortOrder;
    accountSetupTokenExpires?: SortOrderInput | SortOrder;
    twoFactorSecret?: SortOrderInput | SortOrder;
    twoFactorBackupCodes?: SortOrderInput | SortOrder;
    twoFactorEnabledAt?: SortOrderInput | SortOrder;
    twoFactorOTP?: SortOrderInput | SortOrder;
    trustedDevices?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isEmailVerified?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrderInput | SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    passwordResetTokenExpires?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _avg?: UserAvgOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
    _sum?: UserSumOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    firstName?: StringWithAggregatesFilter<'User'> | string;
    lastName?: StringWithAggregatesFilter<'User'> | string;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phoneCarrier?: StringNullableWithAggregatesFilter<'User'> | string | null;
    organizationId?: StringWithAggregatesFilter<'User'> | string;
    role?: StringWithAggregatesFilter<'User'> | string;
    accountSetupToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    accountSetupTokenExpires?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    twoFactorSecret?: StringNullableWithAggregatesFilter<'User'> | string | null;
    twoFactorBackupCodes?: JsonNullableWithAggregatesFilter<'User'>;
    twoFactorEnabledAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    twoFactorOTP?: JsonNullableWithAggregatesFilter<'User'>;
    trustedDevices?: JsonNullableWithAggregatesFilter<'User'>;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    isEmailVerified?: BoolWithAggregatesFilter<'User'> | boolean;
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    loginAttempts?: IntWithAggregatesFilter<'User'> | number;
    lockedUntil?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    passwordResetToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordResetTokenExpires?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
  };

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[];
    OR?: ConnectionWhereInput[];
    NOT?: ConnectionWhereInput | ConnectionWhereInput[];
    id?: StringFilter<'Connection'> | string;
    name?: StringFilter<'Connection'> | string;
    host?: StringFilter<'Connection'> | string;
    port?: IntFilter<'Connection'> | number;
    username?: StringFilter<'Connection'> | string;
    password?: StringFilter<'Connection'> | string;
    isActive?: BoolFilter<'Connection'> | boolean;
    failoverHost?: StringNullableFilter<'Connection'> | string | null;
    databases?: StringNullableListFilter<'Connection'>;
    createdById?: StringFilter<'Connection'> | string;
    organizationId?: StringFilter<'Connection'> | string;
    createdAt?: DateTimeFilter<'Connection'> | Date | string;
    updatedAt?: DateTimeFilter<'Connection'> | Date | string;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    services?: ServiceListRelationFilter;
  };

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    databases?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
    services?: ServiceOrderByRelationAggregateInput;
  };

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: ConnectionWhereInput | ConnectionWhereInput[];
      OR?: ConnectionWhereInput[];
      NOT?: ConnectionWhereInput | ConnectionWhereInput[];
      host?: StringFilter<'Connection'> | string;
      port?: IntFilter<'Connection'> | number;
      username?: StringFilter<'Connection'> | string;
      password?: StringFilter<'Connection'> | string;
      isActive?: BoolFilter<'Connection'> | boolean;
      failoverHost?: StringNullableFilter<'Connection'> | string | null;
      databases?: StringNullableListFilter<'Connection'>;
      createdById?: StringFilter<'Connection'> | string;
      organizationId?: StringFilter<'Connection'> | string;
      createdAt?: DateTimeFilter<'Connection'> | Date | string;
      updatedAt?: DateTimeFilter<'Connection'> | Date | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      services?: ServiceListRelationFilter;
    },
    'id' | 'name'
  >;

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    databases?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ConnectionCountOrderByAggregateInput;
    _avg?: ConnectionAvgOrderByAggregateInput;
    _max?: ConnectionMaxOrderByAggregateInput;
    _min?: ConnectionMinOrderByAggregateInput;
    _sum?: ConnectionSumOrderByAggregateInput;
  };

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[];
    OR?: ConnectionScalarWhereWithAggregatesInput[];
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Connection'> | string;
    name?: StringWithAggregatesFilter<'Connection'> | string;
    host?: StringWithAggregatesFilter<'Connection'> | string;
    port?: IntWithAggregatesFilter<'Connection'> | number;
    username?: StringWithAggregatesFilter<'Connection'> | string;
    password?: StringWithAggregatesFilter<'Connection'> | string;
    isActive?: BoolWithAggregatesFilter<'Connection'> | boolean;
    failoverHost?: StringNullableWithAggregatesFilter<'Connection'> | string | null;
    databases?: StringNullableListFilter<'Connection'>;
    createdById?: StringWithAggregatesFilter<'Connection'> | string;
    organizationId?: StringWithAggregatesFilter<'Connection'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Connection'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Connection'> | Date | string;
  };

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[];
    OR?: ServiceWhereInput[];
    NOT?: ServiceWhereInput | ServiceWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    label?: StringNullableFilter<'Service'> | string | null;
    description?: StringNullableFilter<'Service'> | string | null;
    host?: StringNullableFilter<'Service'> | string | null;
    port?: IntNullableFilter<'Service'> | number | null;
    database?: StringFilter<'Service'> | string;
    username?: StringNullableFilter<'Service'> | string | null;
    password?: StringNullableFilter<'Service'> | string | null;
    isActive?: BoolFilter<'Service'> | boolean;
    failoverHost?: StringNullableFilter<'Service'> | string | null;
    objects?: JsonFilter<'Service'>;
    createdById?: StringFilter<'Service'> | string;
    organizationId?: StringFilter<'Service'> | string;
    connectionId?: StringNullableFilter<'Service'> | string | null;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    applications?: ApplicationListRelationFilter;
    endpoints?: EndpointListRelationFilter;
    connection?: XOR<ConnectionNullableScalarRelationFilter, ConnectionWhereInput> | null;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    host?: SortOrderInput | SortOrder;
    port?: SortOrderInput | SortOrder;
    database?: SortOrder;
    username?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    objects?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    applications?: ApplicationOrderByRelationAggregateInput;
    endpoints?: EndpointOrderByRelationAggregateInput;
    connection?: ConnectionOrderByWithRelationInput;
    createdBy?: UserOrderByWithRelationInput;
  };

  export type ServiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: ServiceWhereInput | ServiceWhereInput[];
      OR?: ServiceWhereInput[];
      NOT?: ServiceWhereInput | ServiceWhereInput[];
      label?: StringNullableFilter<'Service'> | string | null;
      description?: StringNullableFilter<'Service'> | string | null;
      host?: StringNullableFilter<'Service'> | string | null;
      port?: IntNullableFilter<'Service'> | number | null;
      database?: StringFilter<'Service'> | string;
      username?: StringNullableFilter<'Service'> | string | null;
      password?: StringNullableFilter<'Service'> | string | null;
      isActive?: BoolFilter<'Service'> | boolean;
      failoverHost?: StringNullableFilter<'Service'> | string | null;
      objects?: JsonFilter<'Service'>;
      createdById?: StringFilter<'Service'> | string;
      organizationId?: StringFilter<'Service'> | string;
      connectionId?: StringNullableFilter<'Service'> | string | null;
      createdAt?: DateTimeFilter<'Service'> | Date | string;
      updatedAt?: DateTimeFilter<'Service'> | Date | string;
      applications?: ApplicationListRelationFilter;
      endpoints?: EndpointListRelationFilter;
      connection?: XOR<ConnectionNullableScalarRelationFilter, ConnectionWhereInput> | null;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'name'
  >;

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    host?: SortOrderInput | SortOrder;
    port?: SortOrderInput | SortOrder;
    database?: SortOrder;
    username?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrderInput | SortOrder;
    objects?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    connectionId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ServiceCountOrderByAggregateInput;
    _avg?: ServiceAvgOrderByAggregateInput;
    _max?: ServiceMaxOrderByAggregateInput;
    _min?: ServiceMinOrderByAggregateInput;
    _sum?: ServiceSumOrderByAggregateInput;
  };

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    OR?: ServiceScalarWhereWithAggregatesInput[];
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Service'> | string;
    name?: StringWithAggregatesFilter<'Service'> | string;
    label?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    description?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    host?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    port?: IntNullableWithAggregatesFilter<'Service'> | number | null;
    database?: StringWithAggregatesFilter<'Service'> | string;
    username?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    password?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    isActive?: BoolWithAggregatesFilter<'Service'> | boolean;
    failoverHost?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    objects?: JsonWithAggregatesFilter<'Service'>;
    createdById?: StringWithAggregatesFilter<'Service'> | string;
    organizationId?: StringWithAggregatesFilter<'Service'> | string;
    connectionId?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
  };

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[];
    OR?: ApplicationWhereInput[];
    NOT?: ApplicationWhereInput | ApplicationWhereInput[];
    id?: StringFilter<'Application'> | string;
    name?: StringFilter<'Application'> | string;
    description?: StringNullableFilter<'Application'> | string | null;
    isActive?: BoolFilter<'Application'> | boolean;
    configuration?: JsonNullableFilter<'Application'>;
    createdById?: StringFilter<'Application'> | string;
    organizationId?: StringFilter<'Application'> | string;
    serviceId?: StringFilter<'Application'> | string;
    createdAt?: DateTimeFilter<'Application'> | Date | string;
    updatedAt?: DateTimeFilter<'Application'> | Date | string;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    endpoints?: EndpointListRelationFilter;
  };

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
    endpoints?: EndpointOrderByRelationAggregateInput;
  };

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ApplicationWhereInput | ApplicationWhereInput[];
      OR?: ApplicationWhereInput[];
      NOT?: ApplicationWhereInput | ApplicationWhereInput[];
      name?: StringFilter<'Application'> | string;
      description?: StringNullableFilter<'Application'> | string | null;
      isActive?: BoolFilter<'Application'> | boolean;
      configuration?: JsonNullableFilter<'Application'>;
      createdById?: StringFilter<'Application'> | string;
      organizationId?: StringFilter<'Application'> | string;
      serviceId?: StringFilter<'Application'> | string;
      createdAt?: DateTimeFilter<'Application'> | Date | string;
      updatedAt?: DateTimeFilter<'Application'> | Date | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
      endpoints?: EndpointListRelationFilter;
    },
    'id'
  >;

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ApplicationCountOrderByAggregateInput;
    _max?: ApplicationMaxOrderByAggregateInput;
    _min?: ApplicationMinOrderByAggregateInput;
  };

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[];
    OR?: ApplicationScalarWhereWithAggregatesInput[];
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Application'> | string;
    name?: StringWithAggregatesFilter<'Application'> | string;
    description?: StringNullableWithAggregatesFilter<'Application'> | string | null;
    isActive?: BoolWithAggregatesFilter<'Application'> | boolean;
    configuration?: JsonNullableWithAggregatesFilter<'Application'>;
    createdById?: StringWithAggregatesFilter<'Application'> | string;
    organizationId?: StringWithAggregatesFilter<'Application'> | string;
    serviceId?: StringWithAggregatesFilter<'Application'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Application'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Application'> | Date | string;
  };

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[];
    OR?: WorkflowWhereInput[];
    NOT?: WorkflowWhereInput | WorkflowWhereInput[];
    id?: StringFilter<'Workflow'> | string;
    name?: StringFilter<'Workflow'> | string;
    active?: BoolFilter<'Workflow'> | boolean;
    schedule?: StringNullableFilter<'Workflow'> | string | null;
    lastDatabaseCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    lastHubSpotCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    nodes?: JsonFilter<'Workflow'>;
    edges?: JsonFilter<'Workflow'>;
    createdById?: StringFilter<'Workflow'> | string;
    organizationId?: StringFilter<'Workflow'> | string;
    createdAt?: DateTimeFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
    workflowRuns?: WorkflowRunListRelationFilter;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    active?: SortOrder;
    schedule?: SortOrderInput | SortOrder;
    lastDatabaseCheck?: SortOrderInput | SortOrder;
    lastHubSpotCheck?: SortOrderInput | SortOrder;
    nodes?: SortOrder;
    edges?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    workflowRuns?: WorkflowRunOrderByRelationAggregateInput;
    createdBy?: UserOrderByWithRelationInput;
  };

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WorkflowWhereInput | WorkflowWhereInput[];
      OR?: WorkflowWhereInput[];
      NOT?: WorkflowWhereInput | WorkflowWhereInput[];
      name?: StringFilter<'Workflow'> | string;
      active?: BoolFilter<'Workflow'> | boolean;
      schedule?: StringNullableFilter<'Workflow'> | string | null;
      lastDatabaseCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
      lastHubSpotCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
      nodes?: JsonFilter<'Workflow'>;
      edges?: JsonFilter<'Workflow'>;
      createdById?: StringFilter<'Workflow'> | string;
      organizationId?: StringFilter<'Workflow'> | string;
      createdAt?: DateTimeFilter<'Workflow'> | Date | string;
      updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
      workflowRuns?: WorkflowRunListRelationFilter;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    active?: SortOrder;
    schedule?: SortOrderInput | SortOrder;
    lastDatabaseCheck?: SortOrderInput | SortOrder;
    lastHubSpotCheck?: SortOrderInput | SortOrder;
    nodes?: SortOrder;
    edges?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: WorkflowCountOrderByAggregateInput;
    _max?: WorkflowMaxOrderByAggregateInput;
    _min?: WorkflowMinOrderByAggregateInput;
  };

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[];
    OR?: WorkflowScalarWhereWithAggregatesInput[];
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Workflow'> | string;
    name?: StringWithAggregatesFilter<'Workflow'> | string;
    active?: BoolWithAggregatesFilter<'Workflow'> | boolean;
    schedule?: StringNullableWithAggregatesFilter<'Workflow'> | string | null;
    lastDatabaseCheck?: DateTimeNullableWithAggregatesFilter<'Workflow'> | Date | string | null;
    lastHubSpotCheck?: DateTimeNullableWithAggregatesFilter<'Workflow'> | Date | string | null;
    nodes?: JsonWithAggregatesFilter<'Workflow'>;
    edges?: JsonWithAggregatesFilter<'Workflow'>;
    createdById?: StringWithAggregatesFilter<'Workflow'> | string;
    organizationId?: StringWithAggregatesFilter<'Workflow'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Workflow'> | Date | string;
  };

  export type WorkflowRunWhereInput = {
    AND?: WorkflowRunWhereInput | WorkflowRunWhereInput[];
    OR?: WorkflowRunWhereInput[];
    NOT?: WorkflowRunWhereInput | WorkflowRunWhereInput[];
    id?: StringFilter<'WorkflowRun'> | string;
    status?: StringFilter<'WorkflowRun'> | string;
    startedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
    completedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
    errorMessage?: StringNullableFilter<'WorkflowRun'> | string | null;
    executionData?: JsonNullableFilter<'WorkflowRun'>;
    workflowId?: StringFilter<'WorkflowRun'> | string;
    triggeredById?: StringFilter<'WorkflowRun'> | string;
    organizationId?: StringFilter<'WorkflowRun'> | string;
    createdAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
    updatedAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
    triggeredBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>;
  };

  export type WorkflowRunOrderByWithRelationInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrderInput | SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    errorMessage?: SortOrderInput | SortOrder;
    executionData?: SortOrderInput | SortOrder;
    workflowId?: SortOrder;
    triggeredById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    triggeredBy?: UserOrderByWithRelationInput;
    workflow?: WorkflowOrderByWithRelationInput;
  };

  export type WorkflowRunWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WorkflowRunWhereInput | WorkflowRunWhereInput[];
      OR?: WorkflowRunWhereInput[];
      NOT?: WorkflowRunWhereInput | WorkflowRunWhereInput[];
      status?: StringFilter<'WorkflowRun'> | string;
      startedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
      completedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
      errorMessage?: StringNullableFilter<'WorkflowRun'> | string | null;
      executionData?: JsonNullableFilter<'WorkflowRun'>;
      workflowId?: StringFilter<'WorkflowRun'> | string;
      triggeredById?: StringFilter<'WorkflowRun'> | string;
      organizationId?: StringFilter<'WorkflowRun'> | string;
      createdAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
      updatedAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
      triggeredBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>;
    },
    'id'
  >;

  export type WorkflowRunOrderByWithAggregationInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrderInput | SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    errorMessage?: SortOrderInput | SortOrder;
    executionData?: SortOrderInput | SortOrder;
    workflowId?: SortOrder;
    triggeredById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: WorkflowRunCountOrderByAggregateInput;
    _max?: WorkflowRunMaxOrderByAggregateInput;
    _min?: WorkflowRunMinOrderByAggregateInput;
  };

  export type WorkflowRunScalarWhereWithAggregatesInput = {
    AND?: WorkflowRunScalarWhereWithAggregatesInput | WorkflowRunScalarWhereWithAggregatesInput[];
    OR?: WorkflowRunScalarWhereWithAggregatesInput[];
    NOT?: WorkflowRunScalarWhereWithAggregatesInput | WorkflowRunScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'WorkflowRun'> | string;
    status?: StringWithAggregatesFilter<'WorkflowRun'> | string;
    startedAt?: DateTimeNullableWithAggregatesFilter<'WorkflowRun'> | Date | string | null;
    completedAt?: DateTimeNullableWithAggregatesFilter<'WorkflowRun'> | Date | string | null;
    errorMessage?: StringNullableWithAggregatesFilter<'WorkflowRun'> | string | null;
    executionData?: JsonNullableWithAggregatesFilter<'WorkflowRun'>;
    workflowId?: StringWithAggregatesFilter<'WorkflowRun'> | string;
    triggeredById?: StringWithAggregatesFilter<'WorkflowRun'> | string;
    organizationId?: StringWithAggregatesFilter<'WorkflowRun'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'WorkflowRun'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'WorkflowRun'> | Date | string;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    description?: StringNullableFilter<'Role'> | string | null;
    permissions?: JsonFilter<'Role'>;
    isActive?: BoolFilter<'Role'> | boolean;
    createdById?: StringFilter<'Role'> | string;
    organizationId?: StringFilter<'Role'> | string;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    permissions?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name_organizationId?: RoleNameOrganizationIdCompoundUniqueInput;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      name?: StringFilter<'Role'> | string;
      description?: StringNullableFilter<'Role'> | string | null;
      permissions?: JsonFilter<'Role'>;
      isActive?: BoolFilter<'Role'> | boolean;
      createdById?: StringFilter<'Role'> | string;
      organizationId?: StringFilter<'Role'> | string;
      createdAt?: DateTimeFilter<'Role'> | Date | string;
      updatedAt?: DateTimeFilter<'Role'> | Date | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'name_organizationId'
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    permissions?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Role'> | string;
    name?: StringWithAggregatesFilter<'Role'> | string;
    description?: StringNullableWithAggregatesFilter<'Role'> | string | null;
    permissions?: JsonWithAggregatesFilter<'Role'>;
    isActive?: BoolWithAggregatesFilter<'Role'> | boolean;
    createdById?: StringWithAggregatesFilter<'Role'> | string;
    organizationId?: StringWithAggregatesFilter<'Role'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
  };

  export type EndpointWhereInput = {
    AND?: EndpointWhereInput | EndpointWhereInput[];
    OR?: EndpointWhereInput[];
    NOT?: EndpointWhereInput | EndpointWhereInput[];
    id?: StringFilter<'Endpoint'> | string;
    name?: StringFilter<'Endpoint'> | string;
    path?: StringFilter<'Endpoint'> | string;
    method?: StringFilter<'Endpoint'> | string;
    description?: StringNullableFilter<'Endpoint'> | string | null;
    isActive?: BoolFilter<'Endpoint'> | boolean;
    configuration?: JsonNullableFilter<'Endpoint'>;
    createdById?: StringFilter<'Endpoint'> | string;
    organizationId?: StringFilter<'Endpoint'> | string;
    serviceId?: StringFilter<'Endpoint'> | string;
    applicationId?: StringNullableFilter<'Endpoint'> | string | null;
    createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
    application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
  };

  export type EndpointOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    applicationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    application?: ApplicationOrderByWithRelationInput;
    createdBy?: UserOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
  };

  export type EndpointWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: EndpointWhereInput | EndpointWhereInput[];
      OR?: EndpointWhereInput[];
      NOT?: EndpointWhereInput | EndpointWhereInput[];
      name?: StringFilter<'Endpoint'> | string;
      path?: StringFilter<'Endpoint'> | string;
      method?: StringFilter<'Endpoint'> | string;
      description?: StringNullableFilter<'Endpoint'> | string | null;
      isActive?: BoolFilter<'Endpoint'> | boolean;
      configuration?: JsonNullableFilter<'Endpoint'>;
      createdById?: StringFilter<'Endpoint'> | string;
      organizationId?: StringFilter<'Endpoint'> | string;
      serviceId?: StringFilter<'Endpoint'> | string;
      applicationId?: StringNullableFilter<'Endpoint'> | string | null;
      createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
      updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
      application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    },
    'id'
  >;

  export type EndpointOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    description?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrderInput | SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    applicationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: EndpointCountOrderByAggregateInput;
    _max?: EndpointMaxOrderByAggregateInput;
    _min?: EndpointMinOrderByAggregateInput;
  };

  export type EndpointScalarWhereWithAggregatesInput = {
    AND?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[];
    OR?: EndpointScalarWhereWithAggregatesInput[];
    NOT?: EndpointScalarWhereWithAggregatesInput | EndpointScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Endpoint'> | string;
    name?: StringWithAggregatesFilter<'Endpoint'> | string;
    path?: StringWithAggregatesFilter<'Endpoint'> | string;
    method?: StringWithAggregatesFilter<'Endpoint'> | string;
    description?: StringNullableWithAggregatesFilter<'Endpoint'> | string | null;
    isActive?: BoolWithAggregatesFilter<'Endpoint'> | boolean;
    configuration?: JsonNullableWithAggregatesFilter<'Endpoint'>;
    createdById?: StringWithAggregatesFilter<'Endpoint'> | string;
    organizationId?: StringWithAggregatesFilter<'Endpoint'> | string;
    serviceId?: StringWithAggregatesFilter<'Endpoint'> | string;
    applicationId?: StringNullableWithAggregatesFilter<'Endpoint'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Endpoint'> | Date | string;
  };

  export type ApiActivityLogWhereInput = {
    AND?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
    OR?: ApiActivityLogWhereInput[];
    NOT?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
    id?: StringFilter<'ApiActivityLog'> | string;
    method?: StringFilter<'ApiActivityLog'> | string;
    endpoint?: StringFilter<'ApiActivityLog'> | string;
    statusCode?: IntFilter<'ApiActivityLog'> | number;
    responseTime?: IntFilter<'ApiActivityLog'> | number;
    requestBody?: JsonNullableFilter<'ApiActivityLog'>;
    responseBody?: JsonNullableFilter<'ApiActivityLog'>;
    userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
    userId?: StringFilter<'ApiActivityLog'> | string;
    organizationId?: StringFilter<'ApiActivityLog'> | string;
    createdAt?: DateTimeFilter<'ApiActivityLog'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ApiActivityLogOrderByWithRelationInput = {
    id?: SortOrder;
    method?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    requestBody?: SortOrderInput | SortOrder;
    responseBody?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type ApiActivityLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
      OR?: ApiActivityLogWhereInput[];
      NOT?: ApiActivityLogWhereInput | ApiActivityLogWhereInput[];
      method?: StringFilter<'ApiActivityLog'> | string;
      endpoint?: StringFilter<'ApiActivityLog'> | string;
      statusCode?: IntFilter<'ApiActivityLog'> | number;
      responseTime?: IntFilter<'ApiActivityLog'> | number;
      requestBody?: JsonNullableFilter<'ApiActivityLog'>;
      responseBody?: JsonNullableFilter<'ApiActivityLog'>;
      userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
      ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
      userId?: StringFilter<'ApiActivityLog'> | string;
      organizationId?: StringFilter<'ApiActivityLog'> | string;
      createdAt?: DateTimeFilter<'ApiActivityLog'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type ApiActivityLogOrderByWithAggregationInput = {
    id?: SortOrder;
    method?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    requestBody?: SortOrderInput | SortOrder;
    responseBody?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    _count?: ApiActivityLogCountOrderByAggregateInput;
    _avg?: ApiActivityLogAvgOrderByAggregateInput;
    _max?: ApiActivityLogMaxOrderByAggregateInput;
    _min?: ApiActivityLogMinOrderByAggregateInput;
    _sum?: ApiActivityLogSumOrderByAggregateInput;
  };

  export type ApiActivityLogScalarWhereWithAggregatesInput = {
    AND?:
      | ApiActivityLogScalarWhereWithAggregatesInput
      | ApiActivityLogScalarWhereWithAggregatesInput[];
    OR?: ApiActivityLogScalarWhereWithAggregatesInput[];
    NOT?:
      | ApiActivityLogScalarWhereWithAggregatesInput
      | ApiActivityLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    method?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    endpoint?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    statusCode?: IntWithAggregatesFilter<'ApiActivityLog'> | number;
    responseTime?: IntWithAggregatesFilter<'ApiActivityLog'> | number;
    requestBody?: JsonNullableWithAggregatesFilter<'ApiActivityLog'>;
    responseBody?: JsonNullableWithAggregatesFilter<'ApiActivityLog'>;
    userAgent?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableWithAggregatesFilter<'ApiActivityLog'> | string | null;
    userId?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    organizationId?: StringWithAggregatesFilter<'ApiActivityLog'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'ApiActivityLog'> | Date | string;
  };

  export type ApiUsageWhereInput = {
    AND?: ApiUsageWhereInput | ApiUsageWhereInput[];
    OR?: ApiUsageWhereInput[];
    NOT?: ApiUsageWhereInput | ApiUsageWhereInput[];
    id?: StringFilter<'ApiUsage'> | string;
    endpoint?: StringFilter<'ApiUsage'> | string;
    method?: StringFilter<'ApiUsage'> | string;
    callCount?: IntFilter<'ApiUsage'> | number;
    totalResponseTime?: IntFilter<'ApiUsage'> | number;
    userId?: StringFilter<'ApiUsage'> | string;
    organizationId?: StringFilter<'ApiUsage'> | string;
    createdAt?: DateTimeFilter<'ApiUsage'> | Date | string;
    updatedAt?: DateTimeFilter<'ApiUsage'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ApiUsageOrderByWithRelationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type ApiUsageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_endpoint_method?: ApiUsageUserIdEndpointMethodCompoundUniqueInput;
      AND?: ApiUsageWhereInput | ApiUsageWhereInput[];
      OR?: ApiUsageWhereInput[];
      NOT?: ApiUsageWhereInput | ApiUsageWhereInput[];
      endpoint?: StringFilter<'ApiUsage'> | string;
      method?: StringFilter<'ApiUsage'> | string;
      callCount?: IntFilter<'ApiUsage'> | number;
      totalResponseTime?: IntFilter<'ApiUsage'> | number;
      userId?: StringFilter<'ApiUsage'> | string;
      organizationId?: StringFilter<'ApiUsage'> | string;
      createdAt?: DateTimeFilter<'ApiUsage'> | Date | string;
      updatedAt?: DateTimeFilter<'ApiUsage'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'userId_endpoint_method'
  >;

  export type ApiUsageOrderByWithAggregationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ApiUsageCountOrderByAggregateInput;
    _avg?: ApiUsageAvgOrderByAggregateInput;
    _max?: ApiUsageMaxOrderByAggregateInput;
    _min?: ApiUsageMinOrderByAggregateInput;
    _sum?: ApiUsageSumOrderByAggregateInput;
  };

  export type ApiUsageScalarWhereWithAggregatesInput = {
    AND?: ApiUsageScalarWhereWithAggregatesInput | ApiUsageScalarWhereWithAggregatesInput[];
    OR?: ApiUsageScalarWhereWithAggregatesInput[];
    NOT?: ApiUsageScalarWhereWithAggregatesInput | ApiUsageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApiUsage'> | string;
    endpoint?: StringWithAggregatesFilter<'ApiUsage'> | string;
    method?: StringWithAggregatesFilter<'ApiUsage'> | string;
    callCount?: IntWithAggregatesFilter<'ApiUsage'> | number;
    totalResponseTime?: IntWithAggregatesFilter<'ApiUsage'> | number;
    userId?: StringWithAggregatesFilter<'ApiUsage'> | string;
    organizationId?: StringWithAggregatesFilter<'ApiUsage'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'ApiUsage'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ApiUsage'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    isRead?: BoolFilter<'Notification'> | boolean;
    data?: JsonNullableFilter<'Notification'>;
    userId?: StringFilter<'Notification'> | string;
    organizationId?: StringFilter<'Notification'> | string;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    isRead?: SortOrder;
    data?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      type?: StringFilter<'Notification'> | string;
      isRead?: BoolFilter<'Notification'> | boolean;
      data?: JsonNullableFilter<'Notification'>;
      userId?: StringFilter<'Notification'> | string;
      organizationId?: StringFilter<'Notification'> | string;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      updatedAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    isRead?: SortOrder;
    data?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    type?: StringWithAggregatesFilter<'Notification'> | string;
    isRead?: BoolWithAggregatesFilter<'Notification'> | boolean;
    data?: JsonNullableWithAggregatesFilter<'Notification'>;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    organizationId?: StringWithAggregatesFilter<'Notification'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type UserLogWhereInput = {
    AND?: UserLogWhereInput | UserLogWhereInput[];
    OR?: UserLogWhereInput[];
    NOT?: UserLogWhereInput | UserLogWhereInput[];
    id?: StringFilter<'UserLog'> | string;
    action?: StringFilter<'UserLog'> | string;
    details?: JsonNullableFilter<'UserLog'>;
    ipAddress?: StringNullableFilter<'UserLog'> | string | null;
    userAgent?: StringNullableFilter<'UserLog'> | string | null;
    userId?: StringFilter<'UserLog'> | string;
    organizationId?: StringFilter<'UserLog'> | string;
    createdAt?: DateTimeFilter<'UserLog'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type UserLogOrderByWithRelationInput = {
    id?: SortOrder;
    action?: SortOrder;
    details?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type UserLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: UserLogWhereInput | UserLogWhereInput[];
      OR?: UserLogWhereInput[];
      NOT?: UserLogWhereInput | UserLogWhereInput[];
      action?: StringFilter<'UserLog'> | string;
      details?: JsonNullableFilter<'UserLog'>;
      ipAddress?: StringNullableFilter<'UserLog'> | string | null;
      userAgent?: StringNullableFilter<'UserLog'> | string | null;
      userId?: StringFilter<'UserLog'> | string;
      organizationId?: StringFilter<'UserLog'> | string;
      createdAt?: DateTimeFilter<'UserLog'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type UserLogOrderByWithAggregationInput = {
    id?: SortOrder;
    action?: SortOrder;
    details?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserLogCountOrderByAggregateInput;
    _max?: UserLogMaxOrderByAggregateInput;
    _min?: UserLogMinOrderByAggregateInput;
  };

  export type UserLogScalarWhereWithAggregatesInput = {
    AND?: UserLogScalarWhereWithAggregatesInput | UserLogScalarWhereWithAggregatesInput[];
    OR?: UserLogScalarWhereWithAggregatesInput[];
    NOT?: UserLogScalarWhereWithAggregatesInput | UserLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserLog'> | string;
    action?: StringWithAggregatesFilter<'UserLog'> | string;
    details?: JsonNullableWithAggregatesFilter<'UserLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'UserLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'UserLog'> | string | null;
    userId?: StringWithAggregatesFilter<'UserLog'> | string;
    organizationId?: StringWithAggregatesFilter<'UserLog'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'UserLog'> | Date | string;
  };

  export type DatabaseObjectWhereInput = {
    AND?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
    OR?: DatabaseObjectWhereInput[];
    NOT?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
    id?: StringFilter<'DatabaseObject'> | string;
    name?: StringFilter<'DatabaseObject'> | string;
    type?: StringFilter<'DatabaseObject'> | string;
    schema?: StringNullableFilter<'DatabaseObject'> | string | null;
    definition?: StringNullableFilter<'DatabaseObject'> | string | null;
    metadata?: JsonNullableFilter<'DatabaseObject'>;
    organizationId?: StringFilter<'DatabaseObject'> | string;
    createdAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    updatedAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
  };

  export type DatabaseObjectOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    definition?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DatabaseObjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
      OR?: DatabaseObjectWhereInput[];
      NOT?: DatabaseObjectWhereInput | DatabaseObjectWhereInput[];
      name?: StringFilter<'DatabaseObject'> | string;
      type?: StringFilter<'DatabaseObject'> | string;
      schema?: StringNullableFilter<'DatabaseObject'> | string | null;
      definition?: StringNullableFilter<'DatabaseObject'> | string | null;
      metadata?: JsonNullableFilter<'DatabaseObject'>;
      organizationId?: StringFilter<'DatabaseObject'> | string;
      createdAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
      updatedAt?: DateTimeFilter<'DatabaseObject'> | Date | string;
    },
    'id'
  >;

  export type DatabaseObjectOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    schema?: SortOrderInput | SortOrder;
    definition?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DatabaseObjectCountOrderByAggregateInput;
    _max?: DatabaseObjectMaxOrderByAggregateInput;
    _min?: DatabaseObjectMinOrderByAggregateInput;
  };

  export type DatabaseObjectScalarWhereWithAggregatesInput = {
    AND?:
      | DatabaseObjectScalarWhereWithAggregatesInput
      | DatabaseObjectScalarWhereWithAggregatesInput[];
    OR?: DatabaseObjectScalarWhereWithAggregatesInput[];
    NOT?:
      | DatabaseObjectScalarWhereWithAggregatesInput
      | DatabaseObjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    name?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    type?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    schema?: StringNullableWithAggregatesFilter<'DatabaseObject'> | string | null;
    definition?: StringNullableWithAggregatesFilter<'DatabaseObject'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'DatabaseObject'>;
    organizationId?: StringWithAggregatesFilter<'DatabaseObject'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'DatabaseObject'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'DatabaseObject'> | Date | string;
  };

  export type SchemaIntelligenceWhereInput = {
    AND?: SchemaIntelligenceWhereInput | SchemaIntelligenceWhereInput[];
    OR?: SchemaIntelligenceWhereInput[];
    NOT?: SchemaIntelligenceWhereInput | SchemaIntelligenceWhereInput[];
    id?: StringFilter<'SchemaIntelligence'> | string;
    entityName?: StringFilter<'SchemaIntelligence'> | string;
    entityType?: StringFilter<'SchemaIntelligence'> | string;
    confidence?: FloatFilter<'SchemaIntelligence'> | number;
    analysis?: JsonFilter<'SchemaIntelligence'>;
    procedures?: JsonFilter<'SchemaIntelligence'>;
    organizationId?: StringFilter<'SchemaIntelligence'> | string;
    createdAt?: DateTimeFilter<'SchemaIntelligence'> | Date | string;
    updatedAt?: DateTimeFilter<'SchemaIntelligence'> | Date | string;
  };

  export type SchemaIntelligenceOrderByWithRelationInput = {
    id?: SortOrder;
    entityName?: SortOrder;
    entityType?: SortOrder;
    confidence?: SortOrder;
    analysis?: SortOrder;
    procedures?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SchemaIntelligenceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SchemaIntelligenceWhereInput | SchemaIntelligenceWhereInput[];
      OR?: SchemaIntelligenceWhereInput[];
      NOT?: SchemaIntelligenceWhereInput | SchemaIntelligenceWhereInput[];
      entityName?: StringFilter<'SchemaIntelligence'> | string;
      entityType?: StringFilter<'SchemaIntelligence'> | string;
      confidence?: FloatFilter<'SchemaIntelligence'> | number;
      analysis?: JsonFilter<'SchemaIntelligence'>;
      procedures?: JsonFilter<'SchemaIntelligence'>;
      organizationId?: StringFilter<'SchemaIntelligence'> | string;
      createdAt?: DateTimeFilter<'SchemaIntelligence'> | Date | string;
      updatedAt?: DateTimeFilter<'SchemaIntelligence'> | Date | string;
    },
    'id'
  >;

  export type SchemaIntelligenceOrderByWithAggregationInput = {
    id?: SortOrder;
    entityName?: SortOrder;
    entityType?: SortOrder;
    confidence?: SortOrder;
    analysis?: SortOrder;
    procedures?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SchemaIntelligenceCountOrderByAggregateInput;
    _avg?: SchemaIntelligenceAvgOrderByAggregateInput;
    _max?: SchemaIntelligenceMaxOrderByAggregateInput;
    _min?: SchemaIntelligenceMinOrderByAggregateInput;
    _sum?: SchemaIntelligenceSumOrderByAggregateInput;
  };

  export type SchemaIntelligenceScalarWhereWithAggregatesInput = {
    AND?:
      | SchemaIntelligenceScalarWhereWithAggregatesInput
      | SchemaIntelligenceScalarWhereWithAggregatesInput[];
    OR?: SchemaIntelligenceScalarWhereWithAggregatesInput[];
    NOT?:
      | SchemaIntelligenceScalarWhereWithAggregatesInput
      | SchemaIntelligenceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SchemaIntelligence'> | string;
    entityName?: StringWithAggregatesFilter<'SchemaIntelligence'> | string;
    entityType?: StringWithAggregatesFilter<'SchemaIntelligence'> | string;
    confidence?: FloatWithAggregatesFilter<'SchemaIntelligence'> | number;
    analysis?: JsonWithAggregatesFilter<'SchemaIntelligence'>;
    procedures?: JsonWithAggregatesFilter<'SchemaIntelligence'>;
    organizationId?: StringWithAggregatesFilter<'SchemaIntelligence'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'SchemaIntelligence'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'SchemaIntelligence'> | Date | string;
  };

  export type GeneratedArtifactWhereInput = {
    AND?: GeneratedArtifactWhereInput | GeneratedArtifactWhereInput[];
    OR?: GeneratedArtifactWhereInput[];
    NOT?: GeneratedArtifactWhereInput | GeneratedArtifactWhereInput[];
    id?: StringFilter<'GeneratedArtifact'> | string;
    name?: StringFilter<'GeneratedArtifact'> | string;
    type?: StringFilter<'GeneratedArtifact'> | string;
    content?: StringFilter<'GeneratedArtifact'> | string;
    metadata?: JsonNullableFilter<'GeneratedArtifact'>;
    isActive?: BoolFilter<'GeneratedArtifact'> | boolean;
    organizationId?: StringFilter<'GeneratedArtifact'> | string;
    createdAt?: DateTimeFilter<'GeneratedArtifact'> | Date | string;
    updatedAt?: DateTimeFilter<'GeneratedArtifact'> | Date | string;
  };

  export type GeneratedArtifactOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    content?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GeneratedArtifactWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: GeneratedArtifactWhereInput | GeneratedArtifactWhereInput[];
      OR?: GeneratedArtifactWhereInput[];
      NOT?: GeneratedArtifactWhereInput | GeneratedArtifactWhereInput[];
      name?: StringFilter<'GeneratedArtifact'> | string;
      type?: StringFilter<'GeneratedArtifact'> | string;
      content?: StringFilter<'GeneratedArtifact'> | string;
      metadata?: JsonNullableFilter<'GeneratedArtifact'>;
      isActive?: BoolFilter<'GeneratedArtifact'> | boolean;
      organizationId?: StringFilter<'GeneratedArtifact'> | string;
      createdAt?: DateTimeFilter<'GeneratedArtifact'> | Date | string;
      updatedAt?: DateTimeFilter<'GeneratedArtifact'> | Date | string;
    },
    'id'
  >;

  export type GeneratedArtifactOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    content?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: GeneratedArtifactCountOrderByAggregateInput;
    _max?: GeneratedArtifactMaxOrderByAggregateInput;
    _min?: GeneratedArtifactMinOrderByAggregateInput;
  };

  export type GeneratedArtifactScalarWhereWithAggregatesInput = {
    AND?:
      | GeneratedArtifactScalarWhereWithAggregatesInput
      | GeneratedArtifactScalarWhereWithAggregatesInput[];
    OR?: GeneratedArtifactScalarWhereWithAggregatesInput[];
    NOT?:
      | GeneratedArtifactScalarWhereWithAggregatesInput
      | GeneratedArtifactScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'GeneratedArtifact'> | string;
    name?: StringWithAggregatesFilter<'GeneratedArtifact'> | string;
    type?: StringWithAggregatesFilter<'GeneratedArtifact'> | string;
    content?: StringWithAggregatesFilter<'GeneratedArtifact'> | string;
    metadata?: JsonNullableWithAggregatesFilter<'GeneratedArtifact'>;
    isActive?: BoolWithAggregatesFilter<'GeneratedArtifact'> | boolean;
    organizationId?: StringWithAggregatesFilter<'GeneratedArtifact'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'GeneratedArtifact'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'GeneratedArtifact'> | Date | string;
  };

  export type RateLimitConfigWhereInput = {
    AND?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
    OR?: RateLimitConfigWhereInput[];
    NOT?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
    id?: StringFilter<'RateLimitConfig'> | string;
    identifier?: StringFilter<'RateLimitConfig'> | string;
    type?: StringFilter<'RateLimitConfig'> | string;
    limit?: IntFilter<'RateLimitConfig'> | number;
    windowMs?: IntFilter<'RateLimitConfig'> | number;
    isActive?: BoolFilter<'RateLimitConfig'> | boolean;
    organizationId?: StringNullableFilter<'RateLimitConfig'> | string | null;
    createdAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    updatedAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
  };

  export type RateLimitConfigOrderByWithRelationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    limit?: SortOrder;
    windowMs?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RateLimitConfigWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      identifier_type?: RateLimitConfigIdentifierTypeCompoundUniqueInput;
      AND?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
      OR?: RateLimitConfigWhereInput[];
      NOT?: RateLimitConfigWhereInput | RateLimitConfigWhereInput[];
      identifier?: StringFilter<'RateLimitConfig'> | string;
      type?: StringFilter<'RateLimitConfig'> | string;
      limit?: IntFilter<'RateLimitConfig'> | number;
      windowMs?: IntFilter<'RateLimitConfig'> | number;
      isActive?: BoolFilter<'RateLimitConfig'> | boolean;
      organizationId?: StringNullableFilter<'RateLimitConfig'> | string | null;
      createdAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
      updatedAt?: DateTimeFilter<'RateLimitConfig'> | Date | string;
    },
    'id' | 'identifier_type'
  >;

  export type RateLimitConfigOrderByWithAggregationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    limit?: SortOrder;
    windowMs?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RateLimitConfigCountOrderByAggregateInput;
    _avg?: RateLimitConfigAvgOrderByAggregateInput;
    _max?: RateLimitConfigMaxOrderByAggregateInput;
    _min?: RateLimitConfigMinOrderByAggregateInput;
    _sum?: RateLimitConfigSumOrderByAggregateInput;
  };

  export type RateLimitConfigScalarWhereWithAggregatesInput = {
    AND?:
      | RateLimitConfigScalarWhereWithAggregatesInput
      | RateLimitConfigScalarWhereWithAggregatesInput[];
    OR?: RateLimitConfigScalarWhereWithAggregatesInput[];
    NOT?:
      | RateLimitConfigScalarWhereWithAggregatesInput
      | RateLimitConfigScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    identifier?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    type?: StringWithAggregatesFilter<'RateLimitConfig'> | string;
    limit?: IntWithAggregatesFilter<'RateLimitConfig'> | number;
    windowMs?: IntWithAggregatesFilter<'RateLimitConfig'> | number;
    isActive?: BoolWithAggregatesFilter<'RateLimitConfig'> | boolean;
    organizationId?: StringNullableWithAggregatesFilter<'RateLimitConfig'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'RateLimitConfig'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RateLimitConfig'> | Date | string;
  };

  export type OrganizationCreateInput = {
    id?: string;
    name: string;
    slug: string;
    isActive?: boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    isActive?: boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput;
  };

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput;
  };

  export type OrganizationCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    isActive?: boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConnectionCreateInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutConnectionsInput;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type ConnectionUncheckedCreateInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type ConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutConnectionsNestedInput;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type ConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type ConnectionCreateManyInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceCreateInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointCreateNestedManyWithoutServiceInput;
    connection?: ConnectionCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUpdateManyWithoutServiceNestedInput;
    connection?: ConnectionUpdateOneWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUncheckedUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceCreateManyInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApplicationCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApplicationsInput;
    service: ServiceCreateNestedOneWithoutApplicationsInput;
    endpoints?: EndpointCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApplicationsNestedInput;
    service?: ServiceUpdateOneRequiredWithoutApplicationsNestedInput;
    endpoints?: EndpointUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endpoints?: EndpointUncheckedUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowCreateInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutWorkflowInput;
    createdBy: UserCreateNestedOneWithoutWorkflowsInput;
  };

  export type WorkflowUncheckedCreateInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    workflowRuns?: WorkflowRunUpdateManyWithoutWorkflowNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutWorkflowsNestedInput;
  };

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowCreateManyInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunCreateInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    triggeredBy: UserCreateNestedOneWithoutWorkflowRunsInput;
    workflow: WorkflowCreateNestedOneWithoutWorkflowRunsInput;
  };

  export type WorkflowRunUncheckedCreateInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
    triggeredById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    triggeredBy?: UserUpdateOneRequiredWithoutWorkflowRunsNestedInput;
    workflow?: WorkflowUpdateOneRequiredWithoutWorkflowRunsNestedInput;
  };

  export type WorkflowRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
    triggeredById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunCreateManyInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
    triggeredById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
    triggeredById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutRolesInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointCreateInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    application?: ApplicationCreateNestedOneWithoutEndpointsInput;
    createdBy: UserCreateNestedOneWithoutEndpointsInput;
    service: ServiceCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    application?: ApplicationUpdateOneWithoutEndpointsNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutEndpointsNestedInput;
    service?: ServiceUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointCreateManyInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogCreateInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    organizationId: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutApiActivityLogsInput;
  };

  export type ApiActivityLogUncheckedCreateInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type ApiActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutApiActivityLogsNestedInput;
  };

  export type ApiActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogCreateManyInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type ApiActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageCreateInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutApiUsageInput;
  };

  export type ApiUsageUncheckedCreateInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutApiUsageNestedInput;
  };

  export type ApiUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageCreateManyInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogCreateInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    organizationId: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutUserLogsInput;
  };

  export type UserLogUncheckedCreateInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type UserLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutUserLogsNestedInput;
  };

  export type UserLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogCreateManyInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type UserLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DatabaseObjectCreateInput = {
    id?: string;
    name: string;
    type: string;
    schema?: string | null;
    definition?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DatabaseObjectUncheckedCreateInput = {
    id?: string;
    name: string;
    type: string;
    schema?: string | null;
    definition?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DatabaseObjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DatabaseObjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DatabaseObjectCreateManyInput = {
    id?: string;
    name: string;
    type: string;
    schema?: string | null;
    definition?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DatabaseObjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DatabaseObjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    schema?: NullableStringFieldUpdateOperationsInput | string | null;
    definition?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SchemaIntelligenceCreateInput = {
    id?: string;
    entityName: string;
    entityType: string;
    confidence: number;
    analysis: JsonNullValueInput | InputJsonValue;
    procedures: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SchemaIntelligenceUncheckedCreateInput = {
    id?: string;
    entityName: string;
    entityType: string;
    confidence: number;
    analysis: JsonNullValueInput | InputJsonValue;
    procedures: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SchemaIntelligenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    analysis?: JsonNullValueInput | InputJsonValue;
    procedures?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SchemaIntelligenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    analysis?: JsonNullValueInput | InputJsonValue;
    procedures?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SchemaIntelligenceCreateManyInput = {
    id?: string;
    entityName: string;
    entityType: string;
    confidence: number;
    analysis: JsonNullValueInput | InputJsonValue;
    procedures: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SchemaIntelligenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    analysis?: JsonNullValueInput | InputJsonValue;
    procedures?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SchemaIntelligenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    confidence?: FloatFieldUpdateOperationsInput | number;
    analysis?: JsonNullValueInput | InputJsonValue;
    procedures?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GeneratedArtifactCreateInput = {
    id?: string;
    name: string;
    type: string;
    content: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GeneratedArtifactUncheckedCreateInput = {
    id?: string;
    name: string;
    type: string;
    content: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GeneratedArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GeneratedArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GeneratedArtifactCreateManyInput = {
    id?: string;
    name: string;
    type: string;
    content: string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GeneratedArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GeneratedArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitConfigCreateInput = {
    id?: string;
    identifier: string;
    type: string;
    limit: number;
    windowMs: number;
    isActive?: boolean;
    organizationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RateLimitConfigUncheckedCreateInput = {
    id?: string;
    identifier: string;
    type: string;
    limit: number;
    windowMs: number;
    isActive?: boolean;
    organizationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RateLimitConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    limit?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    limit?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitConfigCreateManyInput = {
    id?: string;
    identifier: string;
    type: string;
    limit: number;
    windowMs: number;
    isActive?: boolean;
    organizationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RateLimitConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    limit?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RateLimitConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    limit?: IntFieldUpdateOperationsInput | number;
    windowMs?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    isActive?: SortOrder;
    settings?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type ApiActivityLogListRelationFilter = {
    every?: ApiActivityLogWhereInput;
    some?: ApiActivityLogWhereInput;
    none?: ApiActivityLogWhereInput;
  };

  export type ApiUsageListRelationFilter = {
    every?: ApiUsageWhereInput;
    some?: ApiUsageWhereInput;
    none?: ApiUsageWhereInput;
  };

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput;
    some?: ApplicationWhereInput;
    none?: ApplicationWhereInput;
  };

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput;
    some?: ConnectionWhereInput;
    none?: ConnectionWhereInput;
  };

  export type EndpointListRelationFilter = {
    every?: EndpointWhereInput;
    some?: EndpointWhereInput;
    none?: EndpointWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type RoleListRelationFilter = {
    every?: RoleWhereInput;
    some?: RoleWhereInput;
    none?: RoleWhereInput;
  };

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput;
    some?: ServiceWhereInput;
    none?: ServiceWhereInput;
  };

  export type UserLogListRelationFilter = {
    every?: UserLogWhereInput;
    some?: UserLogWhereInput;
    none?: UserLogWhereInput;
  };

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput;
    isNot?: OrganizationWhereInput;
  };

  export type WorkflowRunListRelationFilter = {
    every?: WorkflowRunWhereInput;
    some?: WorkflowRunWhereInput;
    none?: WorkflowRunWhereInput;
  };

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput;
    some?: WorkflowWhereInput;
    none?: WorkflowWhereInput;
  };

  export type ApiActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ApiUsageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EndpointOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WorkflowRunOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    phone?: SortOrder;
    phoneCarrier?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    accountSetupToken?: SortOrder;
    accountSetupTokenExpires?: SortOrder;
    twoFactorSecret?: SortOrder;
    twoFactorBackupCodes?: SortOrder;
    twoFactorEnabledAt?: SortOrder;
    twoFactorOTP?: SortOrder;
    trustedDevices?: SortOrder;
    isActive?: SortOrder;
    isEmailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetTokenExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    phone?: SortOrder;
    phoneCarrier?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    accountSetupToken?: SortOrder;
    accountSetupTokenExpires?: SortOrder;
    twoFactorSecret?: SortOrder;
    twoFactorEnabledAt?: SortOrder;
    isActive?: SortOrder;
    isEmailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetTokenExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    password?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    phone?: SortOrder;
    phoneCarrier?: SortOrder;
    organizationId?: SortOrder;
    role?: SortOrder;
    accountSetupToken?: SortOrder;
    accountSetupTokenExpires?: SortOrder;
    twoFactorSecret?: SortOrder;
    twoFactorEnabledAt?: SortOrder;
    isActive?: SortOrder;
    isEmailVerified?: SortOrder;
    lastLoginAt?: SortOrder;
    loginAttempts?: SortOrder;
    lockedUntil?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetTokenExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    databases?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ConnectionAvgOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ConnectionSumOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type ConnectionNullableScalarRelationFilter = {
    is?: ConnectionWhereInput | null;
    isNot?: ConnectionWhereInput | null;
  };

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    objects?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    connectionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceAvgOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    connectionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    description?: SortOrder;
    host?: SortOrder;
    port?: SortOrder;
    database?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    isActive?: SortOrder;
    failoverHost?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    connectionId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceSumOrderByAggregateInput = {
    port?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput;
    isNot?: ServiceWhereInput;
  };

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    active?: SortOrder;
    schedule?: SortOrder;
    lastDatabaseCheck?: SortOrder;
    lastHubSpotCheck?: SortOrder;
    nodes?: SortOrder;
    edges?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    active?: SortOrder;
    schedule?: SortOrder;
    lastDatabaseCheck?: SortOrder;
    lastHubSpotCheck?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    active?: SortOrder;
    schedule?: SortOrder;
    lastDatabaseCheck?: SortOrder;
    lastHubSpotCheck?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowScalarRelationFilter = {
    is?: WorkflowWhereInput;
    isNot?: WorkflowWhereInput;
  };

  export type WorkflowRunCountOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    errorMessage?: SortOrder;
    executionData?: SortOrder;
    workflowId?: SortOrder;
    triggeredById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowRunMaxOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    errorMessage?: SortOrder;
    workflowId?: SortOrder;
    triggeredById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type WorkflowRunMinOrderByAggregateInput = {
    id?: SortOrder;
    status?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    errorMessage?: SortOrder;
    workflowId?: SortOrder;
    triggeredById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleNameOrganizationIdCompoundUniqueInput = {
    name: string;
    organizationId: string;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    permissions?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApplicationNullableScalarRelationFilter = {
    is?: ApplicationWhereInput | null;
    isNot?: ApplicationWhereInput | null;
  };

  export type EndpointCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    configuration?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    applicationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EndpointMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    applicationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EndpointMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    path?: SortOrder;
    method?: SortOrder;
    description?: SortOrder;
    isActive?: SortOrder;
    createdById?: SortOrder;
    organizationId?: SortOrder;
    serviceId?: SortOrder;
    applicationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApiActivityLogCountOrderByAggregateInput = {
    id?: SortOrder;
    method?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    requestBody?: SortOrder;
    responseBody?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ApiActivityLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTime?: SortOrder;
  };

  export type ApiActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    method?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ApiActivityLogMinOrderByAggregateInput = {
    id?: SortOrder;
    method?: SortOrder;
    endpoint?: SortOrder;
    statusCode?: SortOrder;
    responseTime?: SortOrder;
    userAgent?: SortOrder;
    ipAddress?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ApiActivityLogSumOrderByAggregateInput = {
    statusCode?: SortOrder;
    responseTime?: SortOrder;
  };

  export type ApiUsageUserIdEndpointMethodCompoundUniqueInput = {
    userId: string;
    endpoint: string;
    method: string;
  };

  export type ApiUsageCountOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApiUsageAvgOrderByAggregateInput = {
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
  };

  export type ApiUsageMaxOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApiUsageMinOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    method?: SortOrder;
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApiUsageSumOrderByAggregateInput = {
    callCount?: SortOrder;
    totalResponseTime?: SortOrder;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    isRead?: SortOrder;
    data?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    isRead?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    isRead?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserLogCountOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    details?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserLogMinOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type DatabaseObjectCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    schema?: SortOrder;
    definition?: SortOrder;
    metadata?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DatabaseObjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    schema?: SortOrder;
    definition?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DatabaseObjectMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    schema?: SortOrder;
    definition?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type SchemaIntelligenceCountOrderByAggregateInput = {
    id?: SortOrder;
    entityName?: SortOrder;
    entityType?: SortOrder;
    confidence?: SortOrder;
    analysis?: SortOrder;
    procedures?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SchemaIntelligenceAvgOrderByAggregateInput = {
    confidence?: SortOrder;
  };

  export type SchemaIntelligenceMaxOrderByAggregateInput = {
    id?: SortOrder;
    entityName?: SortOrder;
    entityType?: SortOrder;
    confidence?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SchemaIntelligenceMinOrderByAggregateInput = {
    id?: SortOrder;
    entityName?: SortOrder;
    entityType?: SortOrder;
    confidence?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SchemaIntelligenceSumOrderByAggregateInput = {
    confidence?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type GeneratedArtifactCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    content?: SortOrder;
    metadata?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GeneratedArtifactMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    content?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GeneratedArtifactMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    content?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RateLimitConfigIdentifierTypeCompoundUniqueInput = {
    identifier: string;
    type: string;
  };

  export type RateLimitConfigCountOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    limit?: SortOrder;
    windowMs?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RateLimitConfigAvgOrderByAggregateInput = {
    limit?: SortOrder;
    windowMs?: SortOrder;
  };

  export type RateLimitConfigMaxOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    limit?: SortOrder;
    windowMs?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RateLimitConfigMinOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    limit?: SortOrder;
    windowMs?: SortOrder;
    isActive?: SortOrder;
    organizationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RateLimitConfigSumOrderByAggregateInput = {
    limit?: SortOrder;
    windowMs?: SortOrder;
  };

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
      | UserCreateWithoutOrganizationInput[]
      | UserUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizationInput
      | UserCreateOrConnectWithoutOrganizationInput[];
    createMany?: UserCreateManyOrganizationInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?:
      | XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
      | UserCreateWithoutOrganizationInput[]
      | UserUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizationInput
      | UserCreateOrConnectWithoutOrganizationInput[];
    createMany?: UserCreateManyOrganizationInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
      | UserCreateWithoutOrganizationInput[]
      | UserUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizationInput
      | UserCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutOrganizationInput
      | UserUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: UserCreateManyOrganizationInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutOrganizationInput
      | UserUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutOrganizationInput
      | UserUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?:
      | XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
      | UserCreateWithoutOrganizationInput[]
      | UserUncheckedCreateWithoutOrganizationInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutOrganizationInput
      | UserCreateOrConnectWithoutOrganizationInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutOrganizationInput
      | UserUpsertWithWhereUniqueWithoutOrganizationInput[];
    createMany?: UserCreateManyOrganizationInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutOrganizationInput
      | UserUpdateWithWhereUniqueWithoutOrganizationInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutOrganizationInput
      | UserUpdateManyWithWhereWithoutOrganizationInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type ApiActivityLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiUsageCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
      | ApiUsageCreateWithoutUserInput[]
      | ApiUsageUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiUsageCreateOrConnectWithoutUserInput
      | ApiUsageCreateOrConnectWithoutUserInput[];
    createMany?: ApiUsageCreateManyUserInputEnvelope;
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
  };

  export type ApplicationCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatedByInput, ApplicationUncheckedCreateWithoutCreatedByInput>
      | ApplicationCreateWithoutCreatedByInput[]
      | ApplicationUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatedByInput
      | ApplicationCreateOrConnectWithoutCreatedByInput[];
    createMany?: ApplicationCreateManyCreatedByInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type ConnectionCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ConnectionCreateWithoutCreatedByInput, ConnectionUncheckedCreateWithoutCreatedByInput>
      | ConnectionCreateWithoutCreatedByInput[]
      | ConnectionUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ConnectionCreateOrConnectWithoutCreatedByInput
      | ConnectionCreateOrConnectWithoutCreatedByInput[];
    createMany?: ConnectionCreateManyCreatedByInputEnvelope;
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
  };

  export type EndpointCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>
      | EndpointCreateWithoutCreatedByInput[]
      | EndpointUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatedByInput
      | EndpointCreateOrConnectWithoutCreatedByInput[];
    createMany?: EndpointCreateManyCreatedByInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
      | RoleCreateWithoutCreatedByInput[]
      | RoleUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatedByInput
      | RoleCreateOrConnectWithoutCreatedByInput[];
    createMany?: RoleCreateManyCreatedByInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type UserLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>
      | UserLogCreateWithoutUserInput[]
      | UserLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLogCreateOrConnectWithoutUserInput
      | UserLogCreateOrConnectWithoutUserInput[];
    createMany?: UserLogCreateManyUserInputEnvelope;
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
  };

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>;
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type WorkflowRunCreateNestedManyWithoutTriggeredByInput = {
    create?:
      | XOR<
          WorkflowRunCreateWithoutTriggeredByInput,
          WorkflowRunUncheckedCreateWithoutTriggeredByInput
        >
      | WorkflowRunCreateWithoutTriggeredByInput[]
      | WorkflowRunUncheckedCreateWithoutTriggeredByInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput[];
    createMany?: WorkflowRunCreateManyTriggeredByInputEnvelope;
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
  };

  export type WorkflowCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
      | WorkflowCreateWithoutCreatedByInput[]
      | WorkflowUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatedByInput
      | WorkflowCreateOrConnectWithoutCreatedByInput[];
    createMany?: WorkflowCreateManyCreatedByInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type ApiActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
  };

  export type ApiUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
      | ApiUsageCreateWithoutUserInput[]
      | ApiUsageUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiUsageCreateOrConnectWithoutUserInput
      | ApiUsageCreateOrConnectWithoutUserInput[];
    createMany?: ApiUsageCreateManyUserInputEnvelope;
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
  };

  export type ApplicationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatedByInput, ApplicationUncheckedCreateWithoutCreatedByInput>
      | ApplicationCreateWithoutCreatedByInput[]
      | ApplicationUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatedByInput
      | ApplicationCreateOrConnectWithoutCreatedByInput[];
    createMany?: ApplicationCreateManyCreatedByInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type ConnectionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ConnectionCreateWithoutCreatedByInput, ConnectionUncheckedCreateWithoutCreatedByInput>
      | ConnectionCreateWithoutCreatedByInput[]
      | ConnectionUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ConnectionCreateOrConnectWithoutCreatedByInput
      | ConnectionCreateOrConnectWithoutCreatedByInput[];
    createMany?: ConnectionCreateManyCreatedByInputEnvelope;
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>
      | EndpointCreateWithoutCreatedByInput[]
      | EndpointUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatedByInput
      | EndpointCreateOrConnectWithoutCreatedByInput[];
    createMany?: EndpointCreateManyCreatedByInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type RoleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
      | RoleCreateWithoutCreatedByInput[]
      | RoleUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatedByInput
      | RoleCreateOrConnectWithoutCreatedByInput[];
    createMany?: RoleCreateManyCreatedByInputEnvelope;
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type UserLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>
      | UserLogCreateWithoutUserInput[]
      | UserLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLogCreateOrConnectWithoutUserInput
      | UserLogCreateOrConnectWithoutUserInput[];
    createMany?: UserLogCreateManyUserInputEnvelope;
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
  };

  export type WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput = {
    create?:
      | XOR<
          WorkflowRunCreateWithoutTriggeredByInput,
          WorkflowRunUncheckedCreateWithoutTriggeredByInput
        >
      | WorkflowRunCreateWithoutTriggeredByInput[]
      | WorkflowRunUncheckedCreateWithoutTriggeredByInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput[];
    createMany?: WorkflowRunCreateManyTriggeredByInputEnvelope;
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
  };

  export type WorkflowUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
      | WorkflowCreateWithoutCreatedByInput[]
      | WorkflowUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatedByInput
      | WorkflowCreateOrConnectWithoutCreatedByInput[];
    createMany?: WorkflowCreateManyCreatedByInputEnvelope;
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ApiActivityLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiUsageUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
      | ApiUsageCreateWithoutUserInput[]
      | ApiUsageUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiUsageCreateOrConnectWithoutUserInput
      | ApiUsageCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiUsageUpsertWithWhereUniqueWithoutUserInput
      | ApiUsageUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiUsageCreateManyUserInputEnvelope;
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    update?:
      | ApiUsageUpdateWithWhereUniqueWithoutUserInput
      | ApiUsageUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiUsageUpdateManyWithWhereWithoutUserInput
      | ApiUsageUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[];
  };

  export type ApplicationUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatedByInput, ApplicationUncheckedCreateWithoutCreatedByInput>
      | ApplicationCreateWithoutCreatedByInput[]
      | ApplicationUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatedByInput
      | ApplicationCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutCreatedByInput
      | ApplicationUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ApplicationCreateManyCreatedByInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutCreatedByInput
      | ApplicationUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutCreatedByInput
      | ApplicationUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type ConnectionUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ConnectionCreateWithoutCreatedByInput, ConnectionUncheckedCreateWithoutCreatedByInput>
      | ConnectionCreateWithoutCreatedByInput[]
      | ConnectionUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ConnectionCreateOrConnectWithoutCreatedByInput
      | ConnectionCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ConnectionUpsertWithWhereUniqueWithoutCreatedByInput
      | ConnectionUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ConnectionCreateManyCreatedByInputEnvelope;
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    update?:
      | ConnectionUpdateWithWhereUniqueWithoutCreatedByInput
      | ConnectionUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ConnectionUpdateManyWithWhereWithoutCreatedByInput
      | ConnectionUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[];
  };

  export type EndpointUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>
      | EndpointCreateWithoutCreatedByInput[]
      | EndpointUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatedByInput
      | EndpointCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutCreatedByInput
      | EndpointUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: EndpointCreateManyCreatedByInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutCreatedByInput
      | EndpointUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutCreatedByInput
      | EndpointUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
      | RoleCreateWithoutCreatedByInput[]
      | RoleUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatedByInput
      | RoleCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutCreatedByInput
      | RoleUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: RoleCreateManyCreatedByInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutCreatedByInput
      | RoleUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutCreatedByInput
      | RoleUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatedByInput
      | ServiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type UserLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>
      | UserLogCreateWithoutUserInput[]
      | UserLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLogCreateOrConnectWithoutUserInput
      | UserLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserLogUpsertWithWhereUniqueWithoutUserInput
      | UserLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserLogCreateManyUserInputEnvelope;
    set?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    disconnect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    delete?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    update?:
      | UserLogUpdateWithWhereUniqueWithoutUserInput
      | UserLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserLogUpdateManyWithWhereWithoutUserInput
      | UserLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserLogScalarWhereInput | UserLogScalarWhereInput[];
  };

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>;
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput;
    upsert?: OrganizationUpsertWithoutUsersInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>,
      OrganizationUncheckedUpdateWithoutUsersInput
    >;
  };

  export type WorkflowRunUpdateManyWithoutTriggeredByNestedInput = {
    create?:
      | XOR<
          WorkflowRunCreateWithoutTriggeredByInput,
          WorkflowRunUncheckedCreateWithoutTriggeredByInput
        >
      | WorkflowRunCreateWithoutTriggeredByInput[]
      | WorkflowRunUncheckedCreateWithoutTriggeredByInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput[];
    upsert?:
      | WorkflowRunUpsertWithWhereUniqueWithoutTriggeredByInput
      | WorkflowRunUpsertWithWhereUniqueWithoutTriggeredByInput[];
    createMany?: WorkflowRunCreateManyTriggeredByInputEnvelope;
    set?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    disconnect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    delete?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    update?:
      | WorkflowRunUpdateWithWhereUniqueWithoutTriggeredByInput
      | WorkflowRunUpdateWithWhereUniqueWithoutTriggeredByInput[];
    updateMany?:
      | WorkflowRunUpdateManyWithWhereWithoutTriggeredByInput
      | WorkflowRunUpdateManyWithWhereWithoutTriggeredByInput[];
    deleteMany?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
  };

  export type WorkflowUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
      | WorkflowCreateWithoutCreatedByInput[]
      | WorkflowUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatedByInput
      | WorkflowCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput
      | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: WorkflowCreateManyCreatedByInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput
      | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutCreatedByInput
      | WorkflowUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiActivityLogCreateWithoutUserInput, ApiActivityLogUncheckedCreateWithoutUserInput>
      | ApiActivityLogCreateWithoutUserInput[]
      | ApiActivityLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiActivityLogCreateOrConnectWithoutUserInput
      | ApiActivityLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiActivityLogCreateManyUserInputEnvelope;
    set?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    disconnect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    delete?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    connect?: ApiActivityLogWhereUniqueInput | ApiActivityLogWhereUniqueInput[];
    update?:
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput
      | ApiActivityLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput
      | ApiActivityLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
  };

  export type ApiUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>
      | ApiUsageCreateWithoutUserInput[]
      | ApiUsageUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiUsageCreateOrConnectWithoutUserInput
      | ApiUsageCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiUsageUpsertWithWhereUniqueWithoutUserInput
      | ApiUsageUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiUsageCreateManyUserInputEnvelope;
    set?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    disconnect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    delete?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    connect?: ApiUsageWhereUniqueInput | ApiUsageWhereUniqueInput[];
    update?:
      | ApiUsageUpdateWithWhereUniqueWithoutUserInput
      | ApiUsageUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiUsageUpdateManyWithWhereWithoutUserInput
      | ApiUsageUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[];
  };

  export type ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutCreatedByInput, ApplicationUncheckedCreateWithoutCreatedByInput>
      | ApplicationCreateWithoutCreatedByInput[]
      | ApplicationUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutCreatedByInput
      | ApplicationCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutCreatedByInput
      | ApplicationUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ApplicationCreateManyCreatedByInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutCreatedByInput
      | ApplicationUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutCreatedByInput
      | ApplicationUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ConnectionCreateWithoutCreatedByInput, ConnectionUncheckedCreateWithoutCreatedByInput>
      | ConnectionCreateWithoutCreatedByInput[]
      | ConnectionUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ConnectionCreateOrConnectWithoutCreatedByInput
      | ConnectionCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ConnectionUpsertWithWhereUniqueWithoutCreatedByInput
      | ConnectionUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ConnectionCreateManyCreatedByInputEnvelope;
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[];
    update?:
      | ConnectionUpdateWithWhereUniqueWithoutCreatedByInput
      | ConnectionUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ConnectionUpdateManyWithWhereWithoutCreatedByInput
      | ConnectionUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>
      | EndpointCreateWithoutCreatedByInput[]
      | EndpointUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutCreatedByInput
      | EndpointCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutCreatedByInput
      | EndpointUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: EndpointCreateManyCreatedByInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutCreatedByInput
      | EndpointUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutCreatedByInput
      | EndpointUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type RoleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>
      | RoleCreateWithoutCreatedByInput[]
      | RoleUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutCreatedByInput
      | RoleCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutCreatedByInput
      | RoleUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: RoleCreateManyCreatedByInputEnvelope;
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutCreatedByInput
      | RoleUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutCreatedByInput
      | RoleUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>
      | ServiceCreateWithoutCreatedByInput[]
      | ServiceUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCreatedByInput
      | ServiceCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput
      | ServiceUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: ServiceCreateManyCreatedByInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput
      | ServiceUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCreatedByInput
      | ServiceUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type UserLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>
      | UserLogCreateWithoutUserInput[]
      | UserLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserLogCreateOrConnectWithoutUserInput
      | UserLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserLogUpsertWithWhereUniqueWithoutUserInput
      | UserLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserLogCreateManyUserInputEnvelope;
    set?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    disconnect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    delete?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    connect?: UserLogWhereUniqueInput | UserLogWhereUniqueInput[];
    update?:
      | UserLogUpdateWithWhereUniqueWithoutUserInput
      | UserLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserLogUpdateManyWithWhereWithoutUserInput
      | UserLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserLogScalarWhereInput | UserLogScalarWhereInput[];
  };

  export type WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput = {
    create?:
      | XOR<
          WorkflowRunCreateWithoutTriggeredByInput,
          WorkflowRunUncheckedCreateWithoutTriggeredByInput
        >
      | WorkflowRunCreateWithoutTriggeredByInput[]
      | WorkflowRunUncheckedCreateWithoutTriggeredByInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput
      | WorkflowRunCreateOrConnectWithoutTriggeredByInput[];
    upsert?:
      | WorkflowRunUpsertWithWhereUniqueWithoutTriggeredByInput
      | WorkflowRunUpsertWithWhereUniqueWithoutTriggeredByInput[];
    createMany?: WorkflowRunCreateManyTriggeredByInputEnvelope;
    set?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    disconnect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    delete?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    update?:
      | WorkflowRunUpdateWithWhereUniqueWithoutTriggeredByInput
      | WorkflowRunUpdateWithWhereUniqueWithoutTriggeredByInput[];
    updateMany?:
      | WorkflowRunUpdateManyWithWhereWithoutTriggeredByInput
      | WorkflowRunUpdateManyWithWhereWithoutTriggeredByInput[];
    deleteMany?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
  };

  export type WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>
      | WorkflowCreateWithoutCreatedByInput[]
      | WorkflowUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | WorkflowCreateOrConnectWithoutCreatedByInput
      | WorkflowCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput
      | WorkflowUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: WorkflowCreateManyCreatedByInputEnvelope;
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[];
    update?:
      | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput
      | WorkflowUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | WorkflowUpdateManyWithWhereWithoutCreatedByInput
      | WorkflowUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
  };

  export type ConnectionCreatedatabasesInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutConnectionsInput = {
    create?: XOR<UserCreateWithoutConnectionsInput, UserUncheckedCreateWithoutConnectionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutConnectionInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ConnectionUpdatedatabasesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutConnectionsNestedInput = {
    create?: XOR<UserCreateWithoutConnectionsInput, UserUncheckedCreateWithoutConnectionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsInput;
    upsert?: UserUpsertWithoutConnectionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutConnectionsInput, UserUpdateWithoutConnectionsInput>,
      UserUncheckedUpdateWithoutConnectionsInput
    >;
  };

  export type ServiceUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutConnectionInput
      | ServiceUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>
      | ServiceCreateWithoutConnectionInput[]
      | ServiceUncheckedCreateWithoutConnectionInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutConnectionInput
      | ServiceCreateOrConnectWithoutConnectionInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput
      | ServiceUpsertWithWhereUniqueWithoutConnectionInput[];
    createMany?: ServiceCreateManyConnectionInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput
      | ServiceUpdateWithWhereUniqueWithoutConnectionInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutConnectionInput
      | ServiceUpdateManyWithWhereWithoutConnectionInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ApplicationCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ApplicationCreateWithoutServiceInput, ApplicationUncheckedCreateWithoutServiceInput>
      | ApplicationCreateWithoutServiceInput[]
      | ApplicationUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutServiceInput
      | ApplicationCreateOrConnectWithoutServiceInput[];
    createMany?: ApplicationCreateManyServiceInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type EndpointCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>
      | EndpointCreateWithoutServiceInput[]
      | EndpointUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutServiceInput
      | EndpointCreateOrConnectWithoutServiceInput[];
    createMany?: EndpointCreateManyServiceInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type ConnectionCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      ConnectionCreateWithoutServicesInput,
      ConnectionUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: ConnectionCreateOrConnectWithoutServicesInput;
    connect?: ConnectionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ApplicationUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ApplicationCreateWithoutServiceInput, ApplicationUncheckedCreateWithoutServiceInput>
      | ApplicationCreateWithoutServiceInput[]
      | ApplicationUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutServiceInput
      | ApplicationCreateOrConnectWithoutServiceInput[];
    createMany?: ApplicationCreateManyServiceInputEnvelope;
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>
      | EndpointCreateWithoutServiceInput[]
      | EndpointUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutServiceInput
      | EndpointCreateOrConnectWithoutServiceInput[];
    createMany?: EndpointCreateManyServiceInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ApplicationUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutServiceInput, ApplicationUncheckedCreateWithoutServiceInput>
      | ApplicationCreateWithoutServiceInput[]
      | ApplicationUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutServiceInput
      | ApplicationCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutServiceInput
      | ApplicationUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ApplicationCreateManyServiceInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutServiceInput
      | ApplicationUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutServiceInput
      | ApplicationUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type EndpointUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>
      | EndpointCreateWithoutServiceInput[]
      | EndpointUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutServiceInput
      | EndpointCreateOrConnectWithoutServiceInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutServiceInput
      | EndpointUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: EndpointCreateManyServiceInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutServiceInput
      | EndpointUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutServiceInput
      | EndpointUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type ConnectionUpdateOneWithoutServicesNestedInput = {
    create?: XOR<
      ConnectionCreateWithoutServicesInput,
      ConnectionUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: ConnectionCreateOrConnectWithoutServicesInput;
    upsert?: ConnectionUpsertWithoutServicesInput;
    disconnect?: ConnectionWhereInput | boolean;
    delete?: ConnectionWhereInput | boolean;
    connect?: ConnectionWhereUniqueInput;
    update?: XOR<
      XOR<ConnectionUpdateToOneWithWhereWithoutServicesInput, ConnectionUpdateWithoutServicesInput>,
      ConnectionUncheckedUpdateWithoutServicesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput;
    upsert?: UserUpsertWithoutServicesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>,
      UserUncheckedUpdateWithoutServicesInput
    >;
  };

  export type ApplicationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ApplicationCreateWithoutServiceInput, ApplicationUncheckedCreateWithoutServiceInput>
      | ApplicationCreateWithoutServiceInput[]
      | ApplicationUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ApplicationCreateOrConnectWithoutServiceInput
      | ApplicationCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ApplicationUpsertWithWhereUniqueWithoutServiceInput
      | ApplicationUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ApplicationCreateManyServiceInputEnvelope;
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[];
    update?:
      | ApplicationUpdateWithWhereUniqueWithoutServiceInput
      | ApplicationUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ApplicationUpdateManyWithWhereWithoutServiceInput
      | ApplicationUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>
      | EndpointCreateWithoutServiceInput[]
      | EndpointUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutServiceInput
      | EndpointCreateOrConnectWithoutServiceInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutServiceInput
      | EndpointUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: EndpointCreateManyServiceInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutServiceInput
      | EndpointUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutServiceInput
      | EndpointUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<
      ServiceCreateWithoutApplicationsInput,
      ServiceUncheckedCreateWithoutApplicationsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutApplicationsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type EndpointCreateNestedManyWithoutApplicationInput = {
    create?:
      | XOR<EndpointCreateWithoutApplicationInput, EndpointUncheckedCreateWithoutApplicationInput>
      | EndpointCreateWithoutApplicationInput[]
      | EndpointUncheckedCreateWithoutApplicationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutApplicationInput
      | EndpointCreateOrConnectWithoutApplicationInput[];
    createMany?: EndpointCreateManyApplicationInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type EndpointUncheckedCreateNestedManyWithoutApplicationInput = {
    create?:
      | XOR<EndpointCreateWithoutApplicationInput, EndpointUncheckedCreateWithoutApplicationInput>
      | EndpointCreateWithoutApplicationInput[]
      | EndpointUncheckedCreateWithoutApplicationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutApplicationInput
      | EndpointCreateOrConnectWithoutApplicationInput[];
    createMany?: EndpointCreateManyApplicationInputEnvelope;
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput;
    upsert?: UserUpsertWithoutApplicationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>,
      UserUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<
      ServiceCreateWithoutApplicationsInput,
      ServiceUncheckedCreateWithoutApplicationsInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutApplicationsInput;
    upsert?: ServiceUpsertWithoutApplicationsInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutApplicationsInput,
        ServiceUpdateWithoutApplicationsInput
      >,
      ServiceUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type EndpointUpdateManyWithoutApplicationNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutApplicationInput, EndpointUncheckedCreateWithoutApplicationInput>
      | EndpointCreateWithoutApplicationInput[]
      | EndpointUncheckedCreateWithoutApplicationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutApplicationInput
      | EndpointCreateOrConnectWithoutApplicationInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutApplicationInput
      | EndpointUpsertWithWhereUniqueWithoutApplicationInput[];
    createMany?: EndpointCreateManyApplicationInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutApplicationInput
      | EndpointUpdateWithWhereUniqueWithoutApplicationInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutApplicationInput
      | EndpointUpdateManyWithWhereWithoutApplicationInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type EndpointUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?:
      | XOR<EndpointCreateWithoutApplicationInput, EndpointUncheckedCreateWithoutApplicationInput>
      | EndpointCreateWithoutApplicationInput[]
      | EndpointUncheckedCreateWithoutApplicationInput[];
    connectOrCreate?:
      | EndpointCreateOrConnectWithoutApplicationInput
      | EndpointCreateOrConnectWithoutApplicationInput[];
    upsert?:
      | EndpointUpsertWithWhereUniqueWithoutApplicationInput
      | EndpointUpsertWithWhereUniqueWithoutApplicationInput[];
    createMany?: EndpointCreateManyApplicationInputEnvelope;
    set?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    disconnect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    delete?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    connect?: EndpointWhereUniqueInput | EndpointWhereUniqueInput[];
    update?:
      | EndpointUpdateWithWhereUniqueWithoutApplicationInput
      | EndpointUpdateWithWhereUniqueWithoutApplicationInput[];
    updateMany?:
      | EndpointUpdateManyWithWhereWithoutApplicationInput
      | EndpointUpdateManyWithWhereWithoutApplicationInput[];
    deleteMany?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
  };

  export type WorkflowRunCreateNestedManyWithoutWorkflowInput = {
    create?:
      | XOR<WorkflowRunCreateWithoutWorkflowInput, WorkflowRunUncheckedCreateWithoutWorkflowInput>
      | WorkflowRunCreateWithoutWorkflowInput[]
      | WorkflowRunUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutWorkflowInput
      | WorkflowRunCreateOrConnectWithoutWorkflowInput[];
    createMany?: WorkflowRunCreateManyWorkflowInputEnvelope;
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput;
    connect?: UserWhereUniqueInput;
  };

  export type WorkflowRunUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?:
      | XOR<WorkflowRunCreateWithoutWorkflowInput, WorkflowRunUncheckedCreateWithoutWorkflowInput>
      | WorkflowRunCreateWithoutWorkflowInput[]
      | WorkflowRunUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutWorkflowInput
      | WorkflowRunCreateOrConnectWithoutWorkflowInput[];
    createMany?: WorkflowRunCreateManyWorkflowInputEnvelope;
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
  };

  export type WorkflowRunUpdateManyWithoutWorkflowNestedInput = {
    create?:
      | XOR<WorkflowRunCreateWithoutWorkflowInput, WorkflowRunUncheckedCreateWithoutWorkflowInput>
      | WorkflowRunCreateWithoutWorkflowInput[]
      | WorkflowRunUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutWorkflowInput
      | WorkflowRunCreateOrConnectWithoutWorkflowInput[];
    upsert?:
      | WorkflowRunUpsertWithWhereUniqueWithoutWorkflowInput
      | WorkflowRunUpsertWithWhereUniqueWithoutWorkflowInput[];
    createMany?: WorkflowRunCreateManyWorkflowInputEnvelope;
    set?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    disconnect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    delete?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    update?:
      | WorkflowRunUpdateWithWhereUniqueWithoutWorkflowInput
      | WorkflowRunUpdateWithWhereUniqueWithoutWorkflowInput[];
    updateMany?:
      | WorkflowRunUpdateManyWithWhereWithoutWorkflowInput
      | WorkflowRunUpdateManyWithWhereWithoutWorkflowInput[];
    deleteMany?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput;
    upsert?: UserUpsertWithoutWorkflowsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutWorkflowsInput, UserUpdateWithoutWorkflowsInput>,
      UserUncheckedUpdateWithoutWorkflowsInput
    >;
  };

  export type WorkflowRunUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?:
      | XOR<WorkflowRunCreateWithoutWorkflowInput, WorkflowRunUncheckedCreateWithoutWorkflowInput>
      | WorkflowRunCreateWithoutWorkflowInput[]
      | WorkflowRunUncheckedCreateWithoutWorkflowInput[];
    connectOrCreate?:
      | WorkflowRunCreateOrConnectWithoutWorkflowInput
      | WorkflowRunCreateOrConnectWithoutWorkflowInput[];
    upsert?:
      | WorkflowRunUpsertWithWhereUniqueWithoutWorkflowInput
      | WorkflowRunUpsertWithWhereUniqueWithoutWorkflowInput[];
    createMany?: WorkflowRunCreateManyWorkflowInputEnvelope;
    set?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    disconnect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    delete?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    connect?: WorkflowRunWhereUniqueInput | WorkflowRunWhereUniqueInput[];
    update?:
      | WorkflowRunUpdateWithWhereUniqueWithoutWorkflowInput
      | WorkflowRunUpdateWithWhereUniqueWithoutWorkflowInput[];
    updateMany?:
      | WorkflowRunUpdateManyWithWhereWithoutWorkflowInput
      | WorkflowRunUpdateManyWithWhereWithoutWorkflowInput[];
    deleteMany?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutWorkflowRunsInput = {
    create?: XOR<UserCreateWithoutWorkflowRunsInput, UserUncheckedCreateWithoutWorkflowRunsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowRunsInput;
    connect?: UserWhereUniqueInput;
  };

  export type WorkflowCreateNestedOneWithoutWorkflowRunsInput = {
    create?: XOR<
      WorkflowCreateWithoutWorkflowRunsInput,
      WorkflowUncheckedCreateWithoutWorkflowRunsInput
    >;
    connectOrCreate?: WorkflowCreateOrConnectWithoutWorkflowRunsInput;
    connect?: WorkflowWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutWorkflowRunsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowRunsInput, UserUncheckedCreateWithoutWorkflowRunsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowRunsInput;
    upsert?: UserUpsertWithoutWorkflowRunsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutWorkflowRunsInput, UserUpdateWithoutWorkflowRunsInput>,
      UserUncheckedUpdateWithoutWorkflowRunsInput
    >;
  };

  export type WorkflowUpdateOneRequiredWithoutWorkflowRunsNestedInput = {
    create?: XOR<
      WorkflowCreateWithoutWorkflowRunsInput,
      WorkflowUncheckedCreateWithoutWorkflowRunsInput
    >;
    connectOrCreate?: WorkflowCreateOrConnectWithoutWorkflowRunsInput;
    upsert?: WorkflowUpsertWithoutWorkflowRunsInput;
    connect?: WorkflowWhereUniqueInput;
    update?: XOR<
      XOR<
        WorkflowUpdateToOneWithWhereWithoutWorkflowRunsInput,
        WorkflowUpdateWithoutWorkflowRunsInput
      >,
      WorkflowUncheckedUpdateWithoutWorkflowRunsInput
    >;
  };

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput;
    upsert?: UserUpsertWithoutRolesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>,
      UserUncheckedUpdateWithoutRolesInput
    >;
  };

  export type ApplicationCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<
      ApplicationCreateWithoutEndpointsInput,
      ApplicationUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: ApplicationCreateOrConnectWithoutEndpointsInput;
    connect?: ApplicationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<UserCreateWithoutEndpointsInput, UserUncheckedCreateWithoutEndpointsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutEndpointsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<ServiceCreateWithoutEndpointsInput, ServiceUncheckedCreateWithoutEndpointsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutEndpointsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type ApplicationUpdateOneWithoutEndpointsNestedInput = {
    create?: XOR<
      ApplicationCreateWithoutEndpointsInput,
      ApplicationUncheckedCreateWithoutEndpointsInput
    >;
    connectOrCreate?: ApplicationCreateOrConnectWithoutEndpointsInput;
    upsert?: ApplicationUpsertWithoutEndpointsInput;
    disconnect?: ApplicationWhereInput | boolean;
    delete?: ApplicationWhereInput | boolean;
    connect?: ApplicationWhereUniqueInput;
    update?: XOR<
      XOR<
        ApplicationUpdateToOneWithWhereWithoutEndpointsInput,
        ApplicationUpdateWithoutEndpointsInput
      >,
      ApplicationUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutEndpointsNestedInput = {
    create?: XOR<UserCreateWithoutEndpointsInput, UserUncheckedCreateWithoutEndpointsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutEndpointsInput;
    upsert?: UserUpsertWithoutEndpointsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutEndpointsInput, UserUpdateWithoutEndpointsInput>,
      UserUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutEndpointsNestedInput = {
    create?: XOR<ServiceCreateWithoutEndpointsInput, ServiceUncheckedCreateWithoutEndpointsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutEndpointsInput;
    upsert?: ServiceUpsertWithoutEndpointsInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutEndpointsInput, ServiceUpdateWithoutEndpointsInput>,
      ServiceUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type UserCreateNestedOneWithoutApiActivityLogsInput = {
    create?: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiActivityLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutApiActivityLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApiActivityLogsInput;
    upsert?: UserUpsertWithoutApiActivityLogsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutApiActivityLogsInput,
        UserUpdateWithoutApiActivityLogsInput
      >,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type UserCreateNestedOneWithoutApiUsageInput = {
    create?: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApiUsageInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutApiUsageNestedInput = {
    create?: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApiUsageInput;
    upsert?: UserUpsertWithoutApiUsageInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutApiUsageInput, UserUpdateWithoutApiUsageInput>,
      UserUncheckedUpdateWithoutApiUsageInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserCreateNestedOneWithoutUserLogsInput = {
    create?: XOR<UserCreateWithoutUserLogsInput, UserUncheckedCreateWithoutUserLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUserLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutUserLogsNestedInput = {
    create?: XOR<UserCreateWithoutUserLogsInput, UserUncheckedCreateWithoutUserLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUserLogsInput;
    upsert?: UserUpsertWithoutUserLogsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutUserLogsInput, UserUpdateWithoutUserLogsInput>,
      UserUncheckedUpdateWithoutUserLogsInput
    >;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type UserCreateWithoutOrganizationInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>;
  };

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput;
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>;
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>;
  };

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput;
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>;
  };

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput;
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    password?: StringNullableFilter<'User'> | string | null;
    firstName?: StringFilter<'User'> | string;
    lastName?: StringFilter<'User'> | string;
    phone?: StringNullableFilter<'User'> | string | null;
    phoneCarrier?: StringNullableFilter<'User'> | string | null;
    organizationId?: StringFilter<'User'> | string;
    role?: StringFilter<'User'> | string;
    accountSetupToken?: StringNullableFilter<'User'> | string | null;
    accountSetupTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
    twoFactorSecret?: StringNullableFilter<'User'> | string | null;
    twoFactorBackupCodes?: JsonNullableFilter<'User'>;
    twoFactorEnabledAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    twoFactorOTP?: JsonNullableFilter<'User'>;
    trustedDevices?: JsonNullableFilter<'User'>;
    isActive?: BoolFilter<'User'> | boolean;
    isEmailVerified?: BoolFilter<'User'> | boolean;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    loginAttempts?: IntFilter<'User'> | number;
    lockedUntil?: DateTimeNullableFilter<'User'> | Date | string | null;
    passwordResetToken?: StringNullableFilter<'User'> | string | null;
    passwordResetTokenExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
  };

  export type ApiActivityLogCreateWithoutUserInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type ApiActivityLogUncheckedCreateWithoutUserInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type ApiActivityLogCreateOrConnectWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    create: XOR<
      ApiActivityLogCreateWithoutUserInput,
      ApiActivityLogUncheckedCreateWithoutUserInput
    >;
  };

  export type ApiActivityLogCreateManyUserInputEnvelope = {
    data: ApiActivityLogCreateManyUserInput | ApiActivityLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ApiUsageCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiUsageUncheckedCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiUsageCreateOrConnectWithoutUserInput = {
    where: ApiUsageWhereUniqueInput;
    create: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>;
  };

  export type ApiUsageCreateManyUserInputEnvelope = {
    data: ApiUsageCreateManyUserInput | ApiUsageCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ApplicationCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutApplicationsInput;
    endpoints?: EndpointCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationCreateOrConnectWithoutCreatedByInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutCreatedByInput,
      ApplicationUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type ApplicationCreateManyCreatedByInputEnvelope = {
    data: ApplicationCreateManyCreatedByInput | ApplicationCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ConnectionCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    services?: ServiceCreateNestedManyWithoutConnectionInput;
  };

  export type ConnectionUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    services?: ServiceUncheckedCreateNestedManyWithoutConnectionInput;
  };

  export type ConnectionCreateOrConnectWithoutCreatedByInput = {
    where: ConnectionWhereUniqueInput;
    create: XOR<
      ConnectionCreateWithoutCreatedByInput,
      ConnectionUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type ConnectionCreateManyCreatedByInputEnvelope = {
    data: ConnectionCreateManyCreatedByInput | ConnectionCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type EndpointCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    application?: ApplicationCreateNestedOneWithoutEndpointsInput;
    service: ServiceCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    serviceId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointCreateOrConnectWithoutCreatedByInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>;
  };

  export type EndpointCreateManyCreatedByInputEnvelope = {
    data: EndpointCreateManyCreatedByInput | EndpointCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type RoleCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleCreateOrConnectWithoutCreatedByInput = {
    where: RoleWhereUniqueInput;
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>;
  };

  export type RoleCreateManyCreatedByInputEnvelope = {
    data: RoleCreateManyCreatedByInput | RoleCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointCreateNestedManyWithoutServiceInput;
    connection?: ConnectionCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type ServiceCreateManyCreatedByInputEnvelope = {
    data: ServiceCreateManyCreatedByInput | ServiceCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type UserLogCreateWithoutUserInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type UserLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type UserLogCreateOrConnectWithoutUserInput = {
    where: UserLogWhereUniqueInput;
    create: XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>;
  };

  export type UserLogCreateManyUserInputEnvelope = {
    data: UserLogCreateManyUserInput | UserLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type OrganizationCreateWithoutUsersInput = {
    id?: string;
    name: string;
    slug: string;
    isActive?: boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string;
    name: string;
    slug: string;
    isActive?: boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>;
  };

  export type WorkflowRunCreateWithoutTriggeredByInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    workflow: WorkflowCreateNestedOneWithoutWorkflowRunsInput;
  };

  export type WorkflowRunUncheckedCreateWithoutTriggeredByInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowRunCreateOrConnectWithoutTriggeredByInput = {
    where: WorkflowRunWhereUniqueInput;
    create: XOR<
      WorkflowRunCreateWithoutTriggeredByInput,
      WorkflowRunUncheckedCreateWithoutTriggeredByInput
    >;
  };

  export type WorkflowRunCreateManyTriggeredByInputEnvelope = {
    data: WorkflowRunCreateManyTriggeredByInput | WorkflowRunCreateManyTriggeredByInput[];
    skipDuplicates?: boolean;
  };

  export type WorkflowCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutWorkflowInput;
  };

  export type WorkflowCreateOrConnectWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput;
    create: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>;
  };

  export type WorkflowCreateManyCreatedByInputEnvelope = {
    data: WorkflowCreateManyCreatedByInput | WorkflowCreateManyCreatedByInput[];
    skipDuplicates?: boolean;
  };

  export type ApiActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    update: XOR<
      ApiActivityLogUpdateWithoutUserInput,
      ApiActivityLogUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ApiActivityLogCreateWithoutUserInput,
      ApiActivityLogUncheckedCreateWithoutUserInput
    >;
  };

  export type ApiActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiActivityLogWhereUniqueInput;
    data: XOR<ApiActivityLogUpdateWithoutUserInput, ApiActivityLogUncheckedUpdateWithoutUserInput>;
  };

  export type ApiActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ApiActivityLogScalarWhereInput;
    data: XOR<
      ApiActivityLogUpdateManyMutationInput,
      ApiActivityLogUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ApiActivityLogScalarWhereInput = {
    AND?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
    OR?: ApiActivityLogScalarWhereInput[];
    NOT?: ApiActivityLogScalarWhereInput | ApiActivityLogScalarWhereInput[];
    id?: StringFilter<'ApiActivityLog'> | string;
    method?: StringFilter<'ApiActivityLog'> | string;
    endpoint?: StringFilter<'ApiActivityLog'> | string;
    statusCode?: IntFilter<'ApiActivityLog'> | number;
    responseTime?: IntFilter<'ApiActivityLog'> | number;
    requestBody?: JsonNullableFilter<'ApiActivityLog'>;
    responseBody?: JsonNullableFilter<'ApiActivityLog'>;
    userAgent?: StringNullableFilter<'ApiActivityLog'> | string | null;
    ipAddress?: StringNullableFilter<'ApiActivityLog'> | string | null;
    userId?: StringFilter<'ApiActivityLog'> | string;
    organizationId?: StringFilter<'ApiActivityLog'> | string;
    createdAt?: DateTimeFilter<'ApiActivityLog'> | Date | string;
  };

  export type ApiUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiUsageWhereUniqueInput;
    update: XOR<ApiUsageUpdateWithoutUserInput, ApiUsageUncheckedUpdateWithoutUserInput>;
    create: XOR<ApiUsageCreateWithoutUserInput, ApiUsageUncheckedCreateWithoutUserInput>;
  };

  export type ApiUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiUsageWhereUniqueInput;
    data: XOR<ApiUsageUpdateWithoutUserInput, ApiUsageUncheckedUpdateWithoutUserInput>;
  };

  export type ApiUsageUpdateManyWithWhereWithoutUserInput = {
    where: ApiUsageScalarWhereInput;
    data: XOR<ApiUsageUpdateManyMutationInput, ApiUsageUncheckedUpdateManyWithoutUserInput>;
  };

  export type ApiUsageScalarWhereInput = {
    AND?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[];
    OR?: ApiUsageScalarWhereInput[];
    NOT?: ApiUsageScalarWhereInput | ApiUsageScalarWhereInput[];
    id?: StringFilter<'ApiUsage'> | string;
    endpoint?: StringFilter<'ApiUsage'> | string;
    method?: StringFilter<'ApiUsage'> | string;
    callCount?: IntFilter<'ApiUsage'> | number;
    totalResponseTime?: IntFilter<'ApiUsage'> | number;
    userId?: StringFilter<'ApiUsage'> | string;
    organizationId?: StringFilter<'ApiUsage'> | string;
    createdAt?: DateTimeFilter<'ApiUsage'> | Date | string;
    updatedAt?: DateTimeFilter<'ApiUsage'> | Date | string;
  };

  export type ApplicationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ApplicationWhereUniqueInput;
    update: XOR<
      ApplicationUpdateWithoutCreatedByInput,
      ApplicationUncheckedUpdateWithoutCreatedByInput
    >;
    create: XOR<
      ApplicationCreateWithoutCreatedByInput,
      ApplicationUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type ApplicationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ApplicationWhereUniqueInput;
    data: XOR<
      ApplicationUpdateWithoutCreatedByInput,
      ApplicationUncheckedUpdateWithoutCreatedByInput
    >;
  };

  export type ApplicationUpdateManyWithWhereWithoutCreatedByInput = {
    where: ApplicationScalarWhereInput;
    data: XOR<
      ApplicationUpdateManyMutationInput,
      ApplicationUncheckedUpdateManyWithoutCreatedByInput
    >;
  };

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
    OR?: ApplicationScalarWhereInput[];
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[];
    id?: StringFilter<'Application'> | string;
    name?: StringFilter<'Application'> | string;
    description?: StringNullableFilter<'Application'> | string | null;
    isActive?: BoolFilter<'Application'> | boolean;
    configuration?: JsonNullableFilter<'Application'>;
    createdById?: StringFilter<'Application'> | string;
    organizationId?: StringFilter<'Application'> | string;
    serviceId?: StringFilter<'Application'> | string;
    createdAt?: DateTimeFilter<'Application'> | Date | string;
    updatedAt?: DateTimeFilter<'Application'> | Date | string;
  };

  export type ConnectionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ConnectionWhereUniqueInput;
    update: XOR<
      ConnectionUpdateWithoutCreatedByInput,
      ConnectionUncheckedUpdateWithoutCreatedByInput
    >;
    create: XOR<
      ConnectionCreateWithoutCreatedByInput,
      ConnectionUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type ConnectionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ConnectionWhereUniqueInput;
    data: XOR<
      ConnectionUpdateWithoutCreatedByInput,
      ConnectionUncheckedUpdateWithoutCreatedByInput
    >;
  };

  export type ConnectionUpdateManyWithWhereWithoutCreatedByInput = {
    where: ConnectionScalarWhereInput;
    data: XOR<
      ConnectionUpdateManyMutationInput,
      ConnectionUncheckedUpdateManyWithoutCreatedByInput
    >;
  };

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[];
    OR?: ConnectionScalarWhereInput[];
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[];
    id?: StringFilter<'Connection'> | string;
    name?: StringFilter<'Connection'> | string;
    host?: StringFilter<'Connection'> | string;
    port?: IntFilter<'Connection'> | number;
    username?: StringFilter<'Connection'> | string;
    password?: StringFilter<'Connection'> | string;
    isActive?: BoolFilter<'Connection'> | boolean;
    failoverHost?: StringNullableFilter<'Connection'> | string | null;
    databases?: StringNullableListFilter<'Connection'>;
    createdById?: StringFilter<'Connection'> | string;
    organizationId?: StringFilter<'Connection'> | string;
    createdAt?: DateTimeFilter<'Connection'> | Date | string;
    updatedAt?: DateTimeFilter<'Connection'> | Date | string;
  };

  export type EndpointUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<EndpointUpdateWithoutCreatedByInput, EndpointUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<EndpointCreateWithoutCreatedByInput, EndpointUncheckedCreateWithoutCreatedByInput>;
  };

  export type EndpointUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<EndpointUpdateWithoutCreatedByInput, EndpointUncheckedUpdateWithoutCreatedByInput>;
  };

  export type EndpointUpdateManyWithWhereWithoutCreatedByInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type EndpointScalarWhereInput = {
    AND?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
    OR?: EndpointScalarWhereInput[];
    NOT?: EndpointScalarWhereInput | EndpointScalarWhereInput[];
    id?: StringFilter<'Endpoint'> | string;
    name?: StringFilter<'Endpoint'> | string;
    path?: StringFilter<'Endpoint'> | string;
    method?: StringFilter<'Endpoint'> | string;
    description?: StringNullableFilter<'Endpoint'> | string | null;
    isActive?: BoolFilter<'Endpoint'> | boolean;
    configuration?: JsonNullableFilter<'Endpoint'>;
    createdById?: StringFilter<'Endpoint'> | string;
    organizationId?: StringFilter<'Endpoint'> | string;
    serviceId?: StringFilter<'Endpoint'> | string;
    applicationId?: StringNullableFilter<'Endpoint'> | string | null;
    createdAt?: DateTimeFilter<'Endpoint'> | Date | string;
    updatedAt?: DateTimeFilter<'Endpoint'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    isRead?: BoolFilter<'Notification'> | boolean;
    data?: JsonNullableFilter<'Notification'>;
    userId?: StringFilter<'Notification'> | string;
    organizationId?: StringFilter<'Notification'> | string;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type RoleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput;
    update: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<RoleCreateWithoutCreatedByInput, RoleUncheckedCreateWithoutCreatedByInput>;
  };

  export type RoleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RoleWhereUniqueInput;
    data: XOR<RoleUpdateWithoutCreatedByInput, RoleUncheckedUpdateWithoutCreatedByInput>;
  };

  export type RoleUpdateManyWithWhereWithoutCreatedByInput = {
    where: RoleScalarWhereInput;
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[];
    OR?: RoleScalarWhereInput[];
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: StringFilter<'Role'> | string;
    description?: StringNullableFilter<'Role'> | string | null;
    permissions?: JsonFilter<'Role'>;
    isActive?: BoolFilter<'Role'> | boolean;
    createdById?: StringFilter<'Role'> | string;
    organizationId?: StringFilter<'Role'> | string;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
  };

  export type ServiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutCreatedByInput, ServiceUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<ServiceCreateWithoutCreatedByInput, ServiceUncheckedCreateWithoutCreatedByInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutCreatedByInput, ServiceUncheckedUpdateWithoutCreatedByInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    OR?: ServiceScalarWhereInput[];
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    label?: StringNullableFilter<'Service'> | string | null;
    description?: StringNullableFilter<'Service'> | string | null;
    host?: StringNullableFilter<'Service'> | string | null;
    port?: IntNullableFilter<'Service'> | number | null;
    database?: StringFilter<'Service'> | string;
    username?: StringNullableFilter<'Service'> | string | null;
    password?: StringNullableFilter<'Service'> | string | null;
    isActive?: BoolFilter<'Service'> | boolean;
    failoverHost?: StringNullableFilter<'Service'> | string | null;
    objects?: JsonFilter<'Service'>;
    createdById?: StringFilter<'Service'> | string;
    organizationId?: StringFilter<'Service'> | string;
    connectionId?: StringNullableFilter<'Service'> | string | null;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
  };

  export type UserLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLogWhereUniqueInput;
    update: XOR<UserLogUpdateWithoutUserInput, UserLogUncheckedUpdateWithoutUserInput>;
    create: XOR<UserLogCreateWithoutUserInput, UserLogUncheckedCreateWithoutUserInput>;
  };

  export type UserLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLogWhereUniqueInput;
    data: XOR<UserLogUpdateWithoutUserInput, UserLogUncheckedUpdateWithoutUserInput>;
  };

  export type UserLogUpdateManyWithWhereWithoutUserInput = {
    where: UserLogScalarWhereInput;
    data: XOR<UserLogUpdateManyMutationInput, UserLogUncheckedUpdateManyWithoutUserInput>;
  };

  export type UserLogScalarWhereInput = {
    AND?: UserLogScalarWhereInput | UserLogScalarWhereInput[];
    OR?: UserLogScalarWhereInput[];
    NOT?: UserLogScalarWhereInput | UserLogScalarWhereInput[];
    id?: StringFilter<'UserLog'> | string;
    action?: StringFilter<'UserLog'> | string;
    details?: JsonNullableFilter<'UserLog'>;
    ipAddress?: StringNullableFilter<'UserLog'> | string | null;
    userAgent?: StringNullableFilter<'UserLog'> | string | null;
    userId?: StringFilter<'UserLog'> | string;
    organizationId?: StringFilter<'UserLog'> | string;
    createdAt?: DateTimeFilter<'UserLog'> | Date | string;
  };

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>;
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput;
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>;
  };

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    settings?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunUpsertWithWhereUniqueWithoutTriggeredByInput = {
    where: WorkflowRunWhereUniqueInput;
    update: XOR<
      WorkflowRunUpdateWithoutTriggeredByInput,
      WorkflowRunUncheckedUpdateWithoutTriggeredByInput
    >;
    create: XOR<
      WorkflowRunCreateWithoutTriggeredByInput,
      WorkflowRunUncheckedCreateWithoutTriggeredByInput
    >;
  };

  export type WorkflowRunUpdateWithWhereUniqueWithoutTriggeredByInput = {
    where: WorkflowRunWhereUniqueInput;
    data: XOR<
      WorkflowRunUpdateWithoutTriggeredByInput,
      WorkflowRunUncheckedUpdateWithoutTriggeredByInput
    >;
  };

  export type WorkflowRunUpdateManyWithWhereWithoutTriggeredByInput = {
    where: WorkflowRunScalarWhereInput;
    data: XOR<
      WorkflowRunUpdateManyMutationInput,
      WorkflowRunUncheckedUpdateManyWithoutTriggeredByInput
    >;
  };

  export type WorkflowRunScalarWhereInput = {
    AND?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
    OR?: WorkflowRunScalarWhereInput[];
    NOT?: WorkflowRunScalarWhereInput | WorkflowRunScalarWhereInput[];
    id?: StringFilter<'WorkflowRun'> | string;
    status?: StringFilter<'WorkflowRun'> | string;
    startedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
    completedAt?: DateTimeNullableFilter<'WorkflowRun'> | Date | string | null;
    errorMessage?: StringNullableFilter<'WorkflowRun'> | string | null;
    executionData?: JsonNullableFilter<'WorkflowRun'>;
    workflowId?: StringFilter<'WorkflowRun'> | string;
    triggeredById?: StringFilter<'WorkflowRun'> | string;
    organizationId?: StringFilter<'WorkflowRun'> | string;
    createdAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
    updatedAt?: DateTimeFilter<'WorkflowRun'> | Date | string;
  };

  export type WorkflowUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput;
    update: XOR<WorkflowUpdateWithoutCreatedByInput, WorkflowUncheckedUpdateWithoutCreatedByInput>;
    create: XOR<WorkflowCreateWithoutCreatedByInput, WorkflowUncheckedCreateWithoutCreatedByInput>;
  };

  export type WorkflowUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WorkflowWhereUniqueInput;
    data: XOR<WorkflowUpdateWithoutCreatedByInput, WorkflowUncheckedUpdateWithoutCreatedByInput>;
  };

  export type WorkflowUpdateManyWithWhereWithoutCreatedByInput = {
    where: WorkflowScalarWhereInput;
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutCreatedByInput>;
  };

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
    OR?: WorkflowScalarWhereInput[];
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[];
    id?: StringFilter<'Workflow'> | string;
    name?: StringFilter<'Workflow'> | string;
    active?: BoolFilter<'Workflow'> | boolean;
    schedule?: StringNullableFilter<'Workflow'> | string | null;
    lastDatabaseCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    lastHubSpotCheck?: DateTimeNullableFilter<'Workflow'> | Date | string | null;
    nodes?: JsonFilter<'Workflow'>;
    edges?: JsonFilter<'Workflow'>;
    createdById?: StringFilter<'Workflow'> | string;
    organizationId?: StringFilter<'Workflow'> | string;
    createdAt?: DateTimeFilter<'Workflow'> | Date | string;
    updatedAt?: DateTimeFilter<'Workflow'> | Date | string;
  };

  export type UserCreateWithoutConnectionsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutConnectionsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutConnectionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutConnectionsInput, UserUncheckedCreateWithoutConnectionsInput>;
  };

  export type ServiceCreateWithoutConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointCreateNestedManyWithoutServiceInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutServiceInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>;
  };

  export type ServiceCreateManyConnectionInputEnvelope = {
    data: ServiceCreateManyConnectionInput | ServiceCreateManyConnectionInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutConnectionsInput = {
    update: XOR<UserUpdateWithoutConnectionsInput, UserUncheckedUpdateWithoutConnectionsInput>;
    create: XOR<UserCreateWithoutConnectionsInput, UserUncheckedCreateWithoutConnectionsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutConnectionsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutConnectionsInput, UserUncheckedUpdateWithoutConnectionsInput>;
  };

  export type UserUpdateWithoutConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type ServiceUpsertWithWhereUniqueWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutConnectionInput, ServiceUncheckedUpdateWithoutConnectionInput>;
    create: XOR<ServiceCreateWithoutConnectionInput, ServiceUncheckedCreateWithoutConnectionInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutConnectionInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutConnectionInput, ServiceUncheckedUpdateWithoutConnectionInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutConnectionInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutConnectionInput>;
  };

  export type ApplicationCreateWithoutServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApplicationsInput;
    endpoints?: EndpointCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutApplicationInput;
  };

  export type ApplicationCreateOrConnectWithoutServiceInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutServiceInput,
      ApplicationUncheckedCreateWithoutServiceInput
    >;
  };

  export type ApplicationCreateManyServiceInputEnvelope = {
    data: ApplicationCreateManyServiceInput | ApplicationCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type EndpointCreateWithoutServiceInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    application?: ApplicationCreateNestedOneWithoutEndpointsInput;
    createdBy: UserCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointCreateOrConnectWithoutServiceInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>;
  };

  export type EndpointCreateManyServiceInputEnvelope = {
    data: EndpointCreateManyServiceInput | EndpointCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ConnectionCreateWithoutServicesInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutConnectionsInput;
  };

  export type ConnectionUncheckedCreateWithoutServicesInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ConnectionCreateOrConnectWithoutServicesInput = {
    where: ConnectionWhereUniqueInput;
    create: XOR<
      ConnectionCreateWithoutServicesInput,
      ConnectionUncheckedCreateWithoutServicesInput
    >;
  };

  export type UserCreateWithoutServicesInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
  };

  export type ApplicationUpsertWithWhereUniqueWithoutServiceInput = {
    where: ApplicationWhereUniqueInput;
    update: XOR<
      ApplicationUpdateWithoutServiceInput,
      ApplicationUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ApplicationCreateWithoutServiceInput,
      ApplicationUncheckedCreateWithoutServiceInput
    >;
  };

  export type ApplicationUpdateWithWhereUniqueWithoutServiceInput = {
    where: ApplicationWhereUniqueInput;
    data: XOR<ApplicationUpdateWithoutServiceInput, ApplicationUncheckedUpdateWithoutServiceInput>;
  };

  export type ApplicationUpdateManyWithWhereWithoutServiceInput = {
    where: ApplicationScalarWhereInput;
    data: XOR<
      ApplicationUpdateManyMutationInput,
      ApplicationUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type EndpointUpsertWithWhereUniqueWithoutServiceInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<EndpointUpdateWithoutServiceInput, EndpointUncheckedUpdateWithoutServiceInput>;
    create: XOR<EndpointCreateWithoutServiceInput, EndpointUncheckedCreateWithoutServiceInput>;
  };

  export type EndpointUpdateWithWhereUniqueWithoutServiceInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<EndpointUpdateWithoutServiceInput, EndpointUncheckedUpdateWithoutServiceInput>;
  };

  export type EndpointUpdateManyWithWhereWithoutServiceInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutServiceInput>;
  };

  export type ConnectionUpsertWithoutServicesInput = {
    update: XOR<
      ConnectionUpdateWithoutServicesInput,
      ConnectionUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      ConnectionCreateWithoutServicesInput,
      ConnectionUncheckedCreateWithoutServicesInput
    >;
    where?: ConnectionWhereInput;
  };

  export type ConnectionUpdateToOneWithWhereWithoutServicesInput = {
    where?: ConnectionWhereInput;
    data: XOR<ConnectionUpdateWithoutServicesInput, ConnectionUncheckedUpdateWithoutServicesInput>;
  };

  export type ConnectionUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutConnectionsNestedInput;
  };

  export type ConnectionUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>;
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>;
  };

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateWithoutApplicationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>;
  };

  export type ServiceCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endpoints?: EndpointCreateNestedManyWithoutServiceInput;
    connection?: ConnectionCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutApplicationsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutApplicationsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutApplicationsInput,
      ServiceUncheckedCreateWithoutApplicationsInput
    >;
  };

  export type EndpointCreateWithoutApplicationInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutEndpointsInput;
    service: ServiceCreateNestedOneWithoutEndpointsInput;
  };

  export type EndpointUncheckedCreateWithoutApplicationInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointCreateOrConnectWithoutApplicationInput = {
    where: EndpointWhereUniqueInput;
    create: XOR<
      EndpointCreateWithoutApplicationInput,
      EndpointUncheckedCreateWithoutApplicationInput
    >;
  };

  export type EndpointCreateManyApplicationInputEnvelope = {
    data: EndpointCreateManyApplicationInput | EndpointCreateManyApplicationInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>;
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>;
  };

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type ServiceUpsertWithoutApplicationsInput = {
    update: XOR<
      ServiceUpdateWithoutApplicationsInput,
      ServiceUncheckedUpdateWithoutApplicationsInput
    >;
    create: XOR<
      ServiceCreateWithoutApplicationsInput,
      ServiceUncheckedCreateWithoutApplicationsInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutApplicationsInput,
      ServiceUncheckedUpdateWithoutApplicationsInput
    >;
  };

  export type ServiceUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endpoints?: EndpointUpdateManyWithoutServiceNestedInput;
    connection?: ConnectionUpdateOneWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endpoints?: EndpointUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type EndpointUpsertWithWhereUniqueWithoutApplicationInput = {
    where: EndpointWhereUniqueInput;
    update: XOR<
      EndpointUpdateWithoutApplicationInput,
      EndpointUncheckedUpdateWithoutApplicationInput
    >;
    create: XOR<
      EndpointCreateWithoutApplicationInput,
      EndpointUncheckedCreateWithoutApplicationInput
    >;
  };

  export type EndpointUpdateWithWhereUniqueWithoutApplicationInput = {
    where: EndpointWhereUniqueInput;
    data: XOR<
      EndpointUpdateWithoutApplicationInput,
      EndpointUncheckedUpdateWithoutApplicationInput
    >;
  };

  export type EndpointUpdateManyWithWhereWithoutApplicationInput = {
    where: EndpointScalarWhereInput;
    data: XOR<EndpointUpdateManyMutationInput, EndpointUncheckedUpdateManyWithoutApplicationInput>;
  };

  export type WorkflowRunCreateWithoutWorkflowInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    triggeredBy: UserCreateNestedOneWithoutWorkflowRunsInput;
  };

  export type WorkflowRunUncheckedCreateWithoutWorkflowInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    triggeredById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowRunCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowRunWhereUniqueInput;
    create: XOR<
      WorkflowRunCreateWithoutWorkflowInput,
      WorkflowRunUncheckedCreateWithoutWorkflowInput
    >;
  };

  export type WorkflowRunCreateManyWorkflowInputEnvelope = {
    data: WorkflowRunCreateManyWorkflowInput | WorkflowRunCreateManyWorkflowInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutWorkflowsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
  };

  export type UserUncheckedCreateWithoutWorkflowsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
  };

  export type UserCreateOrConnectWithoutWorkflowsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>;
  };

  export type WorkflowRunUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowRunWhereUniqueInput;
    update: XOR<
      WorkflowRunUpdateWithoutWorkflowInput,
      WorkflowRunUncheckedUpdateWithoutWorkflowInput
    >;
    create: XOR<
      WorkflowRunCreateWithoutWorkflowInput,
      WorkflowRunUncheckedCreateWithoutWorkflowInput
    >;
  };

  export type WorkflowRunUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowRunWhereUniqueInput;
    data: XOR<
      WorkflowRunUpdateWithoutWorkflowInput,
      WorkflowRunUncheckedUpdateWithoutWorkflowInput
    >;
  };

  export type WorkflowRunUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowRunScalarWhereInput;
    data: XOR<
      WorkflowRunUpdateManyMutationInput,
      WorkflowRunUncheckedUpdateManyWithoutWorkflowInput
    >;
  };

  export type UserUpsertWithoutWorkflowsInput = {
    update: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>;
    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>;
  };

  export type UserUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
  };

  export type UserUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
  };

  export type UserCreateWithoutWorkflowRunsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutWorkflowRunsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutWorkflowRunsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutWorkflowRunsInput, UserUncheckedCreateWithoutWorkflowRunsInput>;
  };

  export type WorkflowCreateWithoutWorkflowRunsInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutWorkflowsInput;
  };

  export type WorkflowUncheckedCreateWithoutWorkflowRunsInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowCreateOrConnectWithoutWorkflowRunsInput = {
    where: WorkflowWhereUniqueInput;
    create: XOR<
      WorkflowCreateWithoutWorkflowRunsInput,
      WorkflowUncheckedCreateWithoutWorkflowRunsInput
    >;
  };

  export type UserUpsertWithoutWorkflowRunsInput = {
    update: XOR<UserUpdateWithoutWorkflowRunsInput, UserUncheckedUpdateWithoutWorkflowRunsInput>;
    create: XOR<UserCreateWithoutWorkflowRunsInput, UserUncheckedCreateWithoutWorkflowRunsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWorkflowRunsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutWorkflowRunsInput, UserUncheckedUpdateWithoutWorkflowRunsInput>;
  };

  export type UserUpdateWithoutWorkflowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutWorkflowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type WorkflowUpsertWithoutWorkflowRunsInput = {
    update: XOR<
      WorkflowUpdateWithoutWorkflowRunsInput,
      WorkflowUncheckedUpdateWithoutWorkflowRunsInput
    >;
    create: XOR<
      WorkflowCreateWithoutWorkflowRunsInput,
      WorkflowUncheckedCreateWithoutWorkflowRunsInput
    >;
    where?: WorkflowWhereInput;
  };

  export type WorkflowUpdateToOneWithWhereWithoutWorkflowRunsInput = {
    where?: WorkflowWhereInput;
    data: XOR<
      WorkflowUpdateWithoutWorkflowRunsInput,
      WorkflowUncheckedUpdateWithoutWorkflowRunsInput
    >;
  };

  export type WorkflowUpdateWithoutWorkflowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutWorkflowsNestedInput;
  };

  export type WorkflowUncheckedUpdateWithoutWorkflowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutRolesInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>;
  };

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>;
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>;
  };

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type ApplicationCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutApplicationsInput;
    service: ServiceCreateNestedOneWithoutApplicationsInput;
  };

  export type ApplicationUncheckedCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApplicationCreateOrConnectWithoutEndpointsInput = {
    where: ApplicationWhereUniqueInput;
    create: XOR<
      ApplicationCreateWithoutEndpointsInput,
      ApplicationUncheckedCreateWithoutEndpointsInput
    >;
  };

  export type UserCreateWithoutEndpointsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutEndpointsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutEndpointsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutEndpointsInput, UserUncheckedCreateWithoutEndpointsInput>;
  };

  export type ServiceCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationCreateNestedManyWithoutServiceInput;
    connection?: ConnectionCreateNestedOneWithoutServicesInput;
    createdBy: UserCreateNestedOneWithoutServicesInput;
  };

  export type ServiceUncheckedCreateWithoutEndpointsInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    applications?: ApplicationUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutEndpointsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutEndpointsInput, ServiceUncheckedCreateWithoutEndpointsInput>;
  };

  export type ApplicationUpsertWithoutEndpointsInput = {
    update: XOR<
      ApplicationUpdateWithoutEndpointsInput,
      ApplicationUncheckedUpdateWithoutEndpointsInput
    >;
    create: XOR<
      ApplicationCreateWithoutEndpointsInput,
      ApplicationUncheckedCreateWithoutEndpointsInput
    >;
    where?: ApplicationWhereInput;
  };

  export type ApplicationUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: ApplicationWhereInput;
    data: XOR<
      ApplicationUpdateWithoutEndpointsInput,
      ApplicationUncheckedUpdateWithoutEndpointsInput
    >;
  };

  export type ApplicationUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApplicationsNestedInput;
    service?: ServiceUpdateOneRequiredWithoutApplicationsNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutEndpointsInput = {
    update: XOR<UserUpdateWithoutEndpointsInput, UserUncheckedUpdateWithoutEndpointsInput>;
    create: XOR<UserCreateWithoutEndpointsInput, UserUncheckedCreateWithoutEndpointsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutEndpointsInput, UserUncheckedUpdateWithoutEndpointsInput>;
  };

  export type UserUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type ServiceUpsertWithoutEndpointsInput = {
    update: XOR<ServiceUpdateWithoutEndpointsInput, ServiceUncheckedUpdateWithoutEndpointsInput>;
    create: XOR<ServiceCreateWithoutEndpointsInput, ServiceUncheckedCreateWithoutEndpointsInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutEndpointsInput, ServiceUncheckedUpdateWithoutEndpointsInput>;
  };

  export type ServiceUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutServiceNestedInput;
    connection?: ConnectionUpdateOneWithoutServicesNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type UserCreateWithoutApiActivityLogsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutApiActivityLogsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutApiActivityLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
  };

  export type UserUpsertWithoutApiActivityLogsInput = {
    update: XOR<
      UserUpdateWithoutApiActivityLogsInput,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
    create: XOR<
      UserCreateWithoutApiActivityLogsInput,
      UserUncheckedCreateWithoutApiActivityLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApiActivityLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutApiActivityLogsInput,
      UserUncheckedUpdateWithoutApiActivityLogsInput
    >;
  };

  export type UserUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutApiActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateWithoutApiUsageInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutApiUsageInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutApiUsageInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>;
  };

  export type UserUpsertWithoutApiUsageInput = {
    update: XOR<UserUpdateWithoutApiUsageInput, UserUncheckedUpdateWithoutApiUsageInput>;
    create: XOR<UserCreateWithoutApiUsageInput, UserUncheckedCreateWithoutApiUsageInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApiUsageInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutApiUsageInput, UserUncheckedUpdateWithoutApiUsageInput>;
  };

  export type UserUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutApiUsageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogCreateNestedManyWithoutUserInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    userLogs?: UserLogUncheckedCreateNestedManyWithoutUserInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateWithoutUserLogsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageCreateNestedManyWithoutUserInput;
    applications?: ApplicationCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    roles?: RoleCreateNestedManyWithoutCreatedByInput;
    services?: ServiceCreateNestedManyWithoutCreatedByInput;
    organization: OrganizationCreateNestedOneWithoutUsersInput;
    workflowRuns?: WorkflowRunCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowCreateNestedManyWithoutCreatedByInput;
  };

  export type UserUncheckedCreateWithoutUserLogsInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    organizationId: string;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedCreateNestedManyWithoutUserInput;
    apiUsage?: ApiUsageUncheckedCreateNestedManyWithoutUserInput;
    applications?: ApplicationUncheckedCreateNestedManyWithoutCreatedByInput;
    connections?: ConnectionUncheckedCreateNestedManyWithoutCreatedByInput;
    endpoints?: EndpointUncheckedCreateNestedManyWithoutCreatedByInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    roles?: RoleUncheckedCreateNestedManyWithoutCreatedByInput;
    services?: ServiceUncheckedCreateNestedManyWithoutCreatedByInput;
    workflowRuns?: WorkflowRunUncheckedCreateNestedManyWithoutTriggeredByInput;
    workflows?: WorkflowUncheckedCreateNestedManyWithoutCreatedByInput;
  };

  export type UserCreateOrConnectWithoutUserLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutUserLogsInput, UserUncheckedCreateWithoutUserLogsInput>;
  };

  export type UserUpsertWithoutUserLogsInput = {
    update: XOR<UserUpdateWithoutUserLogsInput, UserUncheckedUpdateWithoutUserLogsInput>;
    create: XOR<UserCreateWithoutUserLogsInput, UserUncheckedCreateWithoutUserLogsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUserLogsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutUserLogsInput, UserUncheckedUpdateWithoutUserLogsInput>;
  };

  export type UserUpdateWithoutUserLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutUserLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserCreateManyOrganizationInput = {
    id?: string;
    email: string;
    password?: string | null;
    firstName: string;
    lastName: string;
    phone?: string | null;
    phoneCarrier?: string | null;
    role?: string;
    accountSetupToken?: string | null;
    accountSetupTokenExpires?: Date | string | null;
    twoFactorSecret?: string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isEmailVerified?: boolean;
    lastLoginAt?: Date | string | null;
    loginAttempts?: number;
    lockedUntil?: Date | string | null;
    passwordResetToken?: string | null;
    passwordResetTokenExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    roles?: RoleUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    apiActivityLogs?: ApiActivityLogUncheckedUpdateManyWithoutUserNestedInput;
    apiUsage?: ApiUsageUncheckedUpdateManyWithoutUserNestedInput;
    applications?: ApplicationUncheckedUpdateManyWithoutCreatedByNestedInput;
    connections?: ConnectionUncheckedUpdateManyWithoutCreatedByNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutCreatedByNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    roles?: RoleUncheckedUpdateManyWithoutCreatedByNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutCreatedByNestedInput;
    userLogs?: UserLogUncheckedUpdateManyWithoutUserNestedInput;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutTriggeredByNestedInput;
    workflows?: WorkflowUncheckedUpdateManyWithoutCreatedByNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneCarrier?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    accountSetupToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accountSetupTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue;
    twoFactorEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    twoFactorOTP?: NullableJsonNullValueInput | InputJsonValue;
    trustedDevices?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    loginAttempts?: IntFieldUpdateOperationsInput | number;
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogCreateManyUserInput = {
    id?: string;
    method: string;
    endpoint: string;
    statusCode: number;
    responseTime: number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: string | null;
    ipAddress?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type ApiUsageCreateManyUserInput = {
    id?: string;
    endpoint: string;
    method: string;
    callCount?: number;
    totalResponseTime?: number;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApplicationCreateManyCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ConnectionCreateManyCreatedByInput = {
    id?: string;
    name: string;
    host: string;
    port: number;
    username: string;
    password: string;
    isActive?: boolean;
    failoverHost?: string | null;
    databases?: ConnectionCreatedatabasesInput | string[];
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointCreateManyCreatedByInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    serviceId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    isRead?: boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleCreateManyCreatedByInput = {
    id?: string;
    name: string;
    description?: string | null;
    permissions: JsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceCreateManyCreatedByInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    connectionId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserLogCreateManyUserInput = {
    id?: string;
    action: string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    organizationId: string;
    createdAt?: Date | string;
  };

  export type WorkflowRunCreateManyTriggeredByInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowCreateManyCreatedByInput = {
    id?: string;
    name: string;
    active?: boolean;
    schedule?: string | null;
    lastDatabaseCheck?: Date | string | null;
    lastHubSpotCheck?: Date | string | null;
    nodes: JsonNullValueInput | InputJsonValue;
    edges: JsonNullValueInput | InputJsonValue;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApiActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    statusCode?: IntFieldUpdateOperationsInput | number;
    responseTime?: IntFieldUpdateOperationsInput | number;
    requestBody?: NullableJsonNullValueInput | InputJsonValue;
    responseBody?: NullableJsonNullValueInput | InputJsonValue;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    callCount?: IntFieldUpdateOperationsInput | number;
    totalResponseTime?: IntFieldUpdateOperationsInput | number;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApplicationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutApplicationsNestedInput;
    endpoints?: EndpointUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endpoints?: EndpointUncheckedUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ConnectionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    services?: ServiceUpdateManyWithoutConnectionNestedInput;
  };

  export type ConnectionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    services?: ServiceUncheckedUpdateManyWithoutConnectionNestedInput;
  };

  export type ConnectionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    host?: StringFieldUpdateOperationsInput | string;
    port?: IntFieldUpdateOperationsInput | number;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    databases?: ConnectionUpdatedatabasesInput | string[];
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    application?: ApplicationUpdateOneWithoutEndpointsNestedInput;
    service?: ServiceUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    data?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    permissions?: JsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUpdateManyWithoutServiceNestedInput;
    connection?: ConnectionUpdateOneWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUncheckedUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunUpdateWithoutTriggeredByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    workflow?: WorkflowUpdateOneRequiredWithoutWorkflowRunsNestedInput;
  };

  export type WorkflowRunUncheckedUpdateWithoutTriggeredByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunUncheckedUpdateManyWithoutTriggeredByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    workflowId?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    workflowRuns?: WorkflowRunUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    workflowRuns?: WorkflowRunUncheckedUpdateManyWithoutWorkflowNestedInput;
  };

  export type WorkflowUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    schedule?: NullableStringFieldUpdateOperationsInput | string | null;
    lastDatabaseCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    lastHubSpotCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nodes?: JsonNullValueInput | InputJsonValue;
    edges?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceCreateManyConnectionInput = {
    id?: string;
    name: string;
    label?: string | null;
    description?: string | null;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: string | null;
    isActive?: boolean;
    failoverHost?: string | null;
    objects: JsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUpdateManyWithoutServiceNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    applications?: ApplicationUncheckedUpdateManyWithoutServiceNestedInput;
    endpoints?: EndpointUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    host?: NullableStringFieldUpdateOperationsInput | string | null;
    port?: NullableIntFieldUpdateOperationsInput | number | null;
    database?: StringFieldUpdateOperationsInput | string;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    failoverHost?: NullableStringFieldUpdateOperationsInput | string | null;
    objects?: JsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApplicationCreateManyServiceInput = {
    id?: string;
    name: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointCreateManyServiceInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    applicationId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ApplicationUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutApplicationsNestedInput;
    endpoints?: EndpointUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endpoints?: EndpointUncheckedUpdateManyWithoutApplicationNestedInput;
  };

  export type ApplicationUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    application?: ApplicationUpdateOneWithoutEndpointsNestedInput;
    createdBy?: UserUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointCreateManyApplicationInput = {
    id?: string;
    name: string;
    path: string;
    method: string;
    description?: string | null;
    isActive?: boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById: string;
    organizationId: string;
    serviceId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EndpointUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutEndpointsNestedInput;
    service?: ServiceUpdateOneRequiredWithoutEndpointsNestedInput;
  };

  export type EndpointUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EndpointUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    path?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    configuration?: NullableJsonNullValueInput | InputJsonValue;
    createdById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunCreateManyWorkflowInput = {
    id?: string;
    status: string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    errorMessage?: string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    triggeredById: string;
    organizationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type WorkflowRunUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    triggeredBy?: UserUpdateOneRequiredWithoutWorkflowRunsNestedInput;
  };

  export type WorkflowRunUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    triggeredById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WorkflowRunUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    executionData?: NullableJsonNullValueInput | InputJsonValue;
    triggeredById?: StringFieldUpdateOperationsInput | string;
    organizationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
